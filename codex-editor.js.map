{"version":3,"sources":["webpack:///codex-editor.js","webpack:///webpack/bootstrap 286dd833be57efe302e0","webpack:///./codex.js","webpack:///./modules/core.js","webpack:///./modules/tools.js","webpack:///./modules/ui.js","webpack:///./modules/transport.js","webpack:///./modules/renderer.js","webpack:///./modules/saver.js","webpack:///./modules/content.js","webpack:///./modules/toolbar/toolbar.js","webpack:///./modules/toolbar/settings.js","webpack:///./modules/toolbar/inline.js","webpack:///./modules/toolbar/toolbox.js","webpack:///./modules/callbacks.js","webpack:///./modules/draw.js","webpack:///./modules/caret.js","webpack:///./modules/notifications.js","webpack:///./modules/parser.js","webpack:///./modules/sanitizer.js","webpack:///./~/html-janitor/src/html-janitor.js","webpack:///./modules/listeners.js","webpack:///./modules/destroyer.js","webpack:///./modules/paste.js"],"names":["codex","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","userSettings","self","this","version","scriptPrefix","core","tools","ui","transport","renderer","saver","content","toolbar","callback","draw","caret","notifications","parser","sanitizer","listeners","destroyer","paste","settings","holderId","initialBlockPlugin","nodes","holder","wrapper","inlineToolbar","buttons","actions","toolbox","plusButton","showSettingsButton","showTrashButton","blockSettings","pluginSettings","defaultSettings","toolbarButtons","redactor","state","jsonOutput","blocks","inputs","start","userSettings_","prepare","then","makeBlocksFromData","saveInputs","catch","error","log","save","_typeof","Symbol","iterator","obj","constructor","prototype","editor","Promise","resolve","reject","data","hideToolbar","placeholder","document","getElementById","undefined","Error","msg","type","arg","window","console","e","insertAfter","target","element","parentNode","insertBefore","nextSibling","nodeTypes","TAG","TEXT","COMMENT","DOCUMENT_FRAGMENT","keys","BACKSPACE","TAB","ENTER","SHIFT","CTRL","ALT","ESC","SPACE","LEFT","UP","DOWN","RIGHT","DELETE","META","isDomNode","el","nodeType","isEmpty","Object","length","ajax","url","encodedString","isFormData","prop","XMLHTTP","XMLHttpRequest","ActiveXObject","async","test","encodeURIComponent","withCredentials","responseContext","beforeSendResult","beforeSend","open","isFormData_","setRequestHeader","progress","upload","onprogress","bind","onreadystatechange","readyState","status","success","responseText","send","importScript","scriptPath","instanceName","script","createElement","defer","onload","onerror","src","head","appendChild","object","FormData","isNativeInput","nativeInputAreas","indexOf","tagName","isBlockEmpty","block","EXCEPTION_TAGS","nativeInputs","querySelectorAll","nativeInputsAreEmpty","textContentIsEmpty","textContent","trim","Array","forEach","input","value","includes","resolve_","reject_","pluginsRequiresPreparation","allPlugins","pluginName","plugin","push","waitAllPluginsPreparation_","plugins","allPluginsProcessed__","reduce","previousValue","iteration","pluginIsReady__","callPluginsPrepareMethod_","available","loadingMessage","config","className","BLOCK_CLASSNAME","BLOCK_CONTENT","BLOCK_STRETCHED","BLOCK_HIGHLIGHTED","SETTINGS_ITEM","makeToolBar_","addTools_","makeInlineToolbar_","addInlineToolbarTools_","makeNotificationHolder_","bindEvents_","container","inlineToolbarButtons","inlineToolbarActions","blockButtons","makeToolbarSettings_","toolbarContent","makeToolbarContent_","settingsButton","makeRemoveBlockButton","pluginsSettings","createHolder","tool","toolName","toolButton","toolInstance","instance","iconClassname","displayInToolbox","render","toolbarButton","bold","icon","command","italic","link","name","toolbarButtonInline","setInlineToolbarButtonBehaviour","add","globalKeydown","redactorKeyDown","globalKeyup","redactorClicked","plusButtonClicked","showSettingsButtonClicked","button","toolbarButtonClicked","addBlockHandlers","blockKeydown","blockPasteCallback","inline","show","map","current","addInitialBlock","initialBlock","initialBlockType","makeBlockFromData","setAttribute","insertBlock","workingNodeChanged","event","toolClicked","currentRequest","arguments","node","fileSelected","clearInput","i","files","formData","multiple","append","selectAndUpload","args","accept","click","abort","blockData","DOMElement","items","appendBlocks","blocksData","index","all","elements","appendNodeAtIndex","nodeSequence","getNodeAsync","createBlockFromData","toolData","unavailableBlock","innerHTML","dataset","inputPosition","position","stretched","isStretched","html","saveBlocks","childNodes","getBlockData","makeOutput","saveBlockData","validateBlockData","blockContent","pluginsContent","_ref","validate","result","savedData","filter","time","Date","currentNode","editorAreaHightlighted","sync","markBlock","classList","clearMark","remove","getFirstLevelBlock","body","contains","targetNode","replaceBlock","targetBlock","newBlock","replaceChild","needPlaceCaret","workingBlock","newBlockContent","blockType","composeNewBlock_","currentInputIndex","getCurrentInputIndex","editableElement","querySelector","emptyText","createTextNode","set","move","showPlusButton","setTimeout","setToNextBlock","switchBlock","blockToReplace","newBlockComposed","getDeepestTextNodeFromPosition","text","blockChilds","removeChild","lookingFromStart","getRange","selection","getSelection","getRangeAt","splitBlock","inputIndex","textBeforeCaret","textNodeBeforeCaret","textAfterCaret","textNodeAfterCaret","anchorNode","anchorNodeText","caretOffset","anchorOffset","currentBlock","substring","previousChilds","nextChilds","reachedCurrent","child","previousChildsLength","nextChildsLength","newNode","NEW_BLOCK_TYPE","mergeBlocks","targetInputIndex","targetInput","currentInputContent","isLastNode","allChecked","allSiblingsEmpty_","sibling","wrapTextWithParagraphs","htmlData","plainData","wrapPlainTextWithParagraphs","paragraph","blockTyped","newWrapper","firstLevelBlocks","cloneNode","plainText","split","join","getEditableParent","contentEditable","clear","load","articleData","currentContent","assign","concat","defaultToolbarHeight","defaultOffset","opened","makeSettings","close","toggle","hidePlusButton","newYCoordinate","offsetTop","style","transform","Math","floor","hideRemoveActions","setting","settingsBlock","removeBlockWrapper","settingButton","actionWrapper","confirmAction","cancelAction","removeButtonClicked","confirmRemovingRequest","cancelRemovingRequest","action","showRemoveActions","firstLevelBlocksCount","buttonsOpened","actionsOpened","wrappersOffset","storedSelection","showInlineToolbar","selectedText","getSelectionText","showButtons","getWrappersOffset","newCoordinateX","newCoordinateY","coords","getSelectionCoords","offsetHeight","x","left","y","scrollY","top","closeButtons","closeAction","createLinkAction","defaultToolAction","hightlight","offset","getOffset","_x","_y","isNaN","offsetLeft","clientLeft","clientTop","offsetParent","range","sel","createRange","collapse","boundingLeft","boundingTop","rangeCount","cloneRange","getClientRects","rect","toString","showActions","inlineToolbarAnchorInputKeydown_","keyCode","editable","restoreSelection","setAnchor","preventDefault","stopImmediatePropagation","clearRange","isActive","isLinkActive","saveSelection","inputForLink","focus","dataType","execCommand","containerEl","preSelectionRange","selectNodeContents","setEnd","startContainer","startOffset","end","savedSel","charIndex","setStart","nextCharIndex","nodeStack","foundStart","stop","pop","removeAllRanges","addRange","queryCommandState","setButtonHighlighted","removeButtonsHighLight","tag","openedOnBlock","leaf","currentTool","barButtons","nextToolIndex","toolToSelect","visibleTool","appendCallback","UNREPLACEBLE_TOOLS","workingNode","setToBlock","callbacks","enterKeyPressed_","tabKeyPressedOnRedactorsZone_","enterKeyPressedOnRedactorsZone_","escapeKeyPressedOnRedactorsZone_","defaultKeyPressedOnRedactorsZone_","arrowKeyPressed_","enterPressedOnBlock_","saveCurrentInputIndex","isEnterPressedOnToolbar","enableLineBreaks","stopPropagation","shiftKey","currentSelection","currentSelectedNode","caretAtTheEndOfText","atTheEnd","isTextNodeHasParentBetweenContenteditable","enterPressedOnBlock","islastNode","detectWhenClickedOnFirstLevelBlockArea_","firstLevelBlock","indexOfLastInput","inputIsEmpty","currentNodeType","isInitialType","flag","blockRightOrDownArrowPressed_","backspacePressed_","blockLeftOrUpArrowPressed_","focusedNodeHolder","focusedNode","editableElementIndex","lastChild","deepestTextnode","caretInLastChild","firstChild","caretInFirstChild","caretAtTheBeginning","setToPreviousBlock","selectionLength","endOffset","atStart","ceBlock","bar","div","toggler","classname","toolIcon","toolTitle","properties","focusedNodeIndex","nodeToSet","childs","nextInput","emptyTextElement","lastChildNode","lengthOfLastChildNode","previousInput","pluginsRender","isFirstNode","isOffsetZero","insertNode","lastNode","deleteContents","setStartAfter","queue","addToQueue","splice","errorThrown","errorMsg","notification","message","constructorSettings","create","okBtn","cancelBtn","okMsg","cancelMsg","confirmHandler","cancelHandler","confirm","cancel","inputField","insertPastedContent","isFirstLevelBlock","janitor","Config","CUSTOM","BASIC","tags","a","href","rel","init_","userCustomConfig","configuration","clean","dirtyString","customConfig","janitorInstance","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","HTMLJanitor","tagDefinitions","validConfigValues","k","every","isBlockElement","blockElementNames","nodeName","isInlineElement","inlineElementNames","createTreeWalker","NodeFilter","SHOW_TEXT","SHOW_ELEMENT","SHOW_COMMENT","getAllowedAttrs","shouldRejectNode","allowedAttrs","shouldRejectAttr","attr","attrName","toLowerCase","sandbox","_sanitize","treeWalker","_sanitized","Node","TEXT_NODE","COMMENT_NODE","containsBlockElement","isInline","some","isNotTopContainer","isNestedBlockElement","isInvalid","keepNestedBlockElements","attributes","removeAttribute","previousElementSibling","nextElementSibling","allListeners","search","byElement","context","listenersOnElement","listener","byType","eventType","listenersWithType","byHandler","handler","listenersWithHandler","one","isCapture","addEventListener","alreadyAddedListener","removeEventListener","existingListeners","removeAll","get","removeNodes","destroyPlugins","destroy","destroyScripts","scripts","getElementsByTagName","patterns","renderOnPastePatterns","isArray","pattern","pasted","clipBoardData","clipboardData","getData","analize","string","execArray","regex","exec","match","pasteToNewBlock_","needsToHandlePasteEvent","cleanData","wrappedData","paragraphs","emulateUserAgentBehaviour","insertPastedParagraphs","editableParent","childElementCount","createDocumentFragment"],"mappings":"AAAA,GAAIA,OAAQA,SAAaA,OAAc,OAC9B,SAAUC,GCGnB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDOM,SAAUI,EAAQD,EAASH,GAEhC,YExCDI,GAAOD,QAAW,SAAUQ,GAIxB,GAAIC,GAAOC,IAEXD,GAAKE,QAAU,QACfF,EAAKG,aAAe,cAIpBH,EAAKb,SACDiB,KAAMhB,EAAQ,GACdiB,MAAOjB,EAAQ,GACfkB,GAAIlB,EAAQ,GACZmB,UAAWnB,EAAQ,GACnBoB,SAAUpB,EAAQ,GAClBqB,MAAOrB,EAAQ,GACfsB,QAAStB,EAAQ,GACjBuB,QAASvB,EAAQ,GACjBwB,SAAUxB,EAAQ,IAClByB,KAAMzB,EAAQ,IACd0B,MAAO1B,EAAQ,IACf2B,cAAe3B,EAAQ,IACvB4B,OAAQ5B,EAAQ,IAChB6B,UAAW7B,EAAQ,IACnB8B,UAAW9B,EAAQ,IACnB+B,UAAW/B,EAAQ,IACnBgC,MAAOhC,EAAQ,IAGnB,KAAK,GAAII,KAAUQ,GAAKb,QAEpBa,EAAKb,QAAQK,GAAUQ,EAAKb,QAAQK,GAAQG,KAAKK,EAgHrD,OAvGAA,GAAKqB,UACDhB,OAAa,YAAa,SAAU,UAAW,OAAQ,QAAS,OAAQ,UAAW,YAAa,SAChGiB,SAAY,eAGZC,mBAAoB,aAQxBvB,EAAKwB,OACDC,OAAoB,KACpBC,QAAoB,KACpBf,QAAoB,KACpBgB,eACID,QAAU,KACVE,QAAU,KACVC,QAAU,MAEdC,QAAoB,KACpBf,cAAoB,KACpBgB,WAAoB,KACpBC,mBAAoB,KACpBC,gBAAoB,KACpBC,cAAoB,KACpBC,eAAoB,KACpBC,gBAAoB,KACpBC,kBACAC,SAAoB,MAQxBtC,EAAKuC,OACDC,cACAC,UACAC,WAOJ1C,EAAKK,SAgCLL,EAAK2C,MAAQ,SAAUC,GAEnB5C,EAAKb,QAAQiB,KAAKyC,QAAQD,GAGrBE,KAAK9C,EAAKb,QAAQmB,GAAGuC,SAErBC,KAAK9C,EAAKb,QAAQ8B,UAAU4B,SAC5BC,KAAK9C,EAAKb,QAAQiC,MAAMyB,SACxBC,KAAK9C,EAAKb,QAAQoB,UAAUsC,SAC5BC,KAAK9C,EAAKb,QAAQqB,SAASuC,oBAC3BD,KAAK9C,EAAKb,QAAQmB,GAAG0C,YACrBC,MAAM,SAAUC,GAEblD,EAAKb,QAAQiB,KAAK+C,IAAI,uCAAwC,OAAQD,MAMlFlD,EAAK2C,MAAM5C,IAEHqD,KAAMpD,EAAKb,QAAQsB,MAAM2C,QF2C/B,SAAU5D,EAAQD,GAEvB,YAEA,IAAI8D,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,QAAUE,IAAQF,OAAOI,UAAY,eAAkBF,GGhMvQhE,GAAOD,QAAW,WAEd,GAAIa,MAEAuD,EAAS1D,IAQbG,GAAKyC,QAAU,SAAU9C,GAErB,MAAO,IAAI6D,SAAQ,SAAUC,EAASC,GAE7B/D,IAED4D,EAAOtC,SAAShB,MAAQN,EAAaM,OAASsD,EAAOtC,SAAShB,OAI9DN,EAAagE,OAEbJ,EAAOpB,MAAME,OAAS1C,EAAagE,MAInChE,EAAawB,qBAEboC,EAAOtC,SAASE,mBAAqBxB,EAAawB,oBAIlDxB,EAAakB,YAEb0C,EAAOtC,SAASJ,UAAYlB,EAAakB,WAI7C0C,EAAOK,YAAcjE,EAAaiE,YAElCL,EAAOtC,SAAS4C,YAAclE,EAAakE,aAAe,GAE1DN,EAAOnC,MAAMC,OAASyC,SAASC,eAAepE,EAAauB,UAAYqC,EAAOtC,SAASC,UAEpD8C,SAA/Bf,EAAOM,EAAOnC,MAAMC,SAAgD,OAAxBkC,EAAOnC,MAAMC,OAEzDqC,EAAOO,MAAM,+BAAiCtE,EAAauB,WAI3DuC,OAYZzD,EAAK+C,IAAM,SAAUmB,EAAKC,EAAMC,GAE5BD,EAAOA,GAAQ,MAEVC,EAODF,EAAO,wBAA0BA,GALjCE,EAAOF,GAAO,YACdA,EAAO,0BAQX,KAES,WAAaG,SAAUA,OAAOC,QAASH,KAEnCC,EAAMC,OAAOC,QAASH,GAAQD,EAAKE,GACnCC,OAAOC,QAASH,GAAQD,IAIpC,MAAMK,MASXvE,EAAKwE,YAAc,SAAUC,EAAQC,GAEjCD,EAAOE,WAAWC,aAAaF,EAASD,EAAOI,cASnD7E,EAAK8E,WACDC,IAAU,EACVC,KAAU,EACVC,QAAU,EACVC,kBAAmB,IAOvBlF,EAAKmF,MAASC,UAAW,EAAGC,IAAK,EAAGC,MAAO,GAAIC,MAAO,GAAIC,KAAM,GAAIC,IAAK,GAAIC,IAAK,GAAIC,MAAO,GAAIC,KAAM,GAAIC,GAAI,GAAIC,KAAM,GAAIC,MAAO,GAAIC,OAAQ,GAAIC,KAAM,IAO1JjG,EAAKkG,UAAY,SAAUC,GAEvB,MAAOA,IAAoB,YAAd,mBAAOA,GAAP,YAAAlD,EAAOkD,KAAmBA,EAAGC,UAAYD,EAAGC,UAAYvG,KAAKiF,UAAUC,KASxF/E,EAAKqG,QAAU,SAAWjD,GAEtB,MAAmC,KAA5BkD,OAAOnB,KAAK/B,GAAKmD,QAW5BvG,EAAKwG,KAAO,SAAUvF,GAElB,GAAKA,GAAaA,EAASwF,IAA3B,CAMA,GACIC,GACAC,EACAC,EAHAC,EAAUxC,OAAOyC,eAAiB,GAAIA,gBAAmB,GAAIC,eAAc,oBAW/E,IALA9F,EAAS+F,OAAkB,EAC3B/F,EAASkD,KAAkBlD,EAASkD,MAAQ,MAC5ClD,EAAS0C,KAAkB1C,EAAS0C,MAAQ,GAC5C1C,EAAS,gBAAkBA,EAAS,iBAAmB,kCAElC,OAAjBA,EAASkD,MAAiBlD,EAAS0C,KAEnC1C,EAASwF,IAAM,KAAKQ,KAAKhG,EAASwF,KAAOxF,EAASwF,IAAM,IAAMxF,EAAS0C,KAAO1C,EAASwF,IAAM,IAAMxF,EAAS0C,SAEzG,CAEH+C,EAAgB,EAChB,KAAIE,IAAQ3F,GAAS0C,KAEjB+C,GAAkBE,EAAO,IAAMM,mBAAmBjG,EAAS0C,KAAKiD,IAAS,IAM7E3F,EAASkG,kBAETN,EAAQM,iBAAkB,EAQ9B,IAAIC,UACAC,QAEJ,IAAmC,kBAAxBpG,GAASqG,aAEhBD,EAAmBpG,EAASqG,WAAW/H,OAEnC8H,KAAqB,GA6E7B,MArEAR,GAAQU,KAAMtG,EAASkD,KAAMlD,EAASwF,IAAKxF,EAAS+F,OAKpDL,EAAaa,EAAYvG,EAAS0C,MAE7BgD,IAEqB,SAAlB1F,EAASkD,KAET0C,EAAQY,iBAAiB,eAAgBxG,EAAS,iBAIlD4F,EAAQY,iBAAiB,eAAgB,sCAMjDZ,EAAQY,iBAAiB,mBAAoB,kBAE7CL,EAAkBC,GAAoBR,EAEL,kBAAtB5F,GAASyG,WAEhBb,EAAQc,OAAOC,WAAa3G,EAASyG,SAASG,KAAKT,IAIvDP,EAAQiB,mBAAqB,WAEE,IAAvBjB,EAAQkB,aAEe,MAAnBlB,EAAQmB,OAEwB,kBAArB/G,GAASgH,SAEhBhH,EAASgH,QAAQ1I,KAAK6H,EAAiBP,EAAQqB,cAMrB,kBAAnBjH,GAAS6B,OAEhB7B,EAAS6B,MAAMvD,KAAK6H,EAAiBP,EAAQqB,aAAcrB,EAAQmB,UAU/ErB,EAGAE,EAAQsB,KAAKlH,EAAS0C,MAKtBkD,EAAQsB,KAAKzB,GAIVG,IAQX7G,EAAKoI,aAAe,SAAUC,EAAYC,GAEtC,MAAO,IAAI9E,SAAQ,SAAUC,EAASC,GAElC,GAAI6E,SAGED,GAIMxE,SAASC,eAAeR,EAAOxD,aAAeuI,IAEtD7E,EAAQ4E,GAJR3E,EAAO,2BAQX6E,EAASzE,SAAS0E,cAAc,UAChCD,EAAOvB,OAAQ,EACfuB,EAAOE,OAAQ,EACfF,EAAOlJ,GAAKkE,EAAOxD,aAAeuI,EAElCC,EAAOG,OAAS,WAEZjF,EAAQ4E,IAIZE,EAAOI,QAAU,WAEbjF,EAAO2E,IAIXE,EAAOK,IAAMP,EACbvE,SAAS+E,KAAKC,YAAYP,KAWlC,IAAIf,GAAc,SAAUuB,GAExB,MAAOA,aAAkBC,UA+C7B,OAtCAhJ,GAAKiJ,cAAgB,SAAUxE,GAE3B,GAAIyE,IAAoB,QAAS,WAEjC,OAAOA,GAAiBC,QAAQ1E,EAAO2E,WAAY,GAWvDpJ,EAAKqJ,aAAe,SAAUC,GAE1B,GAAMC,IAAkB,MAAO,UAE3BC,EAAuBF,EAAMG,iBAAiB,mBAC9CC,GAAuB,EACvBC,GAAwBL,EAAMM,YAAYC,MAY9C,OAVAC,OAAMxG,UAAUyG,QAAQxK,KAAKiK,EAAc,SAAUQ,GAE/B,YAAdA,EAAM7F,MAAoC,QAAd6F,EAAM7F,OAElCuF,EAAuBA,IAAyBM,EAAMC,MAAMJ,UAM7DF,GAAsBD,IAAyBH,EAAeW,SAASZ,EAAMF,UAKjFpJ,IH4JL,SAAUZ,EAAQD,GAEvB,YI/hBDC,GAAOD,QAAW,WASd,QAASsD,KAEL,MAAO,IAAIe,SAAQ,SAAU2G,EAAUC,GAEnC5G,QAAQC,UAKHf,KAAK,WAEF,GAAI2H,MACAC,EAAa/G,EAAOtD,KAExB,KAAM,GAAIsK,KAAcD,GAAa,CAEjC,GAAIE,GAASF,EAAWC,EAEpBC,GAAO/H,SAAqC,kBAAnB+H,GAAO/H,UAA2B+H,EAAO/H,SAMtE4H,EAA2BI,KAAKD,GAapC,MANKH,GAA2B9D,QAE5B4D,IAIGE,IAKV3H,KAAKgI,GAELhI,KAAK,WAEFa,EAAOxE,QAAQiB,KAAK+C,IAAI,iBAAkB,QAC1CoH,MAEDtH,MAAM,SAAUC,GAEfsH,EAAQtH,OAYxB,QAAS4H,GAA2BC,GAKhC,MAAO,IAAInH,SAAS,SAAUoH,GAW1BD,EAAQE,OAAO,SAAUC,EAAeN,EAAQO,GAE5C,MAAOD,GAAcpI,KAAK,WAMtB,MAAO,IAAIc,SAAU,SAAUwH,GAE3BC,EAA2BT,GAEtB9H,KAAMsI,GACNtI,KAAM,WAEH8H,EAAOU,WAAY,IAItBrI,MAAM,SAAUC,GAEbS,EAAOxE,QAAQiB,KAAK+C,IAApB,WAAmCyH,EAAOrG,KAA1C,kDAAiG,OAAQrB,GACzG0H,EAAOU,WAAY,EACnBV,EAAOW,eAAiBrI,EAGxBkI,MAIHtI,KAAK,WAGEqI,GAAaJ,EAAQpE,OAAS,GAE9BqE,WAUrBpH,QAAQC,aAnInB,GAAIF,GAAS1D,KAyIToL,EAA4B,SAAUT,GAEtC,MAAOA,GAAO/H,QAAS+H,EAAOY,YAIlC,QACI3I,QAASA,KJ+gBX,SAAUrD,EAAQD,GAEvB,YK/pBDC,GAAOD,QAAW,WAEd,GAAIe,MAEAqD,EAAS1D,IAKbK,GAAGmL,WAKCC,gBAAkB,WAKlBC,cAAgB,oBAKhBC,gBAAkB,sBAKlBC,kBAAoB,oBAKpBC,cAAgB,qBASpBxL,EAAGuC,QAAU,WAET,MAAO,IAAIe,SAAQ,SAAUC,GAEzB,GAAInC,GAAWiC,EAAOxE,QAAQ0B,KAAKa,UAC/BY,EAAWqB,EAAOxE,QAAQ0B,KAAKyB,WAC/B3B,EAAWoL,GAEfrK,GAAQwH,YAAYvI,GACpBe,EAAQwH,YAAY5G,GAGpBqB,EAAOnC,MAAME,QAAWA,EACxBiC,EAAOnC,MAAMc,SAAWA,EAGxBqB,EAAOnC,MAAMC,OAAOyH,YAAYxH,GAEhCmC,MAKHf,KAAKkJ,GAGLlJ,KAAKmJ,GAGLnJ,KAAKoJ,GAGLpJ,KAAKqJ,GAGLrJ,KAAKsJ,GAELnJ,MAAO,SAAU0B,GAEdhB,EAAOxE,QAAQiB,KAAK+C,IAAI,iCAAkC,OAAQwB,KAU1E,IAAIsH,GAAqB,WAErB,GAAII,GAAY1I,EAAOxE,QAAQ0B,KAAKc,eAGpCgC,GAAOnC,MAAMG,cAAcD,QAAU2K,EAGrC1I,EAAOnC,MAAMG,cAAcC,QAAU+B,EAAOxE,QAAQ0B,KAAKyL,uBAGzD3I,EAAOnC,MAAMG,cAAcE,QAAU8B,EAAOxE,QAAQ0B,KAAK0L,uBAGzD5I,EAAOnC,MAAMG,cAAcD,QAAQwH,YAAYvF,EAAOnC,MAAMG,cAAcC,SAC1E+B,EAAOnC,MAAMG,cAAcD,QAAQwH,YAAYvF,EAAOnC,MAAMG,cAAcE,SAE1E8B,EAAOnC,MAAME,QAAQwH,YAAYvF,EAAOnC,MAAMG,cAAcD,UAI5DqK,EAAe,WAEf,GAAIpL,GAAkBgD,EAAOxE,QAAQ0B,KAAKF,UACtC6L,EAAkBC,IAClBC,EAAkBC,GAWtB,OARAhM,GAAQuI,YAAYsD,GAGpB7L,EAAQuI,YAAYwD,GAGpB/I,EAAOnC,MAAMb,QAAUA,EAEhBA,GAIPgM,EAAsB,WAEtB,GAAID,GAAiB/I,EAAOxE,QAAQ0B,KAAK6L,iBACrC5K,EAAiB6B,EAAOxE,QAAQ0B,KAAKiB,UACrCC,EAAiB4B,EAAOxE,QAAQ0B,KAAKkB,YAYzC,OATA2K,GAAexD,YAAYnH,GAG3B2K,EAAexD,YAAYpH,GAG3B6B,EAAOnC,MAAMM,QAAaA,EAC1B6B,EAAOnC,MAAMO,WAAaA,EAEnB2K,GAIPD,EAAuB,WAEvB,GAAIvK,GAAsByB,EAAOxE,QAAQ0B,KAAKqB,gBAC1CsK,EAAsB7I,EAAOxE,QAAQ0B,KAAK2L,eAC1CpK,EAAsBuB,EAAOxE,QAAQ0B,KAAKuB,kBAC1CJ,EAAsB2B,EAAOxE,QAAQ0B,KAAK+L,iBAC1C3K,EAAsB0B,EAAOxE,QAAQwB,QAAQU,SAASwL,wBACtD1K,EAAsBwB,EAAOxE,QAAQ0B,KAAKiM,iBAqB9C,OAlBA5K,GAAcgH,YAAY/G,GAC1BD,EAAcgH,YAAY9G,GAM1BoK,EAAatD,YAAYlH,GACzBwK,EAAatD,YAAYjH,GACzBuK,EAAatD,YAAYhH,GAGzByB,EAAOnC,MAAMU,cAAqBA,EAClCyB,EAAOnC,MAAMW,eAAqBA,EAClCwB,EAAOnC,MAAMY,gBAAqBA,EAClCuB,EAAOnC,MAAMQ,mBAAqBA,EAClC2B,EAAOnC,MAAMS,gBAAqBA,EAE3BuK,GAKPL,EAA0B,WAG1BxI,EAAOnC,MAAMT,cAAgB4C,EAAOxE,QAAQ4B,cAAcgM,gBAQ1Df,EAAY,WAEZ,GAAIgB,GACAC,EACAC,CAEJ,KAAMD,IAAYtJ,GAAOtC,SAAShB,MAAQ,CAEtC2M,EAAOrJ,EAAOtC,SAAShB,MAAM4M,GAE7BtJ,EAAOtD,MAAM4M,GAAYD,CACzB,IAAIG,GAAeH,EAAKI,UAEnBJ,GAAKK,gBAAiBL,EAAKM,iBAOE,kBAAvBH,GAAaI,OAOnBP,EAAKM,mBAONJ,EAAavJ,EAAOxE,QAAQ0B,KAAK2M,cAAcP,EAAUD,EAAKK,eAE9D1J,EAAOnC,MAAMM,QAAQoH,YAAYgE,GAEjCvJ,EAAOnC,MAAMa,eAAe4K,GAAYC,GAhBxCvJ,EAAOxE,QAAQiB,KAAK+C,IAAI,wCAAyC,OAAQ8J,GAPzEtJ,EAAOxE,QAAQiB,KAAK+C,IAAI,iDAAkD,OAAQ8J,KA+B1Ff,EAAyB,WAEzB,GAkBIgB,GACAF,EAnBA3M,GAEAoN,MACIC,KAAU,eACVC,QAAU,QAGdC,QACIF,KAAU,iBACVC,QAAU,UAGdE,MACIH,KAAU,eACVC,QAAU,cAOlB,KAAI,GAAIG,KAAQzN,GAEZ2M,EAAO3M,EAAMyN,GAEbZ,EAAavJ,EAAOxE,QAAQ0B,KAAKkN,oBAAoBD,EAAMd,EAAKU,MAEhE/J,EAAOnC,MAAMG,cAAcC,QAAQsH,YAAYgE,GAI/CvJ,EAAOxE,QAAQmB,GAAG0N,gCAAgCd,EAAYF,EAAKW,UAUvEvB,EAAc,WAEdzI,EAAOxE,QAAQiB,KAAK+C,IAAI,sBAAuB,QAO/CQ,EAAOxE,QAAQ+B,UAAU+M,IAAI/J,SAAU,UAAWP,EAAOxE,QAAQyB,SAASsN,eAAe,GAGzFvK,EAAOxE,QAAQ+B,UAAU+M,IAAItK,EAAOnC,MAAMc,SAAU,UAAWqB,EAAOxE,QAAQyB,SAASuN,iBAAiB,GAGxGxK,EAAOxE,QAAQ+B,UAAU+M,IAAI/J,SAAU,QAASP,EAAOxE,QAAQyB,SAASwN,aAAa,GAKrFzK,EAAOxE,QAAQ+B,UAAU+M,IAAItK,EAAOnC,MAAMc,SAAU,QAASqB,EAAOxE,QAAQyB,SAASyN,iBAAiB,GAKtG1K,EAAOxE,QAAQ+B,UAAU+M,IAAItK,EAAOnC,MAAMO,WAAY,QAAS4B,EAAOxE,QAAQyB,SAAS0N,mBAAmB,GAK1G3K,EAAOxE,QAAQ+B,UAAU+M,IAAItK,EAAOnC,MAAMQ,mBAAoB,QAAS2B,EAAOxE,QAAQyB,SAAS2N,2BAA2B,EAG1H,KAAK,GAAIC,KAAU7K,GAAOnC,MAAMa,eAE5BsB,EAAOxE,QAAQ+B,UAAU+M,IAAItK,EAAOnC,MAAMa,eAAemM,GAAS,QAAS7K,EAAOxE,QAAQyB,SAAS6N,sBAAsB,GAwGjI,OAlGAnO,GAAGoO,iBAAmB,SAAUhF,GAEvBA,IAKL/F,EAAOxE,QAAQ+B,UAAU+M,IAAIvE,EAAO,UAAW/F,EAAOxE,QAAQyB,SAAS+N,cAAc,GAqBrFhL,EAAOxE,QAAQ+B,UAAU+M,IAAIvE,EAAO,QAAS/F,EAAOxE,QAAQiC,MAAMwN,oBAAoB,GAKtFjL,EAAOxE,QAAQ+B,UAAU+M,IAAIvE,EAAO,UAAW/F,EAAOxE,QAAQwB,QAAQkO,OAAOC,MAAM,GACnFnL,EAAOxE,QAAQ+B,UAAU+M,IAAIvE,EAAO,QAAS/F,EAAOxE,QAAQwB,QAAQkO,OAAOC,MAAM,KAKrFxO,EAAG0C,WAAa,WAEZ,GAAIV,GAAWqB,EAAOnC,MAAMc,QAE5BqB,GAAOpB,MAAMG,SAGb,IAAIA,GAASJ,EAASuH,iBAAiB,qCAEvCK,OAAMxG,UAAUqL,IAAIpP,KAAK+C,EAAQ,SAAUsM,GAElCA,EAAQzK,MAAwB,QAAhByK,EAAQzK,MAAkC,YAAhByK,EAAQzK,MAEnDZ,EAAOpB,MAAMG,OAAOmI,KAAKmE,MAWrC1O,EAAG2O,gBAAkB,WAEjB,GACIC,GADAC,EAAmBxL,EAAOtC,SAASE,kBAGvC,OAAMoC,GAAOtD,MAAM8O,IAOnBD,EAAevL,EAAOxE,QAAQqB,SAAS4O,mBAAmB7K,KAAM4K,IAEhED,EAAaG,aAAa,mBAAoB1L,EAAOtC,SAAS4C,aAE9DN,EAAOxE,QAAQuB,QAAQ4O,aACnB/K,KAAQ4K,EACRzF,MAAQwF,QAGZvL,GAAOxE,QAAQuB,QAAQ6O,mBAAmBL,QAdtCvL,GAAOxE,QAAQiB,KAAK+C,IAAI,mEAAqE,OAAQgM,IAkB7G7O,EAAG0N,gCAAkC,SAAUQ,EAAQjK,GAEnDZ,EAAOxE,QAAQ+B,UAAU+M,IAAIO,EAAQ,YAAa,SAAUgB,GAExD7L,EAAOxE,QAAQwB,QAAQkO,OAAOY,YAAYD,EAAOjL,KAElD,IAIAjE,IL8oBL,SAAUd,EAAQD,GAEvB,YMvjCDC,GAAOD,QAAW,WAEd,GAAIgB,MAEAoD,EAAS1D,KAMTyP,EAAiB,IAqHrB,OA/GAnP,GAAU6J,MAAQ,KAKlB7J,EAAUoP,UAAY,KAKtBpP,EAAUsC,QAAU,WAEhB,GAAIuH,GAAQzG,EAAOxE,QAAQ0B,KAAK+O,KAAM,QAAS,IAAMrL,KAAO,QAE5DZ,GAAOxE,QAAQ+B,UAAU+M,IAAI7D,EAAO,SAAUzG,EAAOxE,QAAQoB,UAAUsP,cACvElM,EAAOxE,QAAQoB,UAAU6J,MAAQA,GAKrC7J,EAAUuP,WAAa,WAGnBvP,EAAU6J,MAAQ,KAGlB7J,EAAUsC,WAQdtC,EAAUsP,aAAe,WAErB,GACIE,GADA3F,EAAcnK,KAEd+P,EAAc5F,EAAM4F,MACpBC,EAAa,GAAI7G,SAErB,IAAIzF,EAAOxE,QAAQoB,UAAUoP,UAAUO,YAAa,EAEhD,IAAMH,EAAI,EAAGA,EAAIC,EAAMrJ,OAAQoJ,IAE3BE,EAASE,OAAO,UAAWH,EAAMD,GAAIC,EAAMD,GAAGjC,UAMlDmC,GAASE,OAAO,QAASH,EAAM,GAAIA,EAAM,GAAGlC,KAIhD4B,GAAiB/L,EAAOvD,KAAKwG,MACzBrC,KAAO,OACPR,KAAOkM,EACPpJ,IAAalD,EAAOxE,QAAQoB,UAAUoP,UAAU9I,IAChDa,WAAa/D,EAAOxE,QAAQoB,UAAUoP,UAAUjI,WAChDW,QAAa1E,EAAOxE,QAAQoB,UAAUoP,UAAUtH,QAChDnF,MAAaS,EAAOxE,QAAQoB,UAAUoP,UAAUzM,MAChD4E,SAAanE,EAAOxE,QAAQoB,UAAUoP,UAAU7H,WAIpDvH,EAAUuP,cAiBdvP,EAAU6P,gBAAkB,SAAUC,GAElC9P,EAAUoP,UAAYU,EAEjBA,EAAKH,YAAa,GAEnB3P,EAAU6J,MAAMiF,aAAa,WAAY,YAIxCgB,EAAKC,QAEN/P,EAAU6J,MAAMiF,aAAa,SAAUgB,EAAKC,QAIhD/P,EAAU6J,MAAMmG,SAIpBhQ,EAAUiQ,MAAQ,WAEdd,EAAec,QAEfd,EAAiB,MAIdnP,IN0jCL,SAAUf,EAAQD,GAEvB,YO5rCDC,GAAOD,QAAW,WAqLd,QAAS6P,GAAkBqB,GAEvB,GAAIxD,GAAWwD,EAAUlM,KACrBR,EAAO0M,EAAU1M,IAErB,IAAKJ,EAAOtD,MAAM4M,GAAlB,CAOA,GAAID,GAAOrJ,EAAOtD,MAAM4M,GAEpBE,EAAeH,EAAKI,UAExB,IAAkC,kBAAvBD,GAAaI,OAAxB,CAOA,GAAImD,GAAavD,EAAaI,OAAOxJ,EAIrC,OAFA2M,GAAW1D,KAAOG,EAEXuD,IA9MX,GAAIlQ,MAEAmD,EAAS1D,IAkNb,OA7MAO,GAASuC,mBAAqB,WAK1B,MAAIY,GAAOxE,QAAQiB,KAAKqG,QAAQ9C,EAAOpB,MAAME,UAAYkB,EAAOpB,MAAME,OAAOkO,MAAMhK,WAE/EhD,GAAOxE,QAAQmB,GAAG2O,kBAKfzO,EAASoQ,aAAajN,EAAOpB,MAAME,QAErCQ,MAAM,SAAUC,GAEbS,EAAOxE,QAAQiB,KAAK+C,IAAI,+BAAgC,QAASD,MAW7E1C,EAASoQ,aAAe,SAAU7M,GAU9B,IAAK,GARD8M,GAAa9M,EAAK4M,MAMlBlO,KAEKqO,EAAQ,EAAGA,EAAQD,EAAWlK,OAASmK,IAE5CrO,EAAOoI,KAAKjH,QAAQC,QAAQgN,EAAWC,IACpChO,KAAKsM,GAIZ,OAAOxL,SAAQmN,IAAItO,GAChBK,KAAK,SAAAkO,GAEFA,EAAS7G,QAAQ,SAAArF,GAEbnB,EAAOxE,QAAQuB,QAAQ4O,aACnB5F,MAAO5E,EACPP,KAAMO,EAAQkI,KAAKc,YAYrCtN,EAASyQ,kBAAoB,SAAUC,EAAczO,EAAQqO,GAGzDI,EAGKpO,KAAK,WAEF,MAAOa,GAAOxE,QAAQqB,SAAS2Q,aAAa1O,EAAQqO,KAOvDhO,KAAKa,EAAOxE,QAAQqB,SAAS4Q,qBAK7BtO,KAAK,SAAU2N,GAQZ,MAHA9M,GAAOxE,QAAQuB,QAAQ4O,YAAYmB,GAG5BA,EAAU/G,QAKpBzG,MAAM,SAAUC,GAEbS,EAAOxE,QAAQiB,KAAK+C,IAAI,wCAAyC,QAASD,MAoBtF1C,EAAS4Q,oBAAsB,SAAWC,GAGtC,GAAI3H,GACAsD,EAAOqE,EAASrE,KAChBrC,EAAaqC,EAAKzI,IAMtB,KAAKZ,EAAOtD,MAAMsK,GAEd,KAAMtG,kBAAiBsG,EAAjB,cAKV,IAA8C,kBAAnChH,GAAOtD,MAAMsK,GAAY4C,OAEhC,KAAMlJ,kBAAiBsG,EAAjB,8BAILhH,GAAOtD,MAAMsK,GAAYW,aAAc,GAExC5B,EAAQ/F,EAAOxE,QAAQ0B,KAAKyQ,mBAE5B5H,EAAM6H,UAAY5N,EAAOtD,MAAMsK,GAAYY,eAK3C7B,EAAM8H,QAAQC,cAAgBJ,EAASK,UAKvChI,EAAQ/F,EAAOtD,MAAMsK,GAAY4C,OAAOP,EAAKjJ,KAKjD,IAAI4N,GAAYhO,EAAOtD,MAAMsK,GAAYiH,cAAe,CAGxD,QACIrN,KAAYoG,EACZjB,MAAYA,EACZiI,UAAYA,IAoCpBnR,EAAS4O,kBAAoBA,EAEtB5O,IPqrCL,SAAUhB,EAAQD,GAEvB,YQ74CDC,GAAOD,QAAW,WAEd,GAAIkB,MAEAkD,EAAS1D,IAMbQ,GAAM2C,KAAO,WAQT,MALAO,GAAOpB,MAAMsP,KAAOlO,EAAOnC,MAAMc,SAASiP,UAG1C5N,EAAOpB,MAAMC,cAENsP,EAAWnO,EAAOnC,MAAMc,SAASyP,YAW5C,IAAID,GAAa,SAAUrP,GAIvB,IAAI,GAFAsB,MAEI+M,EAAQ,EAAGA,EAAQrO,EAAOkE,OAAQmK,IAEtC/M,EAAK8G,KAAKmH,EAAavP,EAAOqO,IAIlC,OAAOlN,SAAQmN,IAAIhN,GACdjB,KAAKmP,GACLhP,MAAMU,EAAOxE,QAAQiB,KAAK+C,MAK/B6O,EAAe,SAAUtI,GAEzB,MAAOwI,GAAcxI,GAClB5G,KAAKqP,GACLlP,MAAMU,EAAOxE,QAAQiB,KAAK+C,MAW7B+O,EAAgB,SAAUxI,GAE1B,GAAIsD,GAAOtD,EAAMqI,WAAW,GAAGA,WAAW,GAAG/E,IAG7C,KAAKrJ,EAAOtD,MAAM2M,EAAKc,MAGnB,MADAnK,GAAOxE,QAAQiB,KAAK+C,IAApB,WAAmC6J,EAAKc,KAAxC,cAA2D,UACnD/J,KAAM,KAAMiJ,KAAM,KAK9B,IAAyB,kBAAdA,GAAK5J,KAGZ,MADAO,GAAOxE,QAAQiB,KAAK+C,IAApB,WAAmC6J,EAAKc,KAAxC,0BAAuE,UAC/D/J,KAAM,KAAMiJ,KAAM,KAK9B,IAAIoF,GAAiB1I,EAAMqI,WAAW,GAClCM,EAAiBD,EAAaL,WAAW,GACzCL,EAAWW,EAAeb,QAAQC,aAGtC,OAAK9N,GAAOtD,MAAM2M,EAAKc,MAAMxC,aAAc,EAEhC1H,QAAQC,SAASE,KAAM7E,MAAMyE,OAAOpB,MAAME,OAAOkO,MAAMe,GAAU3N,KAAMiJ,SAI3EpJ,QAAQC,QAAQwO,GAClBvP,KAAKkK,EAAK5J,MACVN,KAAK,SAAAiB,GAAA,MAAQ2C,SAAQ3C,OAAMiJ,YAWhCmF,EAAoB,SAAAG,GAAwB,GAAbvO,GAAauO,EAAbvO,KAAMiJ,EAAOsF,EAAPtF,IAErC,KAAKjJ,IAASiJ,EAEV,OAAO,CAIX,IAAIA,EAAKuF,UAAqC,kBAAlBvF,GAAKuF,SAAyB,CAEtD,GAAIC,GAASxF,EAAKuF,SAASxO,EAK3B,KAAKyO,EAED,OAAO,EAMf,OAAQzO,OAAMiJ,SAWdiF,EAAa,SAAUQ,GAEvBA,EAAYA,EAAUC,OAAO,SAAAjC,GAAA,MAAaA,IAE1C,IAAIE,GAAQ8B,EAAU1D,IAAI,SAAA0B,GAAA,MAAa/J,SAAQnC,KAAMkM,EAAUzD,KAAKc,KAAM/J,KAAM0M,EAAU1M,QAI1F,OAFAJ,GAAOpB,MAAMC,WAAamO,GAGtBlR,GAAIkE,EAAOpB,MAAME,OAAOhD,IAAM,KAC9BkT,MAAO,GAAIC,MACX1S,QAASyD,EAAOzD,QAChByQ,SAKR,OAAOlQ,KRg5CL,SAAUjB,EAAQD,GAEvB,YS1iDDC,GAAOD,QAAW,WAEd,GAAImB,MAEAiD,EAAS1D,IAMbS,GAAQmS,YAAc,KAMtBnS,EAAQoS,uBAAyB,KAMjCpS,EAAQqS,KAAO,WAEXpP,EAAOxE,QAAQiB,KAAK+C,IAAI,cAKxBQ,EAAOpB,MAAMsP,KAAOlO,EAAOnC,MAAMc,SAASiP,WAS9C7Q,EAAQsS,UAAY,WAEhBrP,EAAOxE,QAAQuB,QAAQmS,YAAYI,UAAUhF,IAAItK,EAAOxE,QAAQmB,GAAGmL,UAAUI,oBASjFnL,EAAQwS,UAAY,WAEZvP,EAAOxE,QAAQuB,QAAQmS,aAEvBlP,EAAOxE,QAAQuB,QAAQmS,YAAYI,UAAUE,OAAOxP,EAAOxE,QAAQmB,GAAGmL,UAAUI,oBAexFnL,EAAQ0S,mBAAqB,SAAUxD,GAQnC,GANKjM,EAAOxE,QAAQiB,KAAKkG,UAAUsJ,KAE/BA,EAAOA,EAAK7K,YAIZ6K,IAASjM,EAAOnC,MAAMc,UAAYsN,IAAS1L,SAASmP,KAEpD,MAAO,KAIP,OAAOzD,EAAKqD,UAAUK,SAAS3P,EAAOxE,QAAQmB,GAAGmL,UAAUC,kBAEvDkE,EAAOA,EAAK7K,UAIhB,OAAO6K,IAaflP,EAAQ6O,mBAAqB,SAAUgE,GAGnC5P,EAAOxE,QAAQuB,QAAQwS,YAElBK,IAML7S,EAAQmS,YAAcnS,EAAQ0S,mBAAmBG,KAcrD7S,EAAQ8S,aAAe,SAAUC,EAAaC,GAE1C,IAAKD,IAAgBC,EAGjB,WADA/P,GAAOxE,QAAQiB,KAAK+C,IAAI,8BAM5B,OAAOsQ,EAAYR,UAAUK,SAAS3P,EAAOxE,QAAQmB,GAAGmL,UAAUC,kBAE9D+H,EAAcA,EAAY1O,UAK9BpB,GAAOnC,MAAMc,SAASqR,aAAaD,EAAUD,GAK7C9P,EAAOxE,QAAQuB,QAAQ6O,mBAAmBmE,GAK1C/P,EAAOxE,QAAQmB,GAAGoO,iBAAiBgF,GAKnC/P,EAAOxE,QAAQmB,GAAG0C,cAgBtBtC,EAAQ4O,YAAc,SAAWmB,EAAWmD,GAExC,GAAIC,GAAkBlQ,EAAOxE,QAAQuB,QAAQmS,YACzCiB,EAAkBrD,EAAU/G,MAC5BqK,EAAkBtD,EAAUlM,KAC5BqN,EAAkBnB,EAAUkB,UAE5B+B,EAAWM,EAAiBF,EAAiBC,EAAWnC,EA+B5D,IA7BIiC,EAEAlQ,EAAOxE,QAAQiB,KAAKwE,YAAYiP,EAAcH,GAO9C/P,EAAOnC,MAAMc,SAAS4G,YAAYwK,GAOtC/P,EAAOxE,QAAQmB,GAAGoO,iBAAiBgF,GAKnC/P,EAAOxE,QAAQuB,QAAQ6O,mBAAmBmE,GAK1C/P,EAAOxE,QAAQmB,GAAG0C,aAGb4Q,EAAiB,CAKlB,GAAIK,GAAoBtQ,EAAOxE,QAAQ2B,MAAMoT,yBAA0B,CAGvE,IAAID,IAAqB,EAAI,CAGzB,GAAIE,GAAkBT,EAASU,cAAc,qBACzCC,EAAkBnQ,SAASoQ,eAAe,GAE9CH,GAAgBjL,YAAYmL,GAC5B1Q,EAAOxE,QAAQ2B,MAAMyT,IAAIJ,EAAiB,EAAG,GAE7CxQ,EAAOxE,QAAQwB,QAAQ6T,OACvB7Q,EAAOxE,QAAQwB,QAAQ8T,qBAGpB,CAEH,GAAIR,IAAsBtQ,EAAOpB,MAAMG,OAAOiE,OAAS,EACnD,MAGJlC,QAAOiQ,WAAW,WAGd/Q,EAAOxE,QAAQ2B,MAAM6T,eAAeV,GACpCtQ,EAAOxE,QAAQwB,QAAQ6T,OACvB7Q,EAAOxE,QAAQwB,QAAQgH,QAExB,KAUXjH,EAAQoS,wBAAyB,GAWrCpS,EAAQkU,YAAc,SAAUC,EAAgBnB,EAAU1G,GAEtDA,EAAOA,GAAQrJ,EAAOxE,QAAQuB,QAAQmS,YAAYrB,QAAQxE,IAC1D,IAAI8H,GAAmBd,EAAiBN,EAAU1G,EAGlDrJ,GAAOxE,QAAQuB,QAAQ8S,aAAaqB,EAAgBC,GAGpDnR,EAAOxE,QAAQmB,GAAG0C,cAetBtC,EAAQqU,+BAAiC,SAAUrL,EAAOgI,GAMtD,GACIZ,GACAlB,EACAoF,EAHAC,EAAcvL,EAAMqI,UAKxB,KAAIjB,EAAQ,EAAGA,EAAQmE,EAAYtO,OAAQmK,IAEvClB,EAAOqF,EAAYnE,GAEflB,EAAKpJ,UAAY7C,EAAOxE,QAAQiB,KAAK8E,UAAUE,OAE/C4P,EAAOpF,EAAK5F,YAAYC,OAKX,KAAT+K,IAEAtL,EAAMwL,YAAYtF,GAClB8B,KAQZ,IAAgC,IAA5BhI,EAAMqI,WAAWpL,OAEjB,MAAOzC,UAASoQ,eAAe,GAK9B5C,GAAW,IACZA,EAAW,EAEf,IAAIyD,IAAmB,CAUvB,KAPiB,IAAbzD,IAEAyD,GAAmB,EACnBzD,EAAW,GAIPA,GAKAhI,EAFCyL,EAEOzL,EAAMqI,WAAW,GAIjBrI,EAAMqI,WAAWL,EAAW,GAInChI,EAAMlD,UAAY7C,EAAOvD,KAAK8E,UAAUC,IAEzCuM,EAAWhI,EAAMqI,WAAWpL,OAErB+C,EAAMlD,UAAY7C,EAAOvD,KAAK8E,UAAUE,OAE/CsM,EAAW,EAMnB,OAAOhI,GAYX,IAAIsK,GAAmB,SAAUtK,EAAOsD,EAAM4E,GAE1C,GAAI8B,GAAe/P,EAAOxE,QAAQ0B,KAAK+O,KAAK,MAAOjM,EAAOxE,QAAQmB,GAAGmL,UAAUC,oBAC3E0G,EAAezO,EAAOxE,QAAQ0B,KAAK+O,KAAK,MAAOjM,EAAOxE,QAAQmB,GAAGmL,UAAUE,iBAY/E,OAVAyG,GAAalJ,YAAYQ,GACzBgK,EAASxK,YAAYkJ,GAEjBR,GAEAQ,EAAaa,UAAUhF,IAAItK,EAAOxE,QAAQmB,GAAGmL,UAAUG,iBAI3D8H,EAASlC,QAAQxE,KAASA,EACnB0G,EAQXhT,GAAQ0U,SAAW,WAEf,GAAIC,GAAY5Q,OAAO6Q,eAAeC,WAAW,EAEjD,OAAOF,IAaX3U,EAAQ8U,WAAa,SAAUC,GAE3B,GAIIC,GACAC,EACAC,EACAC,EAPAR,EAAiB5Q,OAAO6Q,eACxBQ,EAAiBT,EAAUS,WAC3BC,EAAiBD,EAAW9L,YAC5BgM,EAAiBX,EAAUY,aAM3BC,EAAevS,EAAOxE,QAAQuB,QAAQmS,YAAYuB,cAAc,oBAGpEsB,GAAsBK,EAAeI,UAAU,EAAGH,GAClDJ,EAAsBG,EAAeI,UAAUH,GAE/CL,EAAsBzR,SAASoQ,eAAeoB,GAE1CE,IAEAC,EAAsB3R,SAASoQ,eAAesB,GAIlD,IAAIQ,MACAC,KACAC,GAAiB,CAEjBT,IAEAQ,EAAWxL,KAAKgL,EAIpB,KAAM,GAAWU,GAAPxG,EAAI,EAAawG,EAAQL,EAAanE,WAAWhC,GAAKA,IAEvDwG,GAAST,EAEJQ,EAMFD,EAAWxL,KAAK0L,GAJhBH,EAAevL,KAAK0L,GAUxBD,GAAiB,CAOzB3S,GAAOpB,MAAMG,OAAO+S,GAAYlE,UAAY,EAK5C,IAAIiF,GAAuBJ,EAAezP,MAE1C,KAAIoJ,EAAI,EAAGA,EAAIyG,EAAsBzG,IAEjCpM,EAAOpB,MAAMG,OAAO+S,GAAYvM,YAAYkN,EAAerG,GAI/DpM,GAAOpB,MAAMG,OAAO+S,GAAYvM,YAAYyM,EAK5C,IAAIc,GAAmBJ,EAAW1P,OAC9B+P,EAAmBxS,SAAS0E,cAAc,MAE9C,KAAImH,EAAI,EAAGA,EAAI0G,EAAkB1G,IAE7B2G,EAAQxN,YAAYmN,EAAWtG,GAInC2G,GAAUA,EAAQnF,SAGlB,IAAIoF,GAAiBhT,EAAOtC,SAASE,kBAKrCoC,GAAOxE,QAAQuB,QAAQ4O,aACnB/K,KAAQoS,EACRjN,MAAQ/F,EAAOtD,MAAMsW,GAAgBpJ,QACjCyH,KAAO0B,MAEZ,IAcPhW,EAAQkW,YAAc,SAAU3C,EAAmB4C,GAG/C,GAA0B,IAAtB5C,EAAJ,CAMA,GAAI6C,GACAC,EAAsBpT,EAAOpB,MAAMG,OAAOuR,GAAmB1C,SAQ7DuF,GANCD,EAMalT,EAAOpB,MAAMG,OAAOmU,GAJpBlT,EAAOpB,MAAMG,OAAOuR,EAAoB,GAQ1D6C,EAAYvF,WAAawF,IAW7BrW,EAAQsW,WAAa,SAAUpH,GAM3B,IAFA,GAAIqH,IAAa,GAERA,GAAa,CAKlB,IAAMC,EAAkBtH,GAGpB,OAAO,CAIXA,GAAOA,EAAK7K,WAKP6K,EAAKqD,UAAUK,SAAS3P,EAAOxE,QAAQmB,GAAGmL,UAAUE,iBAErDsL,GAAa,GAMrB,OAAO,EAQX,IAAIC,GAAoB,SAAUtH,GAO9B,IAFA,GAAIuH,GAAUvH,EAAK3K,YAEXkS,GAAU,CAEd,GAAIA,EAAQnN,YAAYrD,OAEpB,OAAO,CAIXwQ,GAAUA,EAAQlS,YAItB,OAAO,EAWXvE,GAAQ0W,uBAAyB,SAAUC,EAAUC,GAEjD,IAAKD,EAASpN,OAEV,MAAOsN,GAA4BD,EAIvC,IAEIvH,GACAyH,EAEAC,EACA7H,EANAlO,EAAUwC,SAAS0E,cAAc,OACjC8O,EAAaxT,SAAS0E,cAAc,OAGpC+O,GAAoB,MAAO,IAW/B,KAHAjW,EAAQ6P,UAAY8F,EACpBG,EAAYtT,SAAS0E,cAAc,KAE9BmH,EAAI,EAAGA,EAAIrO,EAAQqQ,WAAWpL,OAAQoJ,IAEvCH,EAAOlO,EAAQqQ,WAAWhC,GAE1B0H,EAAaE,EAAiBpO,QAAQqG,EAAKpG,WAAY,EAMlDiO,GAKID,EAAUzF,WAAWpL,SAEtB+Q,EAAWxO,YAAYsO,EAAUI,WAAU,IAG3CJ,EAAY,KACZA,EAAYtT,SAAS0E,cAAc,MAIvC8O,EAAWxO,YAAY0G,EAAKgI,WAAU,MAKtCJ,EAAUtO,YAAY0G,EAAKgI,WAAU,IAGhC7H,GAAKrO,EAAQqQ,WAAWpL,OAAS,GAElC+Q,EAAWxO,YAAYsO,EAAUI,WAAU,IAQvD,OAAOF,GAAWnG,UAStB,IAAIgG,GAA8B,SAAUM,GAExC,MAAO,MAAQA,EAAUC,MAAM,QAAQC,KAAK,WAAa,OA8E7D,OArEArX,GAAQsX,kBAAoB,SAAUpI,GAElC,KAAOA,GAAgC,QAAxBA,EAAKqI,iBAEhBrI,EAAOA,EAAK7K,UAIhB,OAAO6K,IASXlP,EAAQwX,MAAQ,SAAUnH,GAEtBpN,EAAOnC,MAAMc,SAASiP,UAAY,GAClC5N,EAAOxE,QAAQuB,QAAQqS,OACvBpP,EAAOxE,QAAQmB,GAAG0C,aACd+N,EAEApN,EAAOpB,MAAME,UAENkB,EAAOpB,MAAME,SAEpBkB,EAAOpB,MAAME,OAAOkO,UAIxBhN,EAAOxE,QAAQuB,QAAQmS,YAAc,MAWzCnS,EAAQyX,KAAO,SAAUC,GAErB,GAAIC,GAAiB3R,OAAO4R,UAAW3U,EAAOpB,MAAME,OAEpDkB,GAAOxE,QAAQuB,QAAQwX,QAElBxR,OAAOnB,KAAK8S,GAAgB1R,OAIrB0R,EAAe1H,OAOvB0H,EAAe1H,MAAQ0H,EAAe1H,MAAM4H,OAAOH,EAAYzH,OAC/DhN,EAAOpB,MAAME,OAAS4V,IANtBA,EAAe1H,MAAQyH,EAAYzH,MACnChN,EAAOpB,MAAME,OAAS4V,GALtB1U,EAAOpB,MAAME,OAAS2V,EAc1BzU,EAAOxE,QAAQqB,SAASuC,sBAIrBrC,IT4+CL,SAAUlB,EAAQD,EAASH,GAEhC,YUpwEDI,GAAOD,QAAW,WAEd,GAAIoB,MAEAgD,EAAS1D,IAoHb,OAlHAU,GAAQU,SAAWjC,EAAQ,GAAcO,KAAKgE,GAC9ChD,EAAQkO,OAAWzP,EAAQ,IAAYO,KAAKgE,GAC5ChD,EAAQmB,QAAW1C,EAAQ,IAAaO,KAAKgE,GAK7ChD,EAAQ6X,qBAAuB,GAE/B7X,EAAQ8X,cAAgB,GAExB9X,EAAQ+X,QAAS,EAEjB/X,EAAQqO,QAAU,KAKlBrO,EAAQgH,KAAO,WAEX,IAAIhE,EAAOK,YAAX,CAMA,GAAIgJ,GAAOrJ,EAAOxE,QAAQuB,QAAQmS,YAAYd,WAAW,GAAGA,WAAW,GAAG/E,IAErErJ,GAAOtD,MAAM2M,EAAKc,OAAUd,EAAK2L,cAA6C,kBAAtB3L,GAAK2L,aAM9DhV,EAAOnC,MAAMQ,mBAAmBiR,UAAUE,OAAO,QAJjDxP,EAAOnC,MAAMQ,mBAAmBiR,UAAUhF,IAAI,QAQlDtK,EAAOnC,MAAMb,QAAQsS,UAAUhF,IAAI,UACnChO,KAAKyY,QAAS,IAOlB/X,EAAQiY,MAAQ,WAEZjV,EAAOnC,MAAMb,QAAQsS,UAAUE,OAAO,UAEtCxS,EAAQ+X,QAAU,EAClB/X,EAAQqO,QAAU,IAElB,KAAK,GAAIR,KAAU7K,GAAOnC,MAAMa,eAE5BsB,EAAOnC,MAAMa,eAAemM,GAAQyE,UAAUE,OAAO,WAKzDxP,GAAOxE,QAAQwB,QAAQmB,QAAQ8W,QAC/BjV,EAAOxE,QAAQwB,QAAQU,SAASuX,SAIpCjY,EAAQkY,OAAS,WAEP5Y,KAAKyY,OAMPzY,KAAK2Y,QAJL3Y,KAAK0H,QAUbhH,EAAQmY,eAAiB,WAErBnV,EAAOnC,MAAMO,WAAWkR,UAAUhF,IAAI,SAI1CtN,EAAQ8T,eAAiB,WAErB9Q,EAAOnC,MAAMO,WAAWkR,UAAUE,OAAO,SAO7CxS,EAAQ6T,KAAO,WAKX,GAFA7Q,EAAOxE,QAAQwB,QAAQmB,QAAQ8W,QAE1BjV,EAAOxE,QAAQuB,QAAQmS,YAA5B,CAMA,GAAIkG,GAAiBpV,EAAOxE,QAAQuB,QAAQmS,YAAYmG,UAAarV,EAAOxE,QAAQwB,QAAQ6X,qBAAuB,EAAK7U,EAAOxE,QAAQwB,QAAQ8X,aAE/I9U,GAAOnC,MAAMb,QAAQsY,MAAMC,UAA3B,kBAAyDC,KAAKC,MAAML,GAApE,SAGApV,EAAOxE,QAAQwB,QAAQU,SAASgY,sBAI7B1Y,IV0wEL,SAAUnB,EAAQD,GAEvB,YW14EDC,GAAOD,QAAW,WAEd,GAAI8B,MAEAsC,EAAS1D,IAiKb,OA/JAoB,GAASqX,QAAS,EAElBrX,EAASiY,QAAU,KACnBjY,EAASQ,QAAU,KAKnBR,EAASsG,KAAO,SAAUqF,GAMtB,GAAMrJ,EAAOtD,MAAM2M,EAAKc,OAAUd,EAAK2L,cAA6C,kBAAtB3L,GAAK2L,aAAnE,CASA,GAAIY,GAAgBvM,EAAK2L,cAEzBhV,GAAOnC,MAAMW,eAAe+G,YAAYqQ,GAIxC5V,EAAOnC,MAAMU,cAAc+Q,UAAUhF,IAAI,UACzChO,KAAKyY,QAAS,IAOlBrX,EAASuX,MAAQ,WAEbjV,EAAOnC,MAAMU,cAAc+Q,UAAUE,OAAO,UAC5CxP,EAAOnC,MAAMW,eAAeoP,UAAY,GAExCtR,KAAKyY,QAAS,GAOlBrX,EAASwX,OAAS,SAAW7L,GAEnB/M,KAAKyY,OAMPzY,KAAK2Y,QAJL3Y,KAAK0H,KAAKqF,IAalB3L,EAASwL,sBAAwB,WAE7B,GAAI2M,GAAsB7V,EAAOxE,QAAQ0B,KAAK+O,KAAK,OAAQ,6BACvD6J,EAAgB9V,EAAOxE,QAAQ0B,KAAK+O,KAAK,OAAQ,8BAAgC2B,UAAY,kCAC7FmI,EAAgB/V,EAAOxE,QAAQ0B,KAAK+O,KAAK,MAAO,sCAChD+J,EAAgBhW,EAAOxE,QAAQ0B,KAAK+O,KAAK,MAAO,8BAAgC5F,YAAc,iBAC9F4P,EAAgBjW,EAAOxE,QAAQ0B,KAAK+O,KAAK,MAAO,6BAA+B5F,YAAc,UAkBjG,OAhBArG,GAAOxE,QAAQ+B,UAAU+M,IAAIwL,EAAe,QAAS9V,EAAOxE,QAAQwB,QAAQU,SAASwY,qBAAqB,GAE1GlW,EAAOxE,QAAQ+B,UAAU+M,IAAI0L,EAAe,QAAShW,EAAOxE,QAAQwB,QAAQU,SAASyY,wBAAwB,GAE7GnW,EAAOxE,QAAQ+B,UAAU+M,IAAI2L,EAAc,QAASjW,EAAOxE,QAAQwB,QAAQU,SAAS0Y,uBAAuB,GAE3GL,EAAcxQ,YAAYyQ,GAC1BD,EAAcxQ,YAAY0Q,GAE1BJ,EAAmBtQ,YAAYuQ,GAC/BD,EAAmBtQ,YAAYwQ,GAG/B/V,EAAOxE,QAAQwB,QAAQU,SAASiY,QAAUG,EAC1C9V,EAAOxE,QAAQwB,QAAQU,SAASQ,QAAU6X,EAEnCF,GAIXnY,EAASwY,oBAAsB,WAE3B,GAAIG,GAASrW,EAAOxE,QAAQwB,QAAQU,SAASQ,OAEzCmY,GAAO/G,UAAUK,SAAS,UAE1B3P,EAAOxE,QAAQwB,QAAQU,SAASgY,oBAIhC1V,EAAOxE,QAAQwB,QAAQU,SAAS4Y,oBAIpCtW,EAAOxE,QAAQwB,QAAQmB,QAAQ8W,QAC/BjV,EAAOxE,QAAQwB,QAAQU,SAASuX,SAIpCvX,EAAS0Y,sBAAwB,WAE7BpW,EAAOxE,QAAQwB,QAAQU,SAASQ,QAAQoR,UAAUE,OAAO,WAI7D9R,EAASyY,uBAAyB,WAE9B,GACII,GADAhE,EAAevS,EAAOxE,QAAQuB,QAAQmS,WAG1CqD,GAAa/C,SAEb+G,EAAwBvW,EAAOnC,MAAMc,SAASyP,WAAWpL,OAK3B,IAA1BuT,IAGAvW,EAAOxE,QAAQuB,QAAQmS,YAAc,KAGrClP,EAAOxE,QAAQmB,GAAG2O,mBAItBtL,EAAOxE,QAAQmB,GAAG0C,aAElBW,EAAOxE,QAAQwB,QAAQiY,SAI3BvX,EAAS4Y,kBAAoB,WAEzBtW,EAAOxE,QAAQwB,QAAQU,SAASQ,QAAQoR,UAAUhF,IAAI,WAI1D5M,EAASgY,kBAAoB,WAEzB1V,EAAOxE,QAAQwB,QAAQU,SAASQ,QAAQoR,UAAUE,OAAO,WAItD9R,IXu4EL,SAAU7B,EAAQD,GAEvB,YY1iFDC,GAAOD,QAAW,WAEd,GAAIsP,MAEAlL,EAAS1D,IAEb4O,GAAOsL,cAAgB,KACvBtL,EAAOuL,cAAgB,KACvBvL,EAAOwL,eAAiB,KAMxBxL,EAAOyL,gBAAkB,KAOzBzL,EAAOC,KAAO,WAEV,GAEIlE,GAFAiI,EAAclP,EAAOxE,QAAQuB,QAAQmS,YACrC7F,EAAO6F,EAAYrB,QAAQxE,IAQ/B,IAFApC,EAASjH,EAAOtD,MAAM2M,GAEjBpC,EAAO2P,kBAAZ,CAGA,GAAIC,GAAe3L,EAAO4L,mBACtB9Z,EAAegD,EAAOnC,MAAMG,cAAcD,OAE1C8Y,GAAa7T,OAAS,IAGtBhD,EAAOxE,QAAQwB,QAAQkO,OAAO2F,OAG9B7T,EAAQsS,UAAUhF,IAAI,UAGtBtK,EAAOxE,QAAQwB,QAAQkO,OAAO6L,iBAWtC7L,EAAO+J,MAAQ,WAEX,GAAIjY,GAAUgD,EAAOnC,MAAMG,cAAcD,OAEzCf,GAAQsS,UAAUE,OAAO,WAS7BtE,EAAO2F,KAAO,WAELvU,KAAKoa,iBAENpa,KAAKoa,eAAiBpa,KAAK0a,oBAI/B,IAGIC,GACAC,EAJAC,EAAkB7a,KAAK8a,qBACvBtC,EAAkB,EAClB9X,EAAkBgD,EAAOnC,MAAMG,cAAcD,OAIpB,KAAzBf,EAAQqa,eAERvC,EAAgB,IAIpBmC,EAAiBE,EAAOG,EAAIhb,KAAKoa,eAAea,KAChDL,EAAiBC,EAAOK,EAAI1W,OAAO2W,QAAUnb,KAAKoa,eAAegB,IAAM5C,EAAgB9X,EAAQqa,aAE/Fra,EAAQsY,MAAMC,UAAd,eAAyCC,KAAKC,MAAMwB,GAApD,OAA0EzB,KAAKC,MAAMyB,GAArF,SAGAlX,EAAOxE,QAAQwB,QAAQkO,OAAOyM,eAC9B3X,EAAOxE,QAAQwB,QAAQkO,OAAO0M,eAUlC1M,EAAOY,YAAc,SAAUD,EAAOjL,GAMlC,OAAQA,GACJ,IAAK,aAAeZ,EAAOxE,QAAQwB,QAAQkO,OAAO2M,iBAAiBhM,EAAOjL,EAAO,MACjF,SAAoBZ,EAAOxE,QAAQwB,QAAQkO,OAAO4M,kBAAkBlX,GAOxEZ,EAAOnC,MAAMG,cAAcC,QAAQmQ,WAAW5H,QAAQxG,EAAOxE,QAAQwB,QAAQkO,OAAO6M,aASxF7M,EAAO8L,kBAAoB,WAEvB,GAAIjZ,GAAUiC,EAAOnC,MAAME,QACvBia,EAAU1b,KAAK2b,UAAUla,EAG7B,OADAzB,MAAKoa,eAAiBsB,EACfA,GAYX9M,EAAO+M,UAAY,SAAWrV,GAK1B,IAHA,GAAIsV,GAAK,EACLC,EAAK,EAEFvV,IAAOwV,MAAOxV,EAAGyV,cAAiBD,MAAOxV,EAAGyS,YAE/C6C,GAAOtV,EAAGyV,WAAazV,EAAG0V,WAC1BH,GAAOvV,EAAGyS,UAAYzS,EAAG2V,UACzB3V,EAAKA,EAAG4V,YAGZ,QAASd,IAAKS,EAAIZ,KAAMW,IAU5BhN,EAAOkM,mBAAqB,WAExB,GAA8BqB,GAA1BC,EAAMnY,SAASmR,UACf4F,EAAI,EAAGE,EAAI,CAEf,IAAIkB,EAEgB,WAAZA,EAAI9X,OAEJ6X,EAAQC,EAAIC,cACZF,EAAMG,UAAS,GACftB,EAAImB,EAAMI,aACVrB,EAAIiB,EAAMK,iBAIX,IAAIhY,OAAO6Q,eAEd+G,EAAM5X,OAAO6Q,eAET+G,EAAIK,aAEJN,EAAQC,EAAI9G,WAAW,GAAGoH,aACtBP,EAAMQ,iBAAgB,CAEtBR,EAAMG,UAAS,EACf,IAAIM,GAAOT,EAAMQ,iBAAiB,EAElC,KAAKC,EAED,MAIJ5B,GAAI4B,EAAK3B,KACTC,EAAI0B,EAAKxB,IAOrB,OAASJ,EAAGA,EAAGE,EAAGA,IAUtBtM,EAAO4L,iBAAmB,WAEtB,GAAID,GAAe,EASnB,OANI/V,QAAO6Q,eAEPkF,EAAe/V,OAAO6Q,eAAewH,YAIlCtC,GAKX3L,EAAO6L,YAAc,WAEjB,GAAI9Y,GAAU+B,EAAOnC,MAAMG,cAAcC,OAEzCA,GAAQqR,UAAUhF,IAAI,UAEtBtK,EAAOxE,QAAQwB,QAAQkO,OAAOsL,eAAgB,EAG9CxW,EAAOnC,MAAMG,cAAcC,QAAQmQ,WAAW5H,QAAQxG,EAAOxE,QAAQwB,QAAQkO,OAAO6M,aAKxF7M,EAAOyM,aAAe,WAElB,GAAI1Z,GAAU+B,EAAOnC,MAAMG,cAAcC,OAEzCA,GAAQqR,UAAUE,OAAO,UAEzBxP,EAAOxE,QAAQwB,QAAQkO,OAAOsL,eAAgB,GAKlDtL,EAAOkO,YAAc,WAEjB,GAAI/C,GAASrW,EAAOnC,MAAMG,cAAcE,OAExCmY,GAAO/G,UAAUhF,IAAI,UAErBtK,EAAOxE,QAAQwB,QAAQkO,OAAOuL,eAAgB,GAKlDvL,EAAO0M,YAAc,WAEjB,GAAIvB,GAASrW,EAAOnC,MAAMG,cAAcE,OAExCmY,GAAOzI,UAAY,GACnByI,EAAO/G,UAAUE,OAAO,UACxBxP,EAAOxE,QAAQwB,QAAQkO,OAAOuL,eAAgB,EAQlD,IAAI4C,GAAmC,SAAUxN,GAE7C,GAAIA,EAAMyN,SAAWtZ,EAAOvD,KAAKmF,KAAKG,MAAtC,CAMA,GAAIwX,GAAkBvZ,EAAOxE,QAAQuB,QAAQmS,YACzCyH,EAAkB3W,EAAOxE,QAAQwB,QAAQkO,OAAOyL,eAEpD3W,GAAOxE,QAAQwB,QAAQkO,OAAOsO,iBAAiBD,EAAU5C,GACzD3W,EAAOxE,QAAQwB,QAAQkO,OAAOuO,UAAUnd,KAAKoK,OAK7CmF,EAAM6N,iBACN7N,EAAM8N,2BAEN3Z,EAAOxE,QAAQwB,QAAQkO,OAAO0O,cAgRlC,OA3QA1O,GAAO2M,iBAAmB,SAAUhM,GAEhC,GAAIgO,GAAWvd,KAAKwd,eAEhBP,EAAkBvZ,EAAOxE,QAAQuB,QAAQmS,YACzCyH,EAAkB3W,EAAOxE,QAAQwB,QAAQkO,OAAO6O,cAAcR,EAKlE,IAFAvZ,EAAOxE,QAAQwB,QAAQkO,OAAOyL,gBAAkBA,EAE5CkD,EASA7Z,EAAOxE,QAAQwB,QAAQkO,OAAOsO,iBAAiBD,EAAU5C,GAEzD3W,EAAOxE,QAAQwB,QAAQkO,OAAO4M,kBAAkB,cAE7C,CAGH,GAAIzB,GAASrW,EAAO9C,KAAK8c,cAEzBha,GAAOnC,MAAMG,cAAcE,QAAQqH,YAAY8Q,GAE/CrW,EAAOxE,QAAQwB,QAAQkO,OAAOyM,eAC9B3X,EAAOxE,QAAQwB,QAAQkO,OAAOkO,cAO9B/C,EAAO4D,QACPpO,EAAM6N,iBAGN1Z,EAAOxE,QAAQ+B,UAAU+M,IAAI+L,EAAQ,UAAWgD,GAAkC,KAM1FnO,EAAO4O,aAAe,WAElB,GAAID,IAAW,CAcf,OAZA7Z,GAAOnC,MAAMG,cAAcC,QAAQmQ,WAAW5H,QAAQ,SAAU6C,GAE5D,GAAI6Q,GAAW7Q,EAAKwE,QAAQjN,IAEZ,SAAZsZ,GAAsB7Q,EAAKiG,UAAUK,SAAS,kBAE9CkK,GAAW,KAMZA,GAKX3O,EAAO4M,kBAAoB,SAAUlX,GAEjCL,SAAS4Z,YAAYvZ,GAAM,EAAO,OAWtCsK,EAAOuO,UAAY,SAAUvW,GAEzB3C,SAAS4Z,YAAY,cAAc,EAAOjX,GAG1ClD,EAAOxE,QAAQwB,QAAQkO,OAAO0M,eASlC1M,EAAO6O,cAAgB,SAAUK,GAE7B,GAEIpb,GAFAyZ,EAAQ3X,OAAO6Q,eAAeC,WAAW,GACzCyI,EAAoB5B,EAAMO,YAQ9B,OALAqB,GAAkBC,mBAAmBF,GACrCC,EAAkBE,OAAO9B,EAAM+B,eAAgB/B,EAAMgC,aAErDzb,EAAQqb,EAAkBlB,WAAWnW,QAGjChE,MAAOA,EACP0b,IAAK1b,EAAQyZ,EAAMU,WAAWnW,SAatCkI,EAAOsO,iBAAmB,SAAUY,EAAaO,GAE7C,GAAIlC,GAAYlY,SAASoY,cACrBiC,EAAY,CAEhBnC,GAAMoC,SAAST,EAAa,GAC5B3B,EAAMG,UAAS,EAQf,KANA,GACI3M,GAGA6O,EAJAC,GAAcX,GAEdY,GAAa,EACbC,GAAO,GAGHA,IAAShP,EAAO8O,EAAUG,QAE9B,GAAqB,GAAjBjP,EAAKpJ,SAELiY,EAAgBF,EAAY3O,EAAKjJ,QAE5BgY,GAAcL,EAAS3b,OAAS4b,GAAaD,EAAS3b,OAAS8b,IAEhErC,EAAMoC,SAAS5O,EAAM0O,EAAS3b,MAAQ4b,GACtCI,GAAa,GAGbA,GAAcL,EAASD,KAAOE,GAAaD,EAASD,KAAOI,IAE3DrC,EAAM8B,OAAOtO,EAAM0O,EAASD,IAAME,GAClCK,GAAO,GAGXL,EAAYE,MAMZ,KAFA,GAAI1O,GAAIH,EAAKmC,WAAWpL,OAEjBoJ,KAEH2O,EAAU7T,KAAK+E,EAAKmC,WAAWhC,GAQ3C,IAAIsM,GAAM5X,OAAO6Q,cAEjB+G,GAAIyC,kBACJzC,EAAI0C,SAAS3C,IASjBvN,EAAO0O,WAAa,WAEhB,GAAIlI,GAAY5Q,OAAO6Q,cAEvBD,GAAUyJ,mBASdjQ,EAAO6M,WAAa,SAAU1O,GAE1B,GAAI6Q,GAAW7Q,EAAKwE,QAAQjN,IAExBL,UAAS8a,kBAAkBnB,GAE3Bla,EAAOxE,QAAQwB,QAAQkO,OAAOoQ,qBAAqBjS,GAInDrJ,EAAOxE,QAAQwB,QAAQkO,OAAOqQ,uBAAuBlS,EAQzD,IAAIqI,GAAY5Q,OAAO6Q,eACnB6J,EAAM9J,EAAUS,WAAW/Q,UAEZ,MAAfoa,EAAI3V,SAA8B,QAAZqU,GAEtBla,EAAOxE,QAAQwB,QAAQkO,OAAOoQ,qBAAqBjS,IAW3D6B,EAAOoQ,qBAAuB,SAAUzQ,GAKpC,GAHAA,EAAOyE,UAAUhF,IAAI,gBAGM,QAAvBO,EAAOgD,QAAQjN,KAAgB,CAE/B,GAAImJ,GAAOc,EAAOuD,WAAW,EAE7BrE,GAAKuF,UAAUE,OAAO,gBACtBzF,EAAKuF,UAAUhF,IAAI,oBAW3BY,EAAOqQ,uBAAyB,SAAU1Q,GAKtC,GAHAA,EAAOyE,UAAUE,OAAO,gBAGG,QAAvB3E,EAAOgD,QAAQjN,KAAgB,CAE/B,GAAImJ,GAAOc,EAAOuD,WAAW,EAE7BrE,GAAKuF,UAAUE,OAAO,kBACtBzF,EAAKuF,UAAUhF,IAAI,kBAOpBY,IZygFL,SAAUrP,EAAQD,GAEvB,YallGDC,GAAOD,QAAW,WAEd,GAAIuC,MAEA6B,EAAS1D,IAiLb,OA/KA6B,GAAQ4W,QAAS,EACjB5W,EAAQsd,cAAgB,KAGxBtd,EAAQ6F,KAAO,WAGPhE,EAAOxE,QAAQwB,QAAQU,SAASqX,QAEhC/U,EAAOxE,QAAQwB,QAAQU,SAASuX,QAKpC9W,EAAQsd,cAAgBzb,EAAOxE,QAAQuB,QAAQmS,YAC/C/Q,EAAQsd,cAAcnM,UAAUhF,IAAI,kBAGpCtK,EAAOnC,MAAMM,QAAQmR,UAAUhF,IAAI,UAGnCtK,EAAOnC,MAAMO,WAAWkR,UAAUhF,IAAI,WAGtCtK,EAAOxE,QAAQwB,QAAQmB,QAAQ4W,QAAS,GAK5C5W,EAAQ8W,MAAQ,WAGR9W,EAAQsd,eAAetd,EAAQsd,cAAcnM,UAAUE,OAAO,kBAClErR,EAAQsd,cAAgB,KAGxBzb,EAAOnC,MAAMM,QAAQmR,UAAUE,OAAO,UAGtCxP,EAAOnC,MAAMO,WAAWkR,UAAUE,OAAO,WAGzCxP,EAAOxE,QAAQwB,QAAQmB,QAAQ4W,QAAS,EAExC/U,EAAOxE,QAAQwB,QAAQqO,QAAU,MAIrClN,EAAQud,KAAO,WAEX,GAAIC,GAAc3b,EAAOxE,QAAQwB,QAAQqO,QACrC3O,EAAcqG,OAAOnB,KAAK5B,EAAOtD,OACjCkf,EAAc5b,EAAOnC,MAAMa,eAC3Bmd,EAAgB,EAChBC,SACAC,SACA1S,QAEJ,IAAMsS,EAoBF,IAHAE,GAAiBnf,EAAMkJ,QAAQ+V,GAAe,GAAKjf,EAAMsG,OACzD+Y,EAAcrf,EAAMmf,IAEZ7b,EAAOtD,MAAMqf,GAAapS,kBAE9BkS,GAAiBA,EAAgB,GAAKnf,EAAMsG,OAC5C+Y,EAAcrf,EAAMmf,OApBxB,KAAIxS,IAAQrJ,GAAOtD,MAAO,CAEtB,GAAIsD,EAAOtD,MAAM2M,GAAMM,iBAEnB,KAIJkS,KAkBRC,EAAepf,EAAMmf,EAErB,KAAM,GAAIhR,KAAU+Q,GAEhBA,EAAW/Q,GAAQyE,UAAUE,OAAO,WAIxCoM,GAAWE,GAAcxM,UAAUhF,IAAI,YACvCtK,EAAOxE,QAAQwB,QAAQqO,QAAUyQ,GAQrC3d,EAAQ2N,YAAc,SAAUD,GAK5B,GAIIsE,GACA6L,EACAlP,EANAmP,GAAsB,QAAS,OAAQ,OAAQ,YAAa,UAAW,SACvE5S,EAAqBrJ,EAAOtD,MAAMsD,EAAOxE,QAAQwB,QAAQqO,SACzD6Q,EAAqBlc,EAAOxE,QAAQuB,QAAQmS,YAC5CoB,EAAqBtQ,EAAOxE,QAAQ2B,MAAM2U,UAM9C3B,GAAkBnQ,EAAOxE,QAAQqB,SAAS4O,mBAAmB7K,KAAMyI,EAAKzI,OAGxEkM,GACI/G,MAAYoK,EACZvP,KAAYyI,EAAKzI,KACjBoN,WAAY,GAIZkO,GACAD,EAAmBrW,QAAQsW,EAAYrO,QAAQxE,SAAU,GACtB,KAAnC6S,EAAY7V,YAAYC,OAIxBtG,EAAOxE,QAAQuB,QAAQkU,YAAYiL,EAAa/L,EAAiB9G,EAAKzI,OAKtEZ,EAAOxE,QAAQuB,QAAQ4O,YAAYmB,GAGnCwD,KAKJ0L,EAAiB3S,EAAK2S,eAElBA,GAA2C,kBAAlBA,IAEzBA,EAAehgB,KAAK6P,GAIxB/K,OAAOiQ,WAAW,WAGd/Q,EAAOxE,QAAQ2B,MAAMgf,WAAW7L,IAEjC,IAMHtQ,EAAOxE,QAAQuB,QAAQ6O,qBAKvB5L,EAAOxE,QAAQwB,QAAQ6T,QAIpB1S,Ib8kGL,SAAUtC,EAAQD,GAEvB,YctwGDC,GAAOD,QAAW,WAEd,GAAIwgB,MAEApc,EAAS1D,IAOb8f,GAAU7R,cAAgB,SAAUsB,GAEhC,OAAQA,EAAMyN,SACV,IAAKtZ,GAAOxE,QAAQiB,KAAKmF,KAAKG,MAAQsa,EAAiBxQ,KAU/DuQ,EAAU5R,gBAAkB,SAAUqB,GAElC,OAAQA,EAAMyN,SACV,IAAKtZ,GAAOxE,QAAQiB,KAAKmF,KAAKE,IAAQwa,EAA8BzQ,EAA4B,MAChG,KAAK7L,GAAOxE,QAAQiB,KAAKmF,KAAKG,MAAQwa,EAAgC1Q,EAA0B,MAChG,KAAK7L,GAAOxE,QAAQiB,KAAKmF,KAAKO,IAAQqa,EAAiC3Q,EAAyB,MAChG,SAA8B4Q,EAAkC5Q,KAUxEuQ,EAAU3R,YAAc,SAAUoB,GAE9B,OAAQA,EAAMyN,SACV,IAAKtZ,GAAOxE,QAAQiB,KAAKmF,KAAKU,GAC9B,IAAKtC,GAAOxE,QAAQiB,KAAKmF,KAAKS,KAC9B,IAAKrC,GAAOxE,QAAQiB,KAAKmF,KAAKY,MAC9B,IAAKxC,GAAOxE,QAAQiB,KAAKmF,KAAKW,KAAQma,EAAiB7Q,IAa/D,IAAIyQ,GAAgC,SAAUzQ,GAM1CA,EAAM6N,iBAGD1Z,EAAOxE,QAAQiB,KAAKqJ,aAAa9F,EAAOxE,QAAQuB,QAAQmS,eAMvDlP,EAAOxE,QAAQwB,QAAQ+X,QAEzB/U,EAAOxE,QAAQwB,QAAQgH,OAIvBhE,EAAOxE,QAAQwB,QAAQ+X,SAAW/U,EAAOxE,QAAQwB,QAAQmB,QAAQ4W,OAEjE/U,EAAOxE,QAAQwB,QAAQmB,QAAQ6F,OAI/BhE,EAAOxE,QAAQwB,QAAQmB,QAAQud,SAWnCW,EAAmB,WAEfrc,EAAOxE,QAAQuB,QAAQoS,yBAMvBnP,EAAOxE,QAAQ2B,MAAM2U,YAAa,EAElC6K,MAcJA,EAAuB,WAEvB,GAAI3J,GAAkBhT,EAAOtC,SAASE,kBAEtCoC,GAAOxE,QAAQuB,QAAQ4O,aACnB/K,KAAQoS,EACRjN,MAAQ/F,EAAOtD,MAAMsW,GAAgBpJ,WACtC,GAEH5J,EAAOxE,QAAQwB,QAAQ6T,OACvB7Q,EAAOxE,QAAQwB,QAAQgH,QAavBuY,EAAkC,SAAU1Q,GAER,QAAhCA,EAAM3K,OAAOoT,iBAGbtU,EAAOxE,QAAQ2B,MAAMyf,uBAIzB,IAAItM,GAA0BtQ,EAAOxE,QAAQ2B,MAAMoT,wBAA0B,EACzE2L,EAA0Blc,EAAOxE,QAAQuB,QAAQmS,YACjD7F,EAA0B6S,EAAYrO,QAAQxE,KAC9CwT,EAA0B7c,EAAOxE,QAAQwB,QAAQ+X,QACrB/U,EAAOxE,QAAQwB,QAAQqO,SACvBQ,EAAM3K,QAAUlB,EAAOpB,MAAMG,OAAOuR,GAGhEwM,EAAmB9c,EAAOtD,MAAM2M,GAAMyT,iBAGtC9J,EAAiBhT,EAAOtC,SAASE,kBAKrC,IAAKif,EAcD,MAZAhR,GAAM6N,iBAEN1Z,EAAOxE,QAAQwB,QAAQmB,QAAQ2N,YAAYD,GAE3C7L,EAAOxE,QAAQwB,QAAQiY,QAKvBpJ,EAAMkR,sBACNlR,GAAM8N,0BAUV,IAAK9N,EAAMmR,UAAYF,EAInB,MAFAjR,GAAMkR,sBACNlR,GAAM8N,0BAKV,IAAIsD,GAAmBnc,OAAO6Q,eAC1BuL,EAAsBD,EAAiB9K,WACvCgL,EAAsBnd,EAAOxE,QAAQ2B,MAAM4Q,SAASqP,WACpDC,GAA4C,CAKhD,IAAKxR,EAAMmR,WAAaF,EAIpB,MAFA9c,GAAOxE,QAAQyB,SAASqgB,oBAAoBtd,EAAOxE,QAAQuB,QAAQwV,aAAc1G,OACjFA,GAAM6N,gBAeV,IALA2D,EAA4CH,GAAyE,QAAlDA,EAAoB9b,WAAWkT,gBAM9F4I,EAAoBra,UAAY7C,EAAOxE,QAAQiB,KAAK8E,UAAUE,MAC7D4b,GACAF,EAgBE,CAEH,GAAII,GAAavd,EAAOxE,QAAQuB,QAAQsW,WAAW6J,EAE9CK,IAAcJ,IAEftR,EAAM6N,iBACN7N,EAAMkR,kBACNlR,EAAM8N,2BAEN3Z,EAAOxE,QAAQiB,KAAK+C,IAAI,oDAExBQ,EAAOxE,QAAQuB,QAAQ4O,aACnB/K,KAAMoS,EACNjN,MAAO/F,EAAOxE,QAAQqB,SAAS4O,mBAAmB7K,KAAMoS,MACzD,GAEHhT,EAAOxE,QAAQwB,QAAQ6T,OACvB7Q,EAAOxE,QAAQwB,QAAQgH,OAGvBhE,EAAOxE,QAAQwB,QAAQ8T,sBAlC3BjF,GAAM6N,iBAEN1Z,EAAOxE,QAAQiB,KAAK+C,IAAI,0BAExBQ,EAAOxE,QAAQuB,QAAQ8U,WAAWvB,GAG7BtQ,EAAOpB,MAAMG,OAAOuR,EAAoB,GAAGjK,YAAYC,QAExDtG,EAAOxE,QAAQwB,QAAQ8T,gBAgC/B9Q,GAAOxE,QAAQmB,GAAG0C,cAWlBmd,EAAmC,SAAU3Q,GAG7C7L,EAAOxE,QAAQwB,QAAQiY,QAGvBjV,EAAOxE,QAAQwB,QAAQmB,QAAQ8W,QAE/BpJ,EAAM6N,kBAUNgD,EAAmB,SAAU7Q,GAE7B7L,EAAOxE,QAAQuB,QAAQ6O,qBAGvB5L,EAAOxE,QAAQwB,QAAQiY,QACvBjV,EAAOxE,QAAQwB,QAAQ6T,QAWvB4L,EAAoC,WAEpCzc,EAAOxE,QAAQwB,QAAQiY;AAElBjV,EAAOxE,QAAQwB,QAAQkO,OAAOuL,gBAE/BzW,EAAOxE,QAAQwB,QAAQkO,OAAO+J,QAC9BjV,EAAOxE,QAAQuB,QAAQwS,aAmB/B6M,GAAU1R,gBAAkB,SAAUmB,GAElC2R,IAEAxd,EAAOxE,QAAQuB,QAAQ6O,mBAAmBC,EAAM3K,QAChDlB,EAAOxE,QAAQmB,GAAG0C,YAElB,IACIoe,GADA5G,EAAe7W,EAAOxE,QAAQwB,QAAQkO,OAAO4L,kBAiBjD,IAb4B,IAAxBD,EAAa7T,QAEbhD,EAAOxE,QAAQwB,QAAQkO,OAAO+J,QAKE,QAAhCpJ,EAAM3K,OAAOoT,iBAEbtU,EAAOxE,QAAQ2B,MAAMyf,wBAIkB,OAAvC5c,EAAOxE,QAAQuB,QAAQmS,YAAsB,CAK7C,GAAIwO,GAAmB1d,EAAOpB,MAAMG,OAAOiE,OAAS,EAAIhD,EAAOpB,MAAMG,OAAOiE,OAAS,EAAI,CAWzF,IARIhD,EAAOpB,MAAMG,OAAOiE,SAGpBya,EAAkBzd,EAAOxE,QAAQuB,QAAQ0S,mBAAmBzP,EAAOpB,MAAMG,OAAO2e,KAKhF1d,EAAOpB,MAAMG,OAAOiE,QAAgE,KAAtDhD,EAAOpB,MAAMG,OAAO2e,GAAkBrX,aAAsBoX,EAAgB5P,QAAQxE,MAAQrJ,EAAOtC,SAASE,mBAE1IoC,EAAOxE,QAAQ2B,MAAMgf,WAAWuB,OAE7B,CAGH,GAAI1K,GAAiBhT,EAAOtC,SAASE,kBAErCoC,GAAOxE,QAAQuB,QAAQ4O,aACnB/K,KAAQoS,EACRjN,MAAQ/F,EAAOxE,QAAQqB,SAAS4O,mBAAmB7K,KAAMoS,MAI1B,IAA/BhT,EAAOpB,MAAMG,OAAOiE,OAEpBhD,EAAOxE,QAAQ2B,MAAMgf,WAAWuB,GAKhC1d,EAAOxE,QAAQ2B,MAAM6T,eAAe0M,QAS5C1d,GAAOxE,QAAQwB,QAAQU,SAASuX,QAChCjV,EAAOxE,QAAQwB,QAAQmB,QAAQ8W,OAOnCjV,GAAOxE,QAAQwB,QAAQ6T,OACvB7Q,EAAOxE,QAAQwB,QAAQgH,MAEvB,IAAI2Z,IAAgB3d,EAAOxE,QAAQuB,QAAQmS,YAAY7I,YAAYC,OAC/DsX,EAAkB5d,EAAOxE,QAAQuB,QAAQmS,YAAYrB,QAAQxE,KAC7DwU,EAAgBD,GAAmB5d,EAAOtC,SAASE,kBAIvDoC,GAAOxE,QAAQwB,QAAQmY,iBAElBwI,GAGD3d,EAAOxE,QAAQuB,QAAQsS,YAItBwO,GAAiBF,GAGlB3d,EAAOxE,QAAQwB,QAAQ8T,iBAiB/B,IAAI0M,GAA0C,WAE1C,GAAI9L,GAAa5Q,OAAO6Q,eACpBQ,EAAaT,EAAUS,WACvB2L,GAAO,CAEX,IAA6B,IAAzBpM,EAAUqH,WAEV/Y,EAAOxE,QAAQuB,QAAQoS,wBAAyB,MAE7C,CAeH,IAbKnP,EAAOxE,QAAQiB,KAAKkG,UAAUwP,KAE/BA,EAAaA,EAAW/Q,YAKM,QAA9B+Q,EAAWmC,kBAEXwJ,GAAO,GAI0B,QAA9B3L,EAAWmC,kBAEdnC,EAAaA,EAAW/Q,WAEU,QAA9B+Q,EAAWmC,kBAEXwJ,GAAO,GAIP3L,GAAc5R,SAASmP,QAS/B1P,EAAOxE,QAAQuB,QAAQoS,wBAA0B2O,GAczD1B,GAAUtR,qBAAuB,SAAUe,GAEvC,GAAIhB,GAASvO,IAEb0D,GAAOxE,QAAQwB,QAAQqO,QAAUR,EAAOgD,QAAQjN,KAEhDZ,EAAOxE,QAAQwB,QAAQmB,QAAQ2N,YAAYD,GAC3C7L,EAAOxE,QAAQwB,QAAQiY,SAO3BmH,EAAUzR,kBAAoB,WAErB3K,EAAOnC,MAAMM,QAAQmR,UAAUK,SAAS,UAMzC3P,EAAOxE,QAAQwB,QAAQmB,QAAQ8W,QAJ/BjV,EAAOxE,QAAQwB,QAAQmB,QAAQ6F,QAqBvCoY,EAAUpR,aAAe,SAAUa,GAE/B,GAAI9F,GAAQ8F,EAAM3K,MAElB,QAAQ2K,EAAMyN,SAEV,IAAKtZ,GAAOxE,QAAQiB,KAAKmF,KAAKW,KAC9B,IAAKvC,GAAOxE,QAAQiB,KAAKmF,KAAKY,MAC1Bub,EAA8BlS,EAC9B,MAEJ,KAAK7L,GAAOxE,QAAQiB,KAAKmF,KAAKC,UAC1Bmc,EAAkBjY,EAAO8F,EACzB,MAEJ,KAAK7L,GAAOxE,QAAQiB,KAAKmF,KAAKU,GAC9B,IAAKtC,GAAOxE,QAAQiB,KAAKmF,KAAKS,KAC1B4b,EAA2BpS,IAiBvC,IAAIkS,GAAgC,SAAUlS,GAE1C,GAGIqS,GAHAxM,EAAc5Q,OAAO6Q,eACrB5S,EAAciB,EAAOpB,MAAMG,OAC3Bof,EAAczM,EAAUS,UAI5B,KAAKgM,EAED,OAAO,CAKX,MAAsC,QAA/BA,EAAY7J,iBAEf4J,EAAoBC,EAAY/c,WAChC+c,EAAoBD,CAOxB,KAFA,GAAIE,GAAuB,EAEpBD,GAAepf,EAAOqf,IAEzBA,GAQJ,KAAKD,EAAY9X,YAGb,WADArG,GAAOxE,QAAQ2B,MAAM6T,eAAeoN,EAQxC,IAGIC,GACAC,EAJAC,GAAsB,EACtBpB,GAAsB,CAoB1B,OAfAkB,GAAYF,EAAY/P,WAAW+P,EAAY/P,WAAWpL,OAAS,GAI/Dsb,EAFAte,EAAOvD,KAAKkG,UAAU0b,GAEJre,EAAOxE,QAAQuB,QAAQqU,+BAA+BiN,EAAWA,EAAUjQ,WAAWpL,QAItFqb,EAItBE,EAAmB7M,EAAUS,YAAcmM,EAC3CnB,EAAsBmB,EAAgBtb,QAAU0O,EAAUY,aAEpDiM,GAAsBpB,MAO5Bnd,GAAOxE,QAAQ2B,MAAM6T,eAAeoN,IALhCpe,EAAOxE,QAAQiB,KAAK+C,IAAI,wDACjB,IAmBXye,EAA6B,SAAUpS,GAEvC,GAGIqS,GAHAxM,EAAc5Q,OAAO6Q,eACrB5S,EAAciB,EAAOpB,MAAMG,OAC3Bof,EAAczM,EAAUS,UAI5B,KAAKgM,EAED,OAAO,CAOX,IAAgC,IAA3BzM,EAAUY,aAEX,OAAO,CAKX,MAAsC,QAA/B6L,EAAY7J,iBAEf4J,EAAoBC,EAAY/c,WAChC+c,EAAoBD,CAOxB,KAFA,GAAIE,GAAuB,EAEpBD,GAAepf,EAAOqf,IAEzBA,GAOJ,IAGII,GACAF,EAJAG,GAAsB,EACtBC,GAAsB,CAS1B,OAAKP,GAAY9X,aAOjBmY,EAAaL,EAAY/P,WAAW,GAIhCkQ,EAFAte,EAAOxE,QAAQiB,KAAKkG,UAAU6b,GAEZxe,EAAOxE,QAAQuB,QAAQqU,+BAA+BoN,EAAY,GAIlEA,EAItBC,EAAsB/M,EAAUS,YAAcmM,EAC9CI,EAAiD,IAA3BhN,EAAUY,kBAE3BmM,GAAqBC,GAEtB1e,EAAOxE,QAAQ2B,MAAMwhB,mBAAmBP,SAtBxCpe,GAAOxE,QAAQ2B,MAAMwhB,mBAAmBP,IAwC5CJ,EAAoB,SAAUjY,EAAO8F,GAErC,GACI4M,GACAmG,EACArI,EAHAjG,EAAoBtQ,EAAOxE,QAAQ2B,MAAMoT,sBAK7C,IAAIvQ,EAAOxE,QAAQiB,KAAKiJ,cAAcmG,EAAM3K,QAAS,CAGjD,GAAiC,IAA7B2K,EAAM3K,OAAOwF,MAAMJ,OAMnB,MAJAP,GAAMyJ,SAUd,GAAIzJ,EAAMM,YAAYC,OAAQ,CAK1B,GAHAmS,EAAkBzY,EAAOxE,QAAQuB,QAAQ0U,WACzCmN,EAAkBnG,EAAMoG,UAAYpG,EAAMgC,aAEtCza,EAAOxE,QAAQ2B,MAAM4Q,SAAS+Q,WAAcF,IAAmB5e,EAAOpB,MAAMG,OAAOuR,EAAoB,GAMvG,MAJAtQ,GAAOxE,QAAQuB,QAAQkW,YAAY3C,GAUtCsO,GAED7Y,EAAMyJ,SAKV+G,EAAwBvW,EAAOnC,MAAMc,SAASyP,WAAWpL,OAK3B,IAA1BuT,GAGAvW,EAAOxE,QAAQuB,QAAQmS,YAAc,KAGrClP,EAAOxE,QAAQmB,GAAG2O,kBAGlBtL,EAAOxE,QAAQmB,GAAG0C,aAGlByB,OAAOiQ,WAAW,WAEd/Q,EAAOxE,QAAQ2B,MAAMwhB,mBAAmB,IAEzC,KAIqC,IAApC3e,EAAOxE,QAAQ2B,MAAM2U,WAGrB9R,EAAOxE,QAAQ2B,MAAMwhB,mBAAmB3e,EAAOxE,QAAQ2B,MAAM2U,YAK7D9R,EAAOxE,QAAQ2B,MAAM6T,eAAehR,EAAOxE,QAAQ2B,MAAM2U,YAMjE9R,EAAOxE,QAAQwB,QAAQ6T,OAElB7Q,EAAOxE,QAAQwB,QAAQ+X,QAExB/U,EAAOxE,QAAQwB,QAAQgH,OAK3BhE,EAAOxE,QAAQmB,GAAG0C,aAGlBwM,EAAM6N,iBA8BV,OAlBA0C,GAAUxR,0BAA4B,SAAUiB,GAQ5C,GAAI8P,GAAc3b,EAAOxE,QAAQuB,QAAQmS,YAAYd,WAAW,GAAGA,WAAW,GAAG/E,IAEjFrJ,GAAOxE,QAAQwB,QAAQU,SAASwX,OAAOyG,GAGvC3b,EAAOxE,QAAQwB,QAAQmB,QAAQ8W,QAC/BjV,EAAOxE,QAAQwB,QAAQU,SAASgY,qBAI7B0G,Id6rGL,SAAUvgB,EAAQD,GAEvB,YetkIDC,GAAOD,QAAW,WAEd,GAAIsB,KAkTJ,OA7SAA,GAAKa,QAAU,WAEX,GAAIA,GAAUwC,SAAS0E,cAAc,MAIrC,OAFAlH,GAAQ+J,WAAa,eAEd/J,GAOXb,EAAKyB,SAAW,WAEZ,GAAIA,GAAW4B,SAAS0E,cAAc,MAItC,OAFAtG,GAASmJ,WAAa,cAEfnJ,GAIXzB,EAAK6hB,QAAU,WAEX,GAAIhZ,GAAQxF,SAAS0E,cAAc,MAInC,OAFAc,GAAM+B,WAAa,WAEZ/B,GAOX7I,EAAKF,QAAU,WAEX,GAAIgiB,GAAMze,SAAS0E,cAAc,MAIjC,OAFA+Z,GAAIlX,WAAa,aAEVkX,GAIX9hB,EAAK6L,eAAiB,WAElB,GAAIhL,GAAUwC,SAAS0E,cAAc,MAIrC,OAFAlH,GAAQuR,UAAUhF,IAAI,uBAEfvM,GAOXb,EAAKc,cAAgB,WAEjB,GAAIghB,GAAMze,SAAS0E,cAAc,MAIjC,OAFA+Z,GAAIlX,WAAa,oBAEVkX,GAOX9hB,EAAKyL,qBAAuB,WAExB,GAAI5K,GAAUwC,SAAS0E,cAAc,MAIrC,OAFAlH,GAAQ+J,WAAa,6BAEd/J,GAOXb,EAAK0L,qBAAuB,WAExB,GAAI7K,GAAUwC,SAAS0E,cAAc,MAIrC,OAFAlH,GAAQ+J,WAAa,6BAEd/J,GAIXb,EAAK8c,aAAe,WAEhB,GAAIvT,GAAQlG,SAAS0E,cAAc,QASnC,OAPAwB,GAAM7F,KAAc,QACpB6F,EAAMqB,WAAc,eACpBrB,EAAMnG,YAAc,sBACpBmG,EAAMiF,aAAa,OAAQ,eAE3BjF,EAAMiF,aAAa,YAAa,aAEzBjF,GAOXvJ,EAAK2L,aAAe,WAEhB,GAAI9C,GAAQxF,SAAS0E,cAAc,MAInC,OAFAc,GAAM+B,WAAa,sBAEZ/B,GAOX7I,EAAKqB,cAAgB,WAEjB,GAAIb,GAAW6C,SAAS0E,cAAc,MAItC,OAFAvH,GAASoK,WAAa,cAEfpK,GAIXR,EAAKuB,gBAAkB,WAEnB,GAAIwgB,GAAM1e,SAAS0E,cAAc,MAIjC,OAFAga,GAAI3P,UAAUhF,IAAI,uBAEX2U,GAIX/hB,EAAKiM,gBAAkB,WAEnB,GAAI8V,GAAM1e,SAAS0E,cAAc,MAIjC,OAFAga,GAAI3P,UAAUhF,IAAI,sBAEX2U,GAIX/hB,EAAKkB,WAAa,WAEd,GAAIyM,GAAStK,SAAS0E,cAAc,OAKpC,OAHA4F,GAAO/C,UAAY,mBAGZ+C,GAOX3N,EAAK+L,eAAiB,WAElB,GAAIiW,GAAU3e,SAAS0E,cAAc,OAOrC,OALAia,GAAQpX,UAAY,2BAGpBoX,EAAQtR,UAAY,8BAEbsR,GAQXhiB,EAAKiB,QAAU,WAEX,GAAIJ,GAAUwC,SAAS0E,cAAc,MAIrC,OAFAlH,GAAQ+J,UAAY,oBAEb/J,GAaXb,EAAK2M,cAAgB,SAAUjJ,EAAMue,GAEjC,GAAItU,GAAatK,SAAS0E,cAAc,MACpCma,EAAY7e,SAAS0E,cAAc,KACnCoa,EAAY9e,SAAS0E,cAAc,OAYvC,OAVA4F,GAAOgD,QAAQjN,KAAOA,EACtBiK,EAAOa,aAAa,QAAS9K,GAE7Bwe,EAAS9P,UAAUhF,IAAI6U,GACvBE,EAAU/P,UAAUhF,IAAI,2BAGxBO,EAAOtF,YAAY6Z,GACnBvU,EAAOtF,YAAY8Z,GAEZxU,GAYX3N,EAAKkN,oBAAsB,SAAUxJ,EAAMue,GAEvC,GAAItU,GAAatK,SAAS0E,cAAc,UACpCma,EAAY7e,SAAS0E,cAAc,IAQvC,OANA4F,GAAOjK,KAAO,SACdiK,EAAOgD,QAAQjN,KAAOA,EACtBwe,EAAS9P,UAAUhF,IAAI6U,GAEvBtU,EAAOtF,YAAY6Z,GAEZvU,GAOX3N,EAAK6I,MAAQ,SAAUF,EAAS9I,GAE5B,GAAIkP,GAAO1L,SAAS0E,cAAcY,EAIlC,OAFAoG,GAAK2B,UAAY7Q,GAAW,GAErBkP,GAUX/O,EAAK+O,KAAO,SAAWpG,EAASiC,EAAWwX,GAEvC,GAAI1c,GAAKrC,SAAS0E,cAAeY,EAIjC,IAFKiC,IAAYlF,EAAGkF,UAAYA,GAE3BwX,EAED,IAAK,GAAInV,KAAQmV,GAEb1c,EAAGuH,GAAQmV,EAAWnV,EAM9B,OAAOvH,IAOX1F,EAAKyQ,iBAAmB,WAEpB,GAAI5P,GAAUwC,SAAS0E,cAAc,MAIrC,OAFAlH,GAAQuR,UAAUhF,IAAI,yBAEfvM,GAIJb,If4jIL,SAAUrB,EAAQD,GAEvB,YgBl3IDC,GAAOD,QAAW,WAEd,GAAIuB,MAEA6C,EAAS1D,IAqSb,OAhSAa,GAAM2U,WAAa,KAKnB3U,EAAM6a,OAAS,KAKf7a,EAAMoiB,iBAAmB,KAQzBpiB,EAAMyT,IAAM,SAAWhO,EAAIuK,EAAO6K,GAE9BA,EAASA,GAAU7a,EAAM6a,QAAU,EACnC7K,EAASA,GAAUhQ,EAAMoiB,kBAAoB,CAE7C,IACIC,GADAC,EAAS7c,EAAGwL,UAchB,IATIoR,EAFmB,IAAlBC,EAAOzc,OAEIJ,EAIA6c,EAAOtS,GAKG,QAAtBvK,EAAG0R,gBAGH,WADA1R,GAAGqX,OAKHja,GAAOxE,QAAQiB,KAAKkG,UAAU6c,KAE9BA,EAAYxf,EAAOxE,QAAQuB,QAAQqU,+BAA+BoO,EAAWA,EAAUpR,WAAWpL,QAItG,IAAIyV,GAAYlY,SAASoY,cACrBjH,EAAY5Q,OAAO6Q,cAEvB7Q,QAAOiQ,WAAW,WAEd0H,EAAMoC,SAAS2E,EAAWxH,GAC1BS,EAAM8B,OAAOiF,EAAWxH,GAExBtG,EAAUyJ,kBACVzJ,EAAU0J,SAAS3C,GAEnBzY,EAAOxE,QAAQ2B,MAAMyf,yBAEtB,KAQPzf,EAAMyf,sBAAwB,WAG1B,GAGIsB,GAHAxM,EAAc5Q,OAAO6Q,eACrB5S,EAAciB,EAAOpB,MAAMG,OAC3Bof,EAAczM,EAAUS,UAG5B,IAAKgM,EAAL,CAOA,KAAsC,QAA/BA,EAAY7J,iBAEf4J,EAAoBC,EAAY/c,WAChC+c,EAAoBD,CAOxB,KAFA,GAAIE,GAAuB,EAEpBD,GAAepf,EAAOqf,IAEzBA,GAIJjhB,GAAM2U,WAAasM,IAOvBjhB,EAAMoT,qBAAuB,WAEzB,MAAOpT,GAAM2U,YAOjB3U,EAAM6T,eAAiB,SAAU7D,GAE7B,GAAIpO,GAASiB,EAAOpB,MAAMG,OACtB2gB,EAAY3gB,EAAOoO,EAAQ,EAE/B,KAAKuS,EAGD,WADA1f,GAAOxE,QAAQiB,KAAK+C,IAAI,yBAS5B,KAAKkgB,EAAUtR,WAAWpL,OAAQ,CAE9B,GAAI2c,GAAmBpf,SAASoQ,eAAe,GAE/C+O,GAAUna,YAAYoa,GAI1B3f,EAAOxE,QAAQ2B,MAAM2U,WAAa3E,EAAQ,EAC1CnN,EAAOxE,QAAQ2B,MAAMyT,IAAI8O,EAAW,EAAG,GACvC1f,EAAOxE,QAAQuB,QAAQ6O,mBAAmB8T,IAQ9CviB,EAAMgf,WAAa,SAAUhP,GAEzB,GAAIpO,GAASiB,EAAOpB,MAAMG,OACtBoU,EAAcpU,EAAOoO,EAEzB,IAAMgG,EAAN,CAUA,IAAKA,EAAY/E,WAAWpL,OAAQ,CAEhC,GAAI2c,GAAmBpf,SAASoQ,eAAe,GAE/CwC,GAAY5N,YAAYoa,GAI5B3f,EAAOxE,QAAQ2B,MAAM2U,WAAa3E,EAClCnN,EAAOxE,QAAQ2B,MAAMyT,IAAIuC,EAAa,EAAG,GACzCnT,EAAOxE,QAAQuB,QAAQ6O,mBAAmBuH,KAO9ChW,EAAMwhB,mBAAqB,SAAUxR,GAEjCA,EAAQA,GAAS,CAEjB,IAEIyS,GACAC,EACAF,EAJA5gB,EAASiB,EAAOpB,MAAMG,OACtB+gB,EAAgB/gB,EAAOoO,EAAQ,EAMnC,OAAK2S,IAOLF,EAAgB5f,EAAOxE,QAAQuB,QAAQqU,+BAA+B0O,EAAeA,EAAc1R,WAAWpL,QAC9G6c,EAAwBD,EAAc5c,OAMjC8c,EAAc1R,WAAWpL,SAE1B2c,EAAmBpf,SAASoQ,eAAe,IAC3CmP,EAAcva,YAAYoa,IAG9B3f,EAAOxE,QAAQ2B,MAAM2U,WAAa3E,EAAQ,EAC1CnN,EAAOxE,QAAQ2B,MAAMyT,IAAIkP,EAAeA,EAAc1R,WAAWpL,OAAS,EAAG6c,OAC7E7f,GAAOxE,QAAQuB,QAAQ6O,mBAAmB7M,EAAOoO,EAAQ,SApBrDnN,GAAOxE,QAAQiB,KAAK+C,IAAI,8BAwBhCrC,EAAM4Q,UAEF+Q,QAAU,WAEN,GAAIpN,GAAkB5Q,OAAO6Q,eACzBW,EAAkBZ,EAAUY,aAC5BH,EAAkBT,EAAUS,WAC5BsL,EAAkBzd,EAAOxE,QAAQuB,QAAQ0S,mBAAmB0C,GAC5D4N,EAAkBtC,EAAgBrP,WAAW,EAE5CpO,GAAOxE,QAAQiB,KAAKkG,UAAUwP,KAE/BA,EAAaA,EAAW/Q,WAI5B,IAAI4e,GAAe7N,IAAe4N,EAAc3R,WAAW,GACvD6R,EAAgC,IAAjB3N,CAEnB,OAAO0N,IAAeC,GAI1B7C,SAAW,WAEP,GAAI1L,GAAe5Q,OAAO6Q,eACtBW,EAAeZ,EAAUY,aACzBH,EAAeT,EAAUS,UAG7B,QAAQA,IAAeA,EAAWnP,QAAUsP,IAAiBH,EAAWnP,SAUhF7F,EAAM+iB,WAAa,SAAUjU,GAEzB,GAAIyF,GAAW+G,EACX0H,EAAWlU,CAEXA,GAAKpJ,UAAY7C,EAAOxE,QAAQiB,KAAK8E,UAAUI,oBAE/Cwe,EAAWlU,EAAKoS,WAIpB3M,EAAY5Q,OAAO6Q,eAEnB8G,EAAQ/G,EAAUE,WAAW,GAC7B6G,EAAM2H,iBAEN3H,EAAMyH,WAAWjU,GAEjBwM,EAAM4H,cAAcF,GACpB1H,EAAMG,UAAS,GAEflH,EAAUyJ,kBACVzJ,EAAU0J,SAAS3C,IAKhBtb,IhBq2IL,SAAUtB,EAAQD,GAEvB,YiBhpJDC,GAAOD,QAAW,WAEd,GAAIwB,MAEA4C,EAAS1D,KAETgkB,KAEAC,EAAa,SAAU7iB,GAEvB4iB,EAAMpZ,KAAKxJ,EAIX,KAFA,GAAIyP,GAAQ,EAEJA,EAAQmT,EAAMtd,QAAUsd,EAAMtd,OAAS,GAElB,WAArBsd,EAAMnT,GAAOvM,MAA0C,UAArB0f,EAAMnT,GAAOvM,MAOnD0f,EAAMnT,GAAO8H,QACbqL,EAAME,OAAOrT,EAAO,IANhBA,IAuMZ,OA3LA/P,GAAcgM,aAAe,WAEzB,GAAItL,GAASkC,EAAOxE,QAAQ0B,KAAK+O,KAAK,MAAO,0BAI7C,OAFAjM,GAAOnC,MAAMT,cAAgBmD,SAASmP,KAAKnK,YAAYzH,GAEhDA,GASXV,EAAcqjB,YAAc,SAAUC,EAAU7U,GAE5C7L,EAAOxE,QAAQ4B,cAAcujB,cAAcC,QAAS,yCAA0ChgB,KAAMiL,EAAMjL,QAoB9GxD,EAAcujB,aAAe,SAAUE,GA8CnC,QAASC,GAAOpjB,GAEZ,IAAMA,IAAYA,EAASkjB,QAGvB,WADA5gB,GAAOxE,QAAQiB,KAAK+C,IAAI,+CAK5B9B,GAASkD,KAAOlD,EAASkD,MAAQ,QACjClD,EAASsR,KAAqB,IAAdtR,EAASsR,MAAa,GAEtC,IAAIjR,GAAUiC,EAAOxE,QAAQ0B,KAAK+O,KAAK,MAAO,oBAC1C2U,EAAU5gB,EAAOxE,QAAQ0B,KAAK+O,KAAK,MAAO,6BAC1CxF,EAAQzG,EAAOxE,QAAQ0B,KAAK+O,KAAK,QAAS,2BAC1C8U,EAAQ/gB,EAAOxE,QAAQ0B,KAAK+O,KAAK,OAAQ,4BACzC+U,EAAYhhB,EAAOxE,QAAQ0B,KAAK+O,KAAK,OAAQ,+BAEjD2U,GAAQva,YAAc3I,EAASkjB,QAC/BG,EAAM1a,YAAc3I,EAASujB,OAAS,KACtCD,EAAU3a,YAAc3I,EAASwjB,WAAa,SAE9ClhB,EAAOxE,QAAQ+B,UAAU+M,IAAIyW,EAAO,QAASI,GAC7CnhB,EAAOxE,QAAQ+B,UAAU+M,IAAI0W,EAAW,QAASI,GAEjDrjB,EAAQwH,YAAYqb,GAEC,UAAjBljB,EAASkD,MAET7C,EAAQwH,YAAYkB,GAIxB1I,EAAQwH,YAAYwb,GAEC,UAAjBrjB,EAASkD,MAAqC,WAAjBlD,EAASkD,MAEtC7C,EAAQwH,YAAYyb,GAIxBjjB,EAAQuR,UAAUhF,IAAI,oBAAsB5M,EAASkD,MACrD7C,EAAQ8P,QAAQjN,KAAOlD,EAASkD,KAEhC+f,EAAe5iB,EACf6C,EAAelD,EAASkD,KACxBygB,EAAe3jB,EAAS2jB,QACxBC,EAAe5jB,EAAS4jB,OACxBC,EAAe9a,EAEM,UAAjB/I,EAASkD,MAAqC,WAAjBlD,EAASkD,MAEtCE,OAAOiQ,WAAWkE,EAAOvX,EAASsR,MAM1C,QAASpK,KAEL5E,EAAOnC,MAAMT,cAAcmI,YAAYob,GACvCY,EAAWtH,QAEXja,EAAOnC,MAAMT,cAAckS,UAAUhF,IAAI,4CAEzCxJ,OAAOiQ,WAAW,WAEd/Q,EAAOnC,MAAMT,cAAckS,UAAUE,OAAO,6CAE7C,KAEH+Q,GAAY3f,KAAMA,EAAMqU,MAAOA,IAInC,QAASA,KAEL0L,EAAanR,SAxHjB,GAAImR,GAAe,KACfW,EAAe,KACf1gB,EAAe,KACfygB,EAAe,KACfE,EAAe,KAEfJ,EAAiB,WAIjB,GAFAlM,IAEuB,kBAAZoM,GAMX,MAAY,UAARzgB,MAEAygB,GAAQE,EAAW7a,WAKvB2a,MAIAD,EAAgB,WAEhBnM,IAEsB,kBAAXqM,IAMXA,IA+FJ,OAPIT,KAEAC,EAAOD,GACPjc,MAKAkc,OAAQA,EACRlc,KAAMA,EACNqQ,MAAOA,IAKf7X,EAAcmX,MAAQ,WAElBvU,EAAOnC,MAAMT,cAAcwQ,UAAY,GACvC0S,MAIGljB,IjBsoJL,SAAUvB,EAAQD,GAEvB,YkBj2JDC,GAAOD,QAAW,WAEd,GAAIyB,MAEA2C,EAAS1D,IAwBb,OArBAe,GAAOmkB,oBAAsB,SAAUpR,EAAWoL,GAE9Cxb,EAAOxE,QAAQuB,QAAQ4O,aACnB/K,KAAQwP,EAAUxP,KAClBmF,MAAQqK,EAAUxG,QACdyH,KAAOmK,EAAI5N,eASvBvQ,EAAOokB,kBAAoB,SAAUxV,GAEjC,MAAOA,GAAKpJ,UAAY7C,EAAOxE,QAAQiB,KAAK8E,UAAUC,KAClDyK,EAAKqD,UAAUK,SAAS3P,EAAOxE,QAAQmB,GAAGmL,UAAUC,kBAIrD1K,IlB42JL,SAAUxB,EAAQD,EAASH,GAEhC,YmB74JDI,GAAOD,QAAW,WAEd,GAAI0B,MAGAokB,EAAUjmB,EAAQ,IAGlBuE,EAAU1D,IAEdgB,GAAU4B,QAAU,WAEZc,EAAOtC,SAASJ,YAAc0C,EAAOxE,QAAQiB,KAAKqG,QAAQ9C,EAAOtC,SAASJ,aAE1EqkB,EAAOC,OAAS5hB,EAAOtC,SAASJ,WASxC,IAAIqkB,IAGAC,OAAS,KAETC,OAEIC,MACI3lB,KACA4lB,GACIC,MAAM,EACN9gB,OAAQ,SACR+gB,IAAK,cAMrB3kB,GAAUqkB,OAASA,CAYnB,IAAIO,GAAQ,SAAUC,GAElB,GAAIC,GAAgBD,GAAoBR,EAAOC,QAAUD,EAAOE,KAEhE,OAAO,IAAIH,GAAQU,GAkBvB,OARA9kB,GAAU+kB,MAAQ,SAAUC,EAAaC,GAErC,GAAIC,GAAkBN,EAAMK,EAE5B,OAAOC,GAAgBH,MAAMC,IAI1BhlB,InBo5JL,SAAUzB,EAAQD,EAASH,GoBn+JjC,GAAAgnB,GAAAC,GAAA,SAAAC,EAAAC,GAEAH,EAAA,EAAAC,EAAA,kBAAAD,KAAAzmB,KAAAJ,EAAAH,EAAAG,EAAAC,GAAA4mB,IAAAhiB,SAAAiiB,IAAA7mB,EAAAD,QAAA8mB,KAMCpmB,KAAA,WAMD,QAAAumB,GAAAhb,GAEA,GAAAib,GAAAjb,EAAA,KACAia,EAAA/e,OAAAnB,KAAAkhB,GAEAC,EAAAjB,EACA1W,IAAA,SAAA4X,GAAwB,aAAAF,GAAAE,KACxBC,MAAA,SAAAriB,GAA6B,iBAAAA,GAAA,YAAAA,GAAA,aAAAA,GAE7B,KAAAmiB,EACA,SAAAriB,OAAA,gCAGApE,MAAAuL,SAKA,QAAAqb,GAAAjX,GACA,MAAAkX,GAAAvd,QAAAqG,EAAAmX,aAAA,EAIA,QAAAC,GAAApX,GACA,MAAAqX,GAAA1d,QAAAqG,EAAAmX,aAAA,EAsGA,QAAAG,GAAAtX,GACA,MAAA1L,UAAAgjB,iBAAAtX,EACAuX,WAAAC,UAAAD,WAAAE,aAAAF,WAAAG,aACA,SAGA,QAAAC,GAAA/b,EAAAub,EAAAnX,GACA,wBAAApE,GAAAia,KAAAsB,GACAvb,EAAAia,KAAAsB,GAAAnX,GAEApE,EAAAia,KAAAsB,GAIA,QAAAS,GAAA5X,EAAA6X,GACA,yBAAAA,IAEK,iBAAAA,KACLA,EAMA,QAAAC,GAAAC,EAAAF,EAAA7X,GACA,GAAAgY,GAAAD,EAAA7Z,KAAA+Z,aAEA,OAAAJ,MAAA,IAEK,kBAAAA,GAAAG,IACLH,EAAAG,GAAAD,EAAAtd,MAAAuF,GACK,mBAAA6X,GAAAG,KAEAH,EAAAG,MAAA,GAEA,gBAAAH,GAAAG,IACLH,EAAAG,KAAAD,EAAAtd,QAjJA,GAAAyc,IAAA,8DAKAG,GAAA,mDAkJA,OA7IAT,GAAA9iB,UAAAsiB,MAAA,SAAAnU,GACA,GAAAiW,GAAA5jB,SAAA0E,cAAA,MAKA,OAJAkf,GAAAvW,UAAAM,EAEA5R,KAAA8nB,UAAAD,GAEAA,EAAAvW,WAGAiV,EAAA9iB,UAAAqkB,UAAA,SAAAhjB,GACA,GAAAijB,GAAAd,EAAAniB,GACA6K,EAAAoY,EAAA7F,YACA,IAAAvS,EAEA,EAEA,KAAAA,EAAAqY,WAIA,GAAArY,EAAApJ,WAAA0hB,KAAAC,UAAA,CAkBA,GAAAvY,EAAApJ,WAAA0hB,KAAAE,aAAA,CACArjB,EAAAmQ,YAAAtF,GACA3P,KAAA8nB,UAAAhjB,EACA,OAGA,GACAsjB,GADAC,EAAAtB,EAAApX,EAEA0Y,KACAD,EAAAne,MAAAxG,UAAA6kB,KAAA5oB,KAAAiQ,EAAAmC,WAAA8U,GAKA,IAAA2B,KAAAzjB,aACA0jB,EACA5B,EAAA9hB,IACA8hB,EAAAjX,IACA4Y,EAEAzB,EAAAnX,EAAAmX,SAAAc,cAEAJ,EAAAF,EAAAtnB,KAAAuL,OAAAub,EAAAnX,GAEA8Y,EAAAJ,GAAAD,CAIA,IAAAK,GAAAlB,EAAA5X,EAAA6X,KACAxnB,KAAAuL,OAAAmd,yBAAAF,EAAA,CAEA,cAAA7Y,EAAAmX,UAAA,UAAAnX,EAAAmX,SACA,KAAAnX,EAAAmC,WAAApL,OAAA,GACA5B,EAAAC,aAAA4K,EAAAmC,WAAA,GAAAnC,EAGA7K,GAAAmQ,YAAAtF,GAEA3P,KAAA8nB,UAAAhjB,EACA,OAIA,OAAA2gB,GAAA,EAAqBA,EAAA9V,EAAAgZ,WAAAjiB,OAA4B+e,GAAA,GACjD,GAAAiC,GAAA/X,EAAAgZ,WAAAlD,EAEAgC,GAAAC,EAAAF,EAAA7X,KACAA,EAAAiZ,gBAAAlB,EAAA7Z,MAEA4X,GAAA,GAKAzlB,KAAA8nB,UAAAnY,GAGAA,EAAAqY,YAAA,MArEA,SAAArY,EAAA7L,KAAAkG,SACA2F,EAAAkZ,wBAAAjC,EAAAjX,EAAAkZ,yBACAlZ,EAAAmZ,oBAAAlC,EAAAjX,EAAAmZ,qBAAA,CACAhkB,EAAAmQ,YAAAtF,GACA3P,KAAA8nB,UAAAhjB,EACA,aAiEK6K,EAAAoY,EAAA/iB,gBA6CLuhB,KpB4+JM,SAAUhnB,EAAQD,GAEvB,YqB1pKDC,GAAOD,QAAU,WAEb,GAAI2B,MAEA8nB,IAiLJ,OAxKA9nB,GAAU+nB,OAAS,WAEf,GAAIC,GAAY,SAAUpkB,EAASqkB,GAE/B,GAAIC,KAEJD,GAAUA,GAAWH,CAErB,KAAK,GAAIjZ,GAAI,EAAGA,EAAIoZ,EAAQxiB,OAAQoJ,IAAK,CAErC,GAAIsZ,GAAWF,EAAQpZ,EAEnBsZ,GAASvkB,UAAYA,GAErBskB,EAAmBve,KAAKwe,GAMhC,MAAOD,IAIPE,EAAS,SAAUC,EAAWJ,GAE9B,GAAIK,KAEJL,GAAUA,GAAWH,CAErB,KAAK,GAAIjZ,GAAI,EAAGA,EAAIoZ,EAAQxiB,OAAQoJ,IAAK,CAErC,GAAIsZ,GAAWF,EAAQpZ,EAEnBsZ,GAAS9kB,OAASglB,GAElBC,EAAkB3e,KAAKwe,GAM/B,MAAOG,IAIPC,EAAY,SAAUC,EAASP,GAE/B,GAAIQ,KAEJR,GAAUA,GAAWH,CAErB,KAAK,GAAIjZ,GAAI,EAAGA,EAAIoZ,EAAQxiB,OAAQoJ,IAAK,CAErC,GAAIsZ,GAAWF,EAAQpZ,EAEnBsZ,GAASK,UAAYA,GAErBC,EAAqB9e,KAAKwe,GAMlC,MAAOM,IAIPC,EAAM,SAAU9kB,EAASykB,EAAWG,GAEpC,GAAIlX,GAASwW,CAWb,OATIlkB,KACA0N,EAAS0W,EAAUpkB,EAAS0N,IAE5B+W,IACA/W,EAAS8W,EAAOC,EAAW/W,IAE3BkX,IACAlX,EAASiX,EAAUC,EAASlX,IAEzBA,EAAO,IAIdzB,EAAM,SAAUjM,EAASykB,EAAWG,GAEpC,GAAIlX,GAASwW,CAWb,OATIlkB,KACA0N,EAAS0W,EAAUpkB,EAAS0N,IAE5B+W,IACA/W,EAAS8W,EAAOC,EAAW/W,IAE3BkX,IACAlX,EAASiX,EAAUC,EAASlX,IAEzBA,EAIX,QACI0W,UAAcA,EACdI,OAAcA,EACdG,UAAcA,EACdG,IAAcA,EACd7Y,IAAcA,MAKtB7P,EAAU+M,IAAM,SAAUnJ,EAASykB,EAAWG,EAASG,GAEnD/kB,EAAQglB,iBAAiBP,EAAWG,EAASG,EAE7C,IAAI9lB,IACAe,QAASA,EACTP,KAAMglB,EACNG,QAASA,GAGTK,EAAuB7oB,EAAU+nB,OAAOW,IAAI9kB,EAASykB,EAAWG,EAE/DK,IAEDf,EAAane,KAAK9G,IAM1B7C,EAAUiS,OAAS,SAAUrO,EAASykB,EAAWG,GAE7C5kB,EAAQklB,oBAAoBT,EAAWG,EAIvC,KAAK,GAFDO,GAAoB/oB,EAAU+nB,OAAOlY,IAAIjM,EAASykB,EAAWG,GAExD3Z,EAAI,EAAGA,EAAIka,EAAkBtjB,OAAQoJ,IAAK,CAE/C,GAAIe,GAAQkY,EAAazf,QAAQ0gB,EAAkBla,GAE/Ce,GAAQ,GAERkY,EAAa7E,OAAOrT,EAAO,KAQvC5P,EAAUgpB,UAAY,WAElBlB,EAAaja,IAAI,SAAUC,GAEvB9N,EAAUiS,OAAOnE,EAAQlK,QAASkK,EAAQzK,KAAMyK,EAAQ0a,YAMhExoB,EAAUipB,IAAM,SAAUrlB,EAASykB,EAAWG,GAE1C,MAAOxoB,GAAU+nB,OAAOlY,IAAIjM,EAASykB,EAAWG,IAI7CxoB,IrBipKL,SAAU1B,EAAQD,GAEvB,YAEA,IAAI8D,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,QAAUE,IAAQF,OAAOI,UAAY,eAAkBF,GsB70KvQhE,GAAOD,QAAU,WAEb,GAAI4B,MAEAwC,EAAS1D,IAsFb,OApFAkB,GAAUipB,YAAc,WAEpBzmB,EAAOnC,MAAME,QAAQyR,SACrBxP,EAAOnC,MAAMT,cAAcoS,UAI/BhS,EAAUkpB,eAAiB,WAEvB,IAAK,GAAIrd,KAAQrJ,GAAOtD,MAEsB,kBAA/BsD,GAAOtD,MAAM2M,GAAMsd,SAE1B3mB,EAAOtD,MAAM2M,GAAMsd,WAQ/BnpB,EAAUopB,eAAiB,WAIvB,IAAK,GAFDC,GAAUtmB,SAASumB,qBAAqB,UAEnC1a,EAAI,EAAGA,EAAIya,EAAQ7jB,OAAQoJ,IAE5Bya,EAAQza,GAAGtQ,GAAG8J,QAAQ5F,EAAOxD,cAAgB,IAE7CqqB,EAAQza,GAAGoD,SACXpD,MAmBZ5O,EAAUmpB,QAAU,SAAUjpB,GAErBA,GAAgC,YAApB,mBAAOA,GAAP,YAAAgC,EAAOhC,MAMpBA,EAASf,KAETa,EAAUipB,cACVzmB,EAAOxE,QAAQ+B,UAAUgpB,aAIzB7oB,EAASmpB,SAETrpB,EAAUopB,iBAIVlpB,EAAS0J,SAET5J,EAAUkpB,iBAIVhpB,EAASf,IAAMe,EAASmpB,SAAWnpB,EAASjB,OAE5CuD,EAAS,QAMVxC,ItB60KL,SAAU3B,EAAQD,GAEvB,YuBz6KDC,GAAOD,QAAU,WAEb,GAAI6B,MAEAuC,EAAS1D,KAETyqB,IAEJtpB,GAAMyB,QAAU,WAEZ,GAAIxC,GAAQsD,EAAOtD,KAEnB,KAAK,GAAI2M,KAAQ3M,GAERA,EAAM2M,GAAM2d,uBAA0BzgB,MAAM0gB,QAAQvqB,EAAM2M,GAAM2d,wBAMrEtqB,EAAM2M,GAAM2d,sBAAsB5b,IAAI,SAAU8b,GAG5CH,EAAS7f,KAAKggB,IAMtB,OAAOjnB,SAAQC,WAQnBzC,EAAM0pB,OAAS,SAAUtb,GAErB,GAAIub,GAAgBvb,EAAMwb,eAAiBvmB,OAAOumB,cAC9CtqB,EAAUqqB,EAAcE,QAAQ,QAEhCzY,EAAS0Y,EAAQxqB,EASrB,OAPI8R,KAEAhD,EAAM6N,iBACN7N,EAAM8N,4BAIH9K,EAQX,IAAI0Y,GAAU,SAAUC,GAEpB,GAAI3Y,IAAU,EACV9R,EAAUiD,EAAOxE,QAAQuB,QAAQmS,YACjCjI,EAAUlK,EAAQ8Q,QAAQxE,IAuB9B,OArBA0d,GAAS3b,IAAK,SAAU8b,GAEpB,GAAIO,GAAYP,EAAQQ,MAAMC,KAAKH,GAC/BI,EAAYH,GAAaA,EAAU,EAElCG,IAASA,IAAUJ,EAAOlhB,SAGtBvJ,EAAQsJ,YAAYC,QAAUW,GAAUjH,EAAOtC,SAASE,oBAEzDiqB,IAIJX,EAAQjqB,SAASuqB,EAAQN,GACzBrY,GAAS,KAMVA,GAIPgZ,EAAmB,WAGnB7nB,EAAOxE,QAAQuB,QAAQ4O,aAEnB/K,KAAOZ,EAAOtC,SAASE,mBACvBmI,MAAQ/F,EAAOtD,MAAMsD,EAAOtC,SAASE,oBAAoBgM,QACrDyH,KAAO,OAGZ,GAcP5T,GAAMwN,mBAAqB,SAAUY,GAGjC,GAAKic,EAAwBjc,EAAM3K,QAAnC,CAOA2K,EAAM6N,gBAGN,IAKIqO,GACAC,EANAtU,EAAY7H,EAAMwb,cAAcC,QAAQ,aACxC3T,EAAY9H,EAAMwb,cAAcC,QAAQ,cAGxCW,EAAajoB,EAAOxE,QAAQ0B,KAAK+O,KAAK,MAAO,MAiBjD,OAZA8b,GAAY/nB,EAAOxE,QAAQ8B,UAAU+kB,MAAM3O,GAM3CsU,EAAchoB,EAAOxE,QAAQuB,QAAQ0W,uBAAuBsU,EAAWpU,GACvEsU,EAAWra,UAAYoa,EAKa,GAAhCC,EAAW7Z,WAAWpL,WAEtBklB,GAA0BD,EAAWzJ,gBAKzC2J,GAAuBF,EAAW7Z,aAUtC,IAAI0Z,GAA0B,SAAU/hB,GAGpC,GAAK/F,EAAOxE,QAAQiB,KAAKiJ,cAAcK,GAEnC,OAAO,CAIX,IAAIqiB,GAAiBpoB,EAAOxE,QAAQuB,QAAQsX,kBAAkBtO,EAG9D,SAAKqiB,GAeLD,EAAyB,SAAUF,GAEnC,GAAIjV,GAAiBhT,EAAOtC,SAASE,mBACjCsR,EAAclP,EAAOxE,QAAQuB,QAAQmS,WAGzC+Y,GAAWzhB,QAAQ,SAAUqN,GAGrB7T,EAAOxE,QAAQiB,KAAKqJ,aAAa+N,KAMrC7T,EAAOxE,QAAQuB,QAAQ4O,aACnB/K,KAAQoS,EACRjN,MAAQ/F,EAAOtD,MAAMsW,GAAgBpJ,QACjCyH,KAAOwC,EAAUjG,cAIzB5N,EAAOxE,QAAQ2B,MAAM2U,gBAIzB9R,EAAOxE,QAAQ2B,MAAMwhB,mBAAmB3e,EAAOxE,QAAQ2B,MAAMoT,uBAAyB,GAMlFvQ,EAAOxE,QAAQiB,KAAKqJ,aAAaoJ,KAEjCA,EAAYM,SACZxP,EAAOxE,QAAQmB,GAAG0C,eAYtB6oB,EAA4B,SAAUjc,GAEtC,GAAI8G,EAEA9G,GAAKoc,mBAELtV,EAAUxS,SAAS+nB,yBAEnBrc,EAAKmC,WAAW5H,QAAQ,SAAU6E,IAEzBrL,EAAOxE,QAAQiB,KAAKkG,UAAU0I,IAAoC,KAAxBA,EAAQjL,KAAKkG,SAM5DyM,EAAQxN,YAAY8F,EAAQ4I,WAAU,OAM1ClB,EAAUxS,SAASoQ,eAAe1E,EAAK5F,aAI3CrG,EAAOxE,QAAQ2B,MAAM+iB,WAAWnN,GAKpC,OAAOtV","file":"codex-editor.js","sourcesContent":["var codex = codex || {}; codex[\"editor\"] =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t *\n\t * Codex Editor\n\t *\n\t * @author Codex Team\n\t */\n\t\n\tmodule.exports = function (userSettings) {\n\t\n\t    'use strict';\n\t\n\t    var self = this;\n\t\n\t    self.version = (\"1.7.7\");\n\t    self.scriptPrefix = 'cdx-script-';\n\t\n\t    self.modules = {\n\t        core: __webpack_require__(1),\n\t        tools: __webpack_require__(2),\n\t        ui: __webpack_require__(3),\n\t        transport: __webpack_require__(4),\n\t        renderer: __webpack_require__(5),\n\t        saver: __webpack_require__(6),\n\t        content: __webpack_require__(7),\n\t        toolbar: __webpack_require__(8),\n\t        callback: __webpack_require__(12),\n\t        draw: __webpack_require__(13),\n\t        caret: __webpack_require__(14),\n\t        notifications: __webpack_require__(15),\n\t        parser: __webpack_require__(16),\n\t        sanitizer: __webpack_require__(17),\n\t        listeners: __webpack_require__(19),\n\t        destroyer: __webpack_require__(20),\n\t        paste: __webpack_require__(21)\n\t    };\n\t\n\t    for (var _module in self.modules) {\n\t\n\t        self.modules[_module] = self.modules[_module].call(self);\n\t    }\n\t\n\t    /**\n\t     * @public\n\t     * holds initial settings\n\t     */\n\t    self.settings = {\n\t        tools: ['paragraph', 'header', 'picture', 'list', 'quote', 'code', 'twitter', 'instagram', 'smile'],\n\t        holderId: 'codex-editor',\n\t\n\t        // Type of block showing on empty editor\n\t        initialBlockPlugin: 'paragraph'\n\t    };\n\t\n\t    /**\n\t     * public\n\t     *\n\t     * Static nodes\n\t     */\n\t    self.nodes = {\n\t        holder: null,\n\t        wrapper: null,\n\t        toolbar: null,\n\t        inlineToolbar: {\n\t            wrapper: null,\n\t            buttons: null,\n\t            actions: null\n\t        },\n\t        toolbox: null,\n\t        notifications: null,\n\t        plusButton: null,\n\t        showSettingsButton: null,\n\t        showTrashButton: null,\n\t        blockSettings: null,\n\t        pluginSettings: null,\n\t        defaultSettings: null,\n\t        toolbarButtons: {}, // { type : DomEl, ... }\n\t        redactor: null\n\t    };\n\t\n\t    /**\n\t     * @public\n\t     *\n\t     * Output state\n\t     */\n\t    self.state = {\n\t        jsonOutput: [],\n\t        blocks: [],\n\t        inputs: []\n\t    };\n\t\n\t    /**\n\t    * @public\n\t    * Editor plugins\n\t    */\n\t    self.tools = {};\n\t\n\t    /**\n\t     * Initialization\n\t     * @uses Promise cEditor.core.prepare\n\t     * @param {Object} userSettings\n\t     * @param {Array}  userSettings.tools       list of plugins\n\t     * @param {String} userSettings.holderId    Element's id to append editor\n\t     *\n\t     * Load user defined tools\n\t     * Tools must contain this important objects :\n\t     *  @param {String} type - this is a type of plugin. It can be used as plugin name\n\t     *  @param {String} iconClassname - this a icon in toolbar\n\t     *  @param {Object} make - what should plugin do, when it is clicked\n\t     *  @param {Object} appendCallback - callback after clicking\n\t     *  @param {Element} settings - what settings does it have\n\t     *  @param {Object} render - plugin get JSON, and should return HTML\n\t     *  @param {Object} save - plugin gets HTML content, returns JSON\n\t     *  @param {Boolean} displayInToolbox - will be displayed in toolbox. Default value is TRUE\n\t     *  @param {Boolean} enableLineBreaks - inserts new block or break lines. Default value is FALSE\n\t     *\n\t     * @example\n\t     *   -  type             : 'header',\n\t     *   -  iconClassname    : 'ce-icon-header',\n\t     *   -  make             : headerTool.make,\n\t     *   -  appendCallback   : headerTool.appendCallback,\n\t     *   -  settings         : headerTool.makeSettings(),\n\t     *   -  render           : headerTool.render,\n\t     *   -  save             : headerTool.save,\n\t     *   -  displayInToolbox : true,\n\t     *   -  enableLineBreaks : false\n\t     */\n\t    self.start = function (userSettings_) {\n\t\n\t        self.modules.core.prepare(userSettings_)\n\t\n\t        // If all ok, make UI, bind events and parse initial-content\n\t        .then(self.modules.ui.prepare)\n\t        // .then(self.modules.tools.prepare)\n\t        .then(self.modules.sanitizer.prepare).then(self.modules.paste.prepare).then(self.modules.transport.prepare).then(self.modules.renderer.makeBlocksFromData).then(self.modules.ui.saveInputs).catch(function (error) {\n\t\n\t            self.modules.core.log('Initialization failed with error: %o', 'warn', error);\n\t        });\n\t    };\n\t\n\t    self.start(userSettings);\n\t\n\t    return { save: self.modules.saver.save };\n\t};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/**\n\t * Codex Editor Core\n\t *\n\t * @author Codex Team\n\t * @version 1.1.3\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var core = {};\n\t\n\t    var editor = this;\n\t\n\t    /**\n\t     * @public\n\t     *\n\t     * Editor preparing method\n\t     * @return Promise\n\t     */\n\t    core.prepare = function (userSettings) {\n\t\n\t        return new Promise(function (resolve, reject) {\n\t\n\t            if (userSettings) {\n\t\n\t                editor.settings.tools = userSettings.tools || editor.settings.tools;\n\t            }\n\t\n\t            if (userSettings.data) {\n\t\n\t                editor.state.blocks = userSettings.data;\n\t            }\n\t\n\t            if (userSettings.initialBlockPlugin) {\n\t\n\t                editor.settings.initialBlockPlugin = userSettings.initialBlockPlugin;\n\t            }\n\t\n\t            if (userSettings.sanitizer) {\n\t\n\t                editor.settings.sanitizer = userSettings.sanitizer;\n\t            }\n\t\n\t            editor.hideToolbar = userSettings.hideToolbar;\n\t\n\t            editor.settings.placeholder = userSettings.placeholder || '';\n\t\n\t            editor.nodes.holder = document.getElementById(userSettings.holderId || editor.settings.holderId);\n\t\n\t            if (_typeof(editor.nodes.holder) === undefined || editor.nodes.holder === null) {\n\t\n\t                reject(Error(\"Holder wasn't found by ID: #\" + userSettings.holderId));\n\t            } else {\n\t\n\t                resolve();\n\t            }\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Logging method\n\t     * @param type = ['log', 'info', 'warn']\n\t     */\n\t    core.log = function (msg, type, arg) {\n\t\n\t        type = type || 'log';\n\t\n\t        if (!arg) {\n\t\n\t            arg = msg || 'undefined';\n\t            msg = '[codex-editor]:      %o';\n\t        } else {\n\t\n\t            msg = '[codex-editor]:      ' + msg;\n\t        }\n\t\n\t        try {\n\t\n\t            if ('console' in window && window.console[type]) {\n\t\n\t                if (arg) window.console[type](msg, arg);else window.console[type](msg);\n\t            }\n\t        } catch (e) {}\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Helper for insert one element after another\n\t     */\n\t    core.insertAfter = function (target, element) {\n\t\n\t        target.parentNode.insertBefore(element, target.nextSibling);\n\t    };\n\t\n\t    /**\n\t     * @const\n\t     *\n\t     * Readable DOM-node types map\n\t     */\n\t    core.nodeTypes = {\n\t        TAG: 1,\n\t        TEXT: 3,\n\t        COMMENT: 8,\n\t        DOCUMENT_FRAGMENT: 11\n\t    };\n\t\n\t    /**\n\t     * @const\n\t     * Readable keys map\n\t     */\n\t    core.keys = { BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, ESC: 27, SPACE: 32, LEFT: 37, UP: 38, DOWN: 40, RIGHT: 39, DELETE: 46, META: 91 };\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Check object for DOM node\n\t     */\n\t    core.isDomNode = function (el) {\n\t\n\t        return el && (typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' && el.nodeType && el.nodeType == this.nodeTypes.TAG;\n\t    };\n\t\n\t    /**\n\t    * Checks passed object for emptiness\n\t    * @require ES5 - Object.keys\n\t    * @param {object}\n\t    */\n\t    core.isEmpty = function (obj) {\n\t\n\t        return Object.keys(obj).length === 0;\n\t    };\n\t\n\t    /**\n\t     * Native Ajax\n\t     * @param {String}   settings.url         - request URL\n\t     * @param {function} settings.beforeSend  - returned value will be passed as context to the Success, Error and Progress callbacks\n\t     * @param {function} settings.success\n\t     * @param {function} settings.progress\n\t     */\n\t    core.ajax = function (settings) {\n\t\n\t        if (!settings || !settings.url) {\n\t\n\t            return;\n\t        }\n\t\n\t        var XMLHTTP = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP'),\n\t            encodedString,\n\t            isFormData,\n\t            prop;\n\t\n\t        settings.async = true;\n\t        settings.type = settings.type || 'GET';\n\t        settings.data = settings.data || '';\n\t        settings['content-type'] = settings['content-type'] || 'application/json; charset=utf-8';\n\t\n\t        if (settings.type == 'GET' && settings.data) {\n\t\n\t            settings.url = /\\?/.test(settings.url) ? settings.url + '&' + settings.data : settings.url + '?' + settings.data;\n\t        } else {\n\t\n\t            encodedString = '';\n\t            for (prop in settings.data) {\n\t\n\t                encodedString += prop + '=' + encodeURIComponent(settings.data[prop]) + '&';\n\t            }\n\t        }\n\t\n\t        if (settings.withCredentials) {\n\t\n\t            XMLHTTP.withCredentials = true;\n\t        }\n\t\n\t        /**\n\t         * Value returned in beforeSend funtion will be passed as context to the other response callbacks\n\t         * If beforeSend returns false, AJAX will be blocked\n\t         */\n\t        var responseContext = void 0,\n\t            beforeSendResult = void 0;\n\t\n\t        if (typeof settings.beforeSend === 'function') {\n\t\n\t            beforeSendResult = settings.beforeSend.call();\n\t\n\t            if (beforeSendResult === false) {\n\t\n\t                return;\n\t            }\n\t        }\n\t\n\t        XMLHTTP.open(settings.type, settings.url, settings.async);\n\t\n\t        /**\n\t         * If we send FormData, we need no content-type header\n\t         */\n\t        isFormData = isFormData_(settings.data);\n\t\n\t        if (!isFormData) {\n\t\n\t            if (settings.type !== 'POST') {\n\t\n\t                XMLHTTP.setRequestHeader('Content-type', settings['content-type']);\n\t            } else {\n\t\n\t                XMLHTTP.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n\t            }\n\t        }\n\t\n\t        XMLHTTP.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\t\n\t        responseContext = beforeSendResult || XMLHTTP;\n\t\n\t        if (typeof settings.progress === 'function') {\n\t\n\t            XMLHTTP.upload.onprogress = settings.progress.bind(responseContext);\n\t        }\n\t\n\t        XMLHTTP.onreadystatechange = function () {\n\t\n\t            if (XMLHTTP.readyState === 4) {\n\t\n\t                if (XMLHTTP.status === 200) {\n\t\n\t                    if (typeof settings.success === 'function') {\n\t\n\t                        settings.success.call(responseContext, XMLHTTP.responseText);\n\t                    }\n\t                } else {\n\t\n\t                    if (typeof settings.error === 'function') {\n\t\n\t                        settings.error.call(responseContext, XMLHTTP.responseText, XMLHTTP.status);\n\t                    }\n\t                }\n\t            }\n\t        };\n\t\n\t        if (isFormData) {\n\t\n\t            // Sending FormData\n\t            XMLHTTP.send(settings.data);\n\t        } else {\n\t\n\t            // POST requests\n\t            XMLHTTP.send(encodedString);\n\t        }\n\t\n\t        return XMLHTTP;\n\t    };\n\t\n\t    /**\n\t    * Appends script to head of document\n\t    * @return Promise\n\t    */\n\t    core.importScript = function (scriptPath, instanceName) {\n\t\n\t        return new Promise(function (resolve, reject) {\n\t\n\t            var script = void 0;\n\t\n\t            /** Script is already loaded */\n\t            if (!instanceName) {\n\t\n\t                reject('Instance name is missed');\n\t            } else if (document.getElementById(editor.scriptPrefix + instanceName)) {\n\t\n\t                resolve(scriptPath);\n\t            }\n\t\n\t            script = document.createElement('SCRIPT');\n\t            script.async = true;\n\t            script.defer = true;\n\t            script.id = editor.scriptPrefix + instanceName;\n\t\n\t            script.onload = function () {\n\t\n\t                resolve(scriptPath);\n\t            };\n\t\n\t            script.onerror = function () {\n\t\n\t                reject(scriptPath);\n\t            };\n\t\n\t            script.src = scriptPath;\n\t            document.head.appendChild(script);\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Function for checking is it FormData object to send.\n\t     * @param {Object} object to check\n\t     * @return boolean\n\t     */\n\t    var isFormData_ = function isFormData_(object) {\n\t\n\t        return object instanceof FormData;\n\t    };\n\t\n\t    /**\n\t     * Check block\n\t     * @param target\n\t     * @description Checks target is it native input\n\t     */\n\t    core.isNativeInput = function (target) {\n\t\n\t        var nativeInputAreas = ['INPUT', 'TEXTAREA'];\n\t\n\t        return nativeInputAreas.indexOf(target.tagName) != -1;\n\t    };\n\t\n\t    /**\n\t     * Check if block is empty\n\t     * We should check block textContent, child native inputs and some exceptions like IMG and IFRAME\n\t     *\n\t     * @param block\n\t     * @returns {boolean}\n\t     */\n\t    core.isBlockEmpty = function (block) {\n\t\n\t        var EXCEPTION_TAGS = ['IMG', 'IFRAME'];\n\t\n\t        var nativeInputs = block.querySelectorAll('textarea, input'),\n\t            nativeInputsAreEmpty = true,\n\t            textContentIsEmpty = !block.textContent.trim();\n\t\n\t        Array.prototype.forEach.call(nativeInputs, function (input) {\n\t\n\t            if (input.type == 'textarea' || input.type == 'text') {\n\t\n\t                nativeInputsAreEmpty = nativeInputsAreEmpty && !input.value.trim();\n\t            }\n\t        });\n\t\n\t        return textContentIsEmpty && nativeInputsAreEmpty && !EXCEPTION_TAGS.includes(block.tagName);\n\t    };\n\t\n\t    return core;\n\t};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t* Module working with plugins\n\t*/\n\tmodule.exports = function () {\n\t\n\t    var editor = this;\n\t\n\t    /**\n\t     * Initialize plugins before using\n\t     * Ex. Load scripts or call some internal methods\n\t     * @return Promise\n\t     */\n\t    function prepare() {\n\t\n\t        return new Promise(function (resolve_, reject_) {\n\t\n\t            Promise.resolve()\n\t\n\t            /**\n\t            * Compose a sequence of plugins that requires preparation\n\t            */\n\t            .then(function () {\n\t\n\t                var pluginsRequiresPreparation = [],\n\t                    allPlugins = editor.tools;\n\t\n\t                for (var pluginName in allPlugins) {\n\t\n\t                    var plugin = allPlugins[pluginName];\n\t\n\t                    if (plugin.prepare && typeof plugin.prepare !== 'function' || !plugin.prepare) {\n\t\n\t                        continue;\n\t                    }\n\t\n\t                    pluginsRequiresPreparation.push(plugin);\n\t                }\n\t\n\t                /**\n\t                * If no one passed plugins requires preparation, finish prepare() and go ahead\n\t                */\n\t                if (!pluginsRequiresPreparation.length) {\n\t\n\t                    resolve_();\n\t                }\n\t\n\t                return pluginsRequiresPreparation;\n\t            })\n\t\n\t            /** Wait plugins while they prepares */\n\t            .then(waitAllPluginsPreparation_).then(function () {\n\t\n\t                editor.modules.core.log('Plugins loaded', 'info');\n\t                resolve_();\n\t            }).catch(function (error) {\n\t\n\t                reject_(error);\n\t            });\n\t        });\n\t    }\n\t\n\t    /**\n\t    * @param {array} plugins - list of tools that requires preparation\n\t    * @return {Promise} resolved while all plugins will be ready or failed\n\t    */\n\t    function waitAllPluginsPreparation_(plugins) {\n\t\n\t        /**\n\t        * @calls allPluginsProcessed__ when all plugins prepared or failed\n\t        */\n\t        return new Promise(function (allPluginsProcessed__) {\n\t\n\t            /**\n\t             * pluck each element from queue\n\t             * First, send resolved Promise as previous value\n\t             * Each plugins \"prepare\" method returns a Promise, that's why\n\t             * reduce current element will not be able to continue while can't get\n\t             * a resolved Promise\n\t             *\n\t             * If last plugin is \"prepared\" then go to the next stage of initialization\n\t             */\n\t            plugins.reduce(function (previousValue, plugin, iteration) {\n\t\n\t                return previousValue.then(function () {\n\t\n\t                    /**\n\t                    * Wait till plugins prepared\n\t                    * @calls pluginIsReady__ when plugin is ready or failed\n\t                    */\n\t                    return new Promise(function (pluginIsReady__) {\n\t\n\t                        callPluginsPrepareMethod_(plugin).then(pluginIsReady__).then(function () {\n\t\n\t                            plugin.available = true;\n\t                        }).catch(function (error) {\n\t\n\t                            editor.modules.core.log('Plugin \\xAB' + plugin.type + '\\xBB was not loaded. Preparation failed because %o', 'warn', error);\n\t                            plugin.available = false;\n\t                            plugin.loadingMessage = error;\n\t\n\t                            /** Go ahead even some plugin has problems */\n\t                            pluginIsReady__();\n\t                        }).then(function () {\n\t\n\t                            /** If last plugin has problems then just ignore and continue */\n\t                            if (iteration == plugins.length - 1) {\n\t\n\t                                allPluginsProcessed__();\n\t                            }\n\t                        });\n\t                    });\n\t                });\n\t            }, Promise.resolve());\n\t        });\n\t    }\n\t\n\t    var callPluginsPrepareMethod_ = function callPluginsPrepareMethod_(plugin) {\n\t\n\t        return plugin.prepare(plugin.config || {});\n\t    };\n\t\n\t    return {\n\t        prepare: prepare\n\t    };\n\t};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor UI module\n\t *\n\t * @author Codex Team\n\t * @version 1.2.0\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var ui = {};\n\t\n\t    var editor = this;\n\t\n\t    /**\n\t     * Basic editor classnames\n\t     */\n\t    ui.className = {\n\t\n\t        /**\n\t         * @const {string} BLOCK_CLASSNAME - redactor blocks name\n\t         */\n\t        BLOCK_CLASSNAME: 'ce-block',\n\t\n\t        /**\n\t         * @const {String} wrapper for plugins content\n\t         */\n\t        BLOCK_CONTENT: 'ce-block__content',\n\t\n\t        /**\n\t         * @const {String} BLOCK_STRETCHED - makes block stretched\n\t         */\n\t        BLOCK_STRETCHED: 'ce-block--stretched',\n\t\n\t        /**\n\t         * @const {String} BLOCK_HIGHLIGHTED - adds background\n\t         */\n\t        BLOCK_HIGHLIGHTED: 'ce-block--focused',\n\t\n\t        /**\n\t         * @const {String} - for all default settings\n\t         */\n\t        SETTINGS_ITEM: 'ce-settings__item'\n\t\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Making main interface\n\t     */\n\t    ui.prepare = function () {\n\t\n\t        return new Promise(function (resolve) {\n\t\n\t            var wrapper = editor.modules.draw.wrapper(),\n\t                redactor = editor.modules.draw.redactor(),\n\t                toolbar = makeToolBar_();\n\t\n\t            wrapper.appendChild(toolbar);\n\t            wrapper.appendChild(redactor);\n\t\n\t            /** Save created ui-elements to static nodes state */\n\t            editor.nodes.wrapper = wrapper;\n\t            editor.nodes.redactor = redactor;\n\t\n\t            /** Append editor wrapper with redactor zone into holder */\n\t            editor.nodes.holder.appendChild(wrapper);\n\t\n\t            resolve();\n\t        })\n\t\n\t        /** Add toolbox tools */\n\t        .then(addTools_)\n\t\n\t        /** Make container for inline toolbar */\n\t        .then(makeInlineToolbar_)\n\t\n\t        /** Add inline toolbar tools */\n\t        .then(addInlineToolbarTools_)\n\t\n\t        /** Draw wrapper for notifications */\n\t        .then(makeNotificationHolder_)\n\t\n\t        /** Add eventlisteners to redactor elements */\n\t        .then(bindEvents_).catch(function (e) {\n\t\n\t            editor.modules.core.log(\"Can't draw editor interface %o\", 'warn', e);\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     * Draws inline toolbar zone\n\t     */\n\t    var makeInlineToolbar_ = function makeInlineToolbar_() {\n\t\n\t        var container = editor.modules.draw.inlineToolbar();\n\t\n\t        /** Append to redactor new inline block */\n\t        editor.nodes.inlineToolbar.wrapper = container;\n\t\n\t        /** Draw toolbar buttons */\n\t        editor.nodes.inlineToolbar.buttons = editor.modules.draw.inlineToolbarButtons();\n\t\n\t        /** Buttons action or settings */\n\t        editor.nodes.inlineToolbar.actions = editor.modules.draw.inlineToolbarActions();\n\t\n\t        /** Append to inline toolbar buttons as part of it */\n\t        editor.nodes.inlineToolbar.wrapper.appendChild(editor.nodes.inlineToolbar.buttons);\n\t        editor.nodes.inlineToolbar.wrapper.appendChild(editor.nodes.inlineToolbar.actions);\n\t\n\t        editor.nodes.wrapper.appendChild(editor.nodes.inlineToolbar.wrapper);\n\t    };\n\t\n\t    var makeToolBar_ = function makeToolBar_() {\n\t\n\t        var toolbar = editor.modules.draw.toolbar(),\n\t            blockButtons = makeToolbarSettings_(),\n\t            toolbarContent = makeToolbarContent_();\n\t\n\t        /** Appending first-level block buttons */\n\t        toolbar.appendChild(blockButtons);\n\t\n\t        /** Append toolbarContent to toolbar */\n\t        toolbar.appendChild(toolbarContent);\n\t\n\t        /** Make toolbar global */\n\t        editor.nodes.toolbar = toolbar;\n\t\n\t        return toolbar;\n\t    };\n\t\n\t    var makeToolbarContent_ = function makeToolbarContent_() {\n\t\n\t        var toolbarContent = editor.modules.draw.toolbarContent(),\n\t            toolbox = editor.modules.draw.toolbox(),\n\t            plusButton = editor.modules.draw.plusButton();\n\t\n\t        /** Append plus button */\n\t        toolbarContent.appendChild(plusButton);\n\t\n\t        /** Appending toolbar tools */\n\t        toolbarContent.appendChild(toolbox);\n\t\n\t        /** Make Toolbox and plusButton global */\n\t        editor.nodes.toolbox = toolbox;\n\t        editor.nodes.plusButton = plusButton;\n\t\n\t        return toolbarContent;\n\t    };\n\t\n\t    var makeToolbarSettings_ = function makeToolbarSettings_() {\n\t\n\t        var blockSettings = editor.modules.draw.blockSettings(),\n\t            blockButtons = editor.modules.draw.blockButtons(),\n\t            defaultSettings = editor.modules.draw.defaultSettings(),\n\t            showSettingsButton = editor.modules.draw.settingsButton(),\n\t            showTrashButton = editor.modules.toolbar.settings.makeRemoveBlockButton(),\n\t            pluginSettings = editor.modules.draw.pluginsSettings();\n\t\n\t        /** Add default and plugins settings */\n\t        blockSettings.appendChild(pluginSettings);\n\t        blockSettings.appendChild(defaultSettings);\n\t\n\t        /**\n\t         * Make blocks buttons\n\t         * This block contains settings button and remove block button\n\t         */\n\t        blockButtons.appendChild(showSettingsButton);\n\t        blockButtons.appendChild(showTrashButton);\n\t        blockButtons.appendChild(blockSettings);\n\t\n\t        /** Make BlockSettings, PluginSettings, DefaultSettings global */\n\t        editor.nodes.blockSettings = blockSettings;\n\t        editor.nodes.pluginSettings = pluginSettings;\n\t        editor.nodes.defaultSettings = defaultSettings;\n\t        editor.nodes.showSettingsButton = showSettingsButton;\n\t        editor.nodes.showTrashButton = showTrashButton;\n\t\n\t        return blockButtons;\n\t    };\n\t\n\t    /** Draw notifications holder */\n\t    var makeNotificationHolder_ = function makeNotificationHolder_() {\n\t\n\t        /** Append block with notifications to the document */\n\t        editor.nodes.notifications = editor.modules.notifications.createHolder();\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     * Append tools passed in editor.tools\n\t     */\n\t    var addTools_ = function addTools_() {\n\t\n\t        var tool, toolName, toolButton;\n\t\n\t        for (toolName in editor.settings.tools) {\n\t\n\t            tool = editor.settings.tools[toolName];\n\t\n\t            editor.tools[toolName] = tool;\n\t            var toolInstance = tool.instance();\n\t\n\t            if (!tool.iconClassname && tool.displayInToolbox) {\n\t\n\t                editor.modules.core.log('Toolbar icon classname missed. Tool %o skipped', 'warn', toolName);\n\t                continue;\n\t            }\n\t\n\t            if (typeof toolInstance.render != 'function') {\n\t\n\t                editor.modules.core.log('render method missed. Tool %o skipped', 'warn', toolName);\n\t                continue;\n\t            }\n\t\n\t            if (!tool.displayInToolbox) {\n\t\n\t                continue;\n\t            } else {\n\t\n\t                /** if tools is for toolbox */\n\t                toolButton = editor.modules.draw.toolbarButton(toolName, tool.iconClassname);\n\t\n\t                editor.nodes.toolbox.appendChild(toolButton);\n\t\n\t                editor.nodes.toolbarButtons[toolName] = toolButton;\n\t            }\n\t        }\n\t    };\n\t\n\t    var addInlineToolbarTools_ = function addInlineToolbarTools_() {\n\t\n\t        var tools = {\n\t\n\t            bold: {\n\t                icon: 'ce-icon-bold',\n\t                command: 'bold'\n\t            },\n\t\n\t            italic: {\n\t                icon: 'ce-icon-italic',\n\t                command: 'italic'\n\t            },\n\t\n\t            link: {\n\t                icon: 'ce-icon-link',\n\t                command: 'createLink'\n\t            }\n\t        };\n\t\n\t        var toolButton, tool;\n\t\n\t        for (var name in tools) {\n\t\n\t            tool = tools[name];\n\t\n\t            toolButton = editor.modules.draw.toolbarButtonInline(name, tool.icon);\n\t\n\t            editor.nodes.inlineToolbar.buttons.appendChild(toolButton);\n\t            /**\n\t             * Add callbacks to this buttons\n\t             */\n\t            editor.modules.ui.setInlineToolbarButtonBehaviour(toolButton, tool.command);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     * Bind editor UI events\n\t     */\n\t    var bindEvents_ = function bindEvents_() {\n\t\n\t        editor.modules.core.log('ui.bindEvents fired', 'info');\n\t\n\t        // window.addEventListener('error', function (errorMsg, url, lineNumber) {\n\t        //     editor.notifications.errorThrown(errorMsg, event);\n\t        // }, false );\n\t\n\t        /** All keydowns on Document */\n\t        editor.modules.listeners.add(document, 'keydown', editor.modules.callback.globalKeydown, false);\n\t\n\t        /** All keydowns on Redactor zone */\n\t        editor.modules.listeners.add(editor.nodes.redactor, 'keydown', editor.modules.callback.redactorKeyDown, false);\n\t\n\t        /** All keydowns on Document */\n\t        editor.modules.listeners.add(document, 'keyup', editor.modules.callback.globalKeyup, false);\n\t\n\t        /**\n\t         * Mouse click to radactor\n\t         */\n\t        editor.modules.listeners.add(editor.nodes.redactor, 'click', editor.modules.callback.redactorClicked, false);\n\t\n\t        /**\n\t         * Clicks to the Plus button\n\t         */\n\t        editor.modules.listeners.add(editor.nodes.plusButton, 'click', editor.modules.callback.plusButtonClicked, false);\n\t\n\t        /**\n\t         * Clicks to SETTINGS button in toolbar\n\t         */\n\t        editor.modules.listeners.add(editor.nodes.showSettingsButton, 'click', editor.modules.callback.showSettingsButtonClicked, false);\n\t\n\t        /** Bind click listeners on toolbar buttons */\n\t        for (var button in editor.nodes.toolbarButtons) {\n\t\n\t            editor.modules.listeners.add(editor.nodes.toolbarButtons[button], 'click', editor.modules.callback.toolbarButtonClicked, false);\n\t        }\n\t    };\n\t\n\t    ui.addBlockHandlers = function (block) {\n\t\n\t        if (!block) return;\n\t\n\t        /**\n\t         * Block keydowns\n\t         */\n\t        editor.modules.listeners.add(block, 'keydown', editor.modules.callback.blockKeydown, false);\n\t\n\t        /**\n\t         * Pasting content from another source\n\t         * We have two type of sanitization\n\t         * First - uses deep-first search algorithm to get sub nodes,\n\t         * sanitizes whole Block_content and replaces cleared nodes\n\t         * This method is deprecated\n\t         * Method is used in editor.callback.blockPaste(event)\n\t         *\n\t         * Secont - uses Mutation observer.\n\t         * Observer \"observe\" DOM changes and send changings to callback.\n\t         * Callback gets changed node, not whole Block_content.\n\t         * Inserted or changed node, which we've gotten have been cleared and replaced with diry node\n\t         *\n\t         * Method is used in editor.callback.blockPasteViaSanitize(event)\n\t         *\n\t         * @uses html-janitor\n\t         * @example editor.callback.blockPasteViaSanitize(event), the second method.\n\t         *\n\t         */\n\t        editor.modules.listeners.add(block, 'paste', editor.modules.paste.blockPasteCallback, false);\n\t\n\t        /**\n\t         * Show inline toolbar for selected text\n\t         */\n\t        editor.modules.listeners.add(block, 'mouseup', editor.modules.toolbar.inline.show, false);\n\t        editor.modules.listeners.add(block, 'keyup', editor.modules.toolbar.inline.show, false);\n\t    };\n\t\n\t    /** getting all contenteditable elements */\n\t    ui.saveInputs = function () {\n\t\n\t        var redactor = editor.nodes.redactor;\n\t\n\t        editor.state.inputs = [];\n\t\n\t        /** Save all inputs in global variable state */\n\t        var inputs = redactor.querySelectorAll('[contenteditable], input, textarea');\n\t\n\t        Array.prototype.map.call(inputs, function (current) {\n\t\n\t            if (!current.type || current.type == 'text' || current.type == 'textarea') {\n\t\n\t                editor.state.inputs.push(current);\n\t            }\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Adds first initial block on empty redactor\n\t     */\n\t    ui.addInitialBlock = function () {\n\t\n\t        var initialBlockType = editor.settings.initialBlockPlugin,\n\t            initialBlock;\n\t\n\t        if (!editor.tools[initialBlockType]) {\n\t\n\t            editor.modules.core.log('Plugin %o was not implemented and can\\'t be used as initial block', 'warn', initialBlockType);\n\t            return;\n\t        }\n\t\n\t        initialBlock = editor.modules.renderer.makeBlockFromData({ type: initialBlockType });\n\t\n\t        initialBlock.setAttribute('data-placeholder', editor.settings.placeholder);\n\t\n\t        editor.modules.content.insertBlock({\n\t            type: initialBlockType,\n\t            block: initialBlock\n\t        });\n\t\n\t        editor.modules.content.workingNodeChanged(initialBlock);\n\t    };\n\t\n\t    ui.setInlineToolbarButtonBehaviour = function (button, type) {\n\t\n\t        editor.modules.listeners.add(button, 'mousedown', function (event) {\n\t\n\t            editor.modules.toolbar.inline.toolClicked(event, type);\n\t        }, false);\n\t    };\n\t\n\t    return ui;\n\t};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t *\n\t * Codex.Editor Transport Module\n\t *\n\t * @copyright 2017 Codex-Team\n\t * @version 1.2.0\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var transport = {};\n\t\n\t    var editor = this;\n\t\n\t    /**\n\t     * @private {Object} current XmlHttpRequest instance\n\t     */\n\t    var currentRequest = null;\n\t\n\t    /**\n\t     * @type {null} | {DOMElement} input - keeps input element in memory\n\t     */\n\t    transport.input = null;\n\t\n\t    /**\n\t     * @property {Object} arguments - keep plugin settings and defined callbacks\n\t     */\n\t    transport.arguments = null;\n\t\n\t    /**\n\t     * Prepares input element where will be files\n\t     */\n\t    transport.prepare = function () {\n\t\n\t        var input = editor.modules.draw.node('INPUT', '', { type: 'file' });\n\t\n\t        editor.modules.listeners.add(input, 'change', editor.modules.transport.fileSelected);\n\t        editor.modules.transport.input = input;\n\t    };\n\t\n\t    /** Clear input when files is uploaded */\n\t    transport.clearInput = function () {\n\t\n\t        /** Remove old input */\n\t        transport.input = null;\n\t\n\t        /** Prepare new one */\n\t        transport.prepare();\n\t    };\n\t\n\t    /**\n\t     * Callback for file selection\n\t     * @param {Event} event\n\t     */\n\t    transport.fileSelected = function () {\n\t\n\t        var input = this,\n\t            i,\n\t            files = input.files,\n\t            formData = new FormData();\n\t\n\t        if (editor.modules.transport.arguments.multiple === true) {\n\t\n\t            for (i = 0; i < files.length; i++) {\n\t\n\t                formData.append('files[]', files[i], files[i].name);\n\t            }\n\t        } else {\n\t\n\t            formData.append('files', files[0], files[0].name);\n\t        }\n\t\n\t        currentRequest = editor.core.ajax({\n\t            type: 'POST',\n\t            data: formData,\n\t            url: editor.modules.transport.arguments.url,\n\t            beforeSend: editor.modules.transport.arguments.beforeSend,\n\t            success: editor.modules.transport.arguments.success,\n\t            error: editor.modules.transport.arguments.error,\n\t            progress: editor.modules.transport.arguments.progress\n\t        });\n\t\n\t        /** Clear input */\n\t        transport.clearInput();\n\t    };\n\t\n\t    /**\n\t     * Use plugin callbacks\n\t     * @protected\n\t     *\n\t     * @param {Object} args - can have :\n\t     * @param {String} args.url - fetch URL\n\t     * @param {Function} args.beforeSend - function calls before sending ajax\n\t     * @param {Function} args.success - success callback\n\t     * @param {Function} args.error - on error handler\n\t     * @param {Function} args.progress - xhr onprogress handler\n\t     * @param {Boolean} args.multiple - allow select several files\n\t     * @param {String} args.accept - adds accept attribute\n\t     */\n\t    transport.selectAndUpload = function (args) {\n\t\n\t        transport.arguments = args;\n\t\n\t        if (args.multiple === true) {\n\t\n\t            transport.input.setAttribute('multiple', 'multiple');\n\t        }\n\t\n\t        if (args.accept) {\n\t\n\t            transport.input.setAttribute('accept', args.accept);\n\t        }\n\t\n\t        transport.input.click();\n\t    };\n\t\n\t    transport.abort = function () {\n\t\n\t        currentRequest.abort();\n\t\n\t        currentRequest = null;\n\t    };\n\t\n\t    return transport;\n\t};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor Renderer Module\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var renderer = {};\n\t\n\t    var editor = this;\n\t\n\t    /**\n\t     * Asyncronously parses input JSON to redactor blocks\n\t     */\n\t    renderer.makeBlocksFromData = function () {\n\t\n\t        /**\n\t         * If redactor is empty, add first paragraph to start writing\n\t         */\n\t        if (editor.modules.core.isEmpty(editor.state.blocks) || !editor.state.blocks.items.length) {\n\t\n\t            editor.modules.ui.addInitialBlock();\n\t            return;\n\t        }\n\t\n\t        return renderer.appendBlocks(editor.state.blocks)\n\t        /** Write log if something goes wrong */\n\t        .catch(function (error) {\n\t\n\t            editor.modules.core.log('Error while parsing JSON: %o', 'error', error);\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Parses JSON to blocks\n\t     * @param {object} data\n\t     * @return Primise -> nodeList\n\t     */\n\t    renderer.appendBlocks = function (data) {\n\t\n\t        var blocksData = data.items;\n\t\n\t        /**\n\t         * Sequence of one-by-one blocks appending\n\t         * Uses to save blocks order after async-handler\n\t         */\n\t        var blocks = [];\n\t\n\t        for (var index = 0; index < blocksData.length; index++) {\n\t\n\t            blocks.push(Promise.resolve(blocksData[index]).then(makeBlockFromData));\n\t        }\n\t\n\t        return Promise.all(blocks).then(function (elements) {\n\t\n\t            elements.forEach(function (element) {\n\t\n\t                editor.modules.content.insertBlock({\n\t                    block: element,\n\t                    type: element.tool.name\n\t                });\n\t            });\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Append node at specified index\n\t     */\n\t    renderer.appendNodeAtIndex = function (nodeSequence, blocks, index) {\n\t\n\t        /** We need to append node to sequence */\n\t        nodeSequence\n\t\n\t        /** first, get node async-aware */\n\t        .then(function () {\n\t\n\t            return editor.modules.renderer.getNodeAsync(blocks, index);\n\t        })\n\t\n\t        /**\n\t         * second, compose editor-block from JSON object\n\t         */\n\t        .then(editor.modules.renderer.createBlockFromData)\n\t\n\t        /**\n\t         * now insert block to redactor\n\t         */\n\t        .then(function (blockData) {\n\t\n\t            /**\n\t             * blockData has 'block', 'type' and 'stretched' information\n\t             */\n\t            editor.modules.content.insertBlock(blockData);\n\t\n\t            /** Pass created block to next step */\n\t            return blockData.block;\n\t        })\n\t\n\t        /** Log if something wrong with node */\n\t        .catch(function (error) {\n\t\n\t            editor.modules.core.log('Node skipped while parsing because %o', 'error', error);\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Creates editor block by JSON-data\n\t     *\n\t     * @uses render method of each plugin\n\t     *\n\t     * @param {Object} toolData.tool\n\t     *                              { header : {\n\t     *                                                text: '',\n\t     *                                                type: 'H3', ...\n\t     *                                            }\n\t     *                               }\n\t     * @param {Number} toolData.position - index in input-blocks array\n\t     * @return {Object} with type and Element\n\t     */\n\t    renderer.createBlockFromData = function (toolData) {\n\t\n\t        /** New parser */\n\t        var block,\n\t            tool = toolData.tool,\n\t            pluginName = tool.type;\n\t\n\t        /** Get first key of object that stores plugin name */\n\t        // for (var pluginName in blockData) break;\n\t\n\t        /** Check for plugin existance */\n\t        if (!editor.tools[pluginName]) {\n\t\n\t            throw Error('Plugin \\xAB' + pluginName + '\\xBB not found');\n\t        }\n\t\n\t        /** Check for plugin having render method */\n\t        if (typeof editor.tools[pluginName].render != 'function') {\n\t\n\t            throw Error('Plugin \\xAB' + pluginName + '\\xBB must have \\xABrender\\xBB method');\n\t        }\n\t\n\t        if (editor.tools[pluginName].available === false) {\n\t\n\t            block = editor.modules.draw.unavailableBlock();\n\t\n\t            block.innerHTML = editor.tools[pluginName].loadingMessage;\n\t\n\t            /**\n\t            * Saver will extract data from initial block data by position in array\n\t            */\n\t            block.dataset.inputPosition = toolData.position;\n\t        } else {\n\t\n\t            /** New Parser */\n\t            block = editor.tools[pluginName].render(tool.data);\n\t        }\n\t\n\t        /** is first-level block stretched */\n\t        var stretched = editor.tools[pluginName].isStretched || false;\n\t\n\t        /** Retrun type and block */\n\t        return {\n\t            type: pluginName,\n\t            block: block,\n\t            stretched: stretched\n\t        };\n\t    };\n\t\n\t    function makeBlockFromData(blockData) {\n\t\n\t        var toolName = blockData.type,\n\t            data = blockData.data;\n\t\n\t        if (!editor.tools[toolName]) {\n\t\n\t            // throw Error(`Plugin «${toolName}» not found`);\n\t            return;\n\t        }\n\t\n\t        var tool = editor.tools[toolName];\n\t\n\t        var toolInstance = tool.instance();\n\t\n\t        if (typeof toolInstance.render != 'function') {\n\t\n\t            // throw Error(`Plugin «${toolName}» must have «render» method`);\n\t            return;\n\t        }\n\t\n\t        var DOMElement = toolInstance.render(data);\n\t\n\t        DOMElement.tool = toolInstance;\n\t\n\t        return DOMElement;\n\t    }\n\t\n\t    renderer.makeBlockFromData = makeBlockFromData;\n\t\n\t    return renderer;\n\t};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor Saver\n\t *\n\t * @author Codex Team\n\t * @version 1.1.0\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var saver = {};\n\t\n\t    var editor = this;\n\t\n\t    /**\n\t     * @public\n\t     * Save blocks\n\t     */\n\t    saver.save = function () {\n\t\n\t        /** Save html content of redactor to memory */\n\t        editor.state.html = editor.nodes.redactor.innerHTML;\n\t\n\t        /** Clean jsonOutput state */\n\t        editor.state.jsonOutput = [];\n\t\n\t        return saveBlocks(editor.nodes.redactor.childNodes);\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     * Save each block data\n\t     *\n\t     * @param blocks\n\t     * @returns {Promise.<TResult>}\n\t     */\n\t    var saveBlocks = function saveBlocks(blocks) {\n\t\n\t        var data = [];\n\t\n\t        for (var index = 0; index < blocks.length; index++) {\n\t\n\t            data.push(getBlockData(blocks[index]));\n\t        }\n\t\n\t        return Promise.all(data).then(makeOutput).catch(editor.modules.core.log);\n\t    };\n\t\n\t    /** Save and validate block data */\n\t    var getBlockData = function getBlockData(block) {\n\t\n\t        return saveBlockData(block).then(validateBlockData).catch(editor.modules.core.log);\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     * Call block`s plugin save method and return saved data\n\t     *\n\t     * @param block\n\t     * @returns {Object}\n\t     */\n\t    var saveBlockData = function saveBlockData(block) {\n\t\n\t        var tool = block.childNodes[0].childNodes[0].tool;\n\t\n\t        /** Check for plugin existence */\n\t        if (!editor.tools[tool.name]) {\n\t\n\t            editor.modules.core.log('Plugin \\xAB' + tool.name + '\\xBB not found', 'error');\n\t            return { data: null, tool: null };\n\t        }\n\t\n\t        /** Check for plugin having save method */\n\t        if (typeof tool.save !== 'function') {\n\t\n\t            editor.modules.core.log('Plugin \\xAB' + tool.name + '\\xBB must have save method', 'error');\n\t            return { data: null, tool: null };\n\t        }\n\t\n\t        /** Result saver */\n\t        var blockContent = block.childNodes[0],\n\t            pluginsContent = blockContent.childNodes[0],\n\t            position = pluginsContent.dataset.inputPosition;\n\t\n\t        /** If plugin wasn't available then return data from cache */\n\t        if (editor.tools[tool.name].available === false) {\n\t\n\t            return Promise.resolve({ data: codex.editor.state.blocks.items[position].data, tool: tool });\n\t        }\n\t\n\t        return Promise.resolve(pluginsContent).then(tool.save).then(function (data) {\n\t            return Object({ data: data, tool: tool });\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Call plugin`s validate method. Return false if validation failed\n\t     *\n\t     * @param data\n\t     * @param tool\n\t     * @returns {Object|Boolean}\n\t     */\n\t    var validateBlockData = function validateBlockData(_ref) {\n\t        var data = _ref.data,\n\t            tool = _ref.tool;\n\t\n\t\n\t        if (!data || !tool) {\n\t\n\t            return false;\n\t        }\n\t\n\t        if (tool.validate && typeof tool.validate === 'function') {\n\t\n\t            var result = tool.validate(data);\n\t\n\t            /**\n\t             * Do not allow invalid data\n\t             */\n\t            if (!result) {\n\t\n\t                return false;\n\t            }\n\t        }\n\t\n\t        return { data: data, tool: tool };\n\t    };\n\t\n\t    /**\n\t     * Compile article output\n\t     *\n\t     * @param savedData\n\t     * @returns {{time: number, version, items: (*|Array)}}\n\t     */\n\t    var makeOutput = function makeOutput(savedData) {\n\t\n\t        savedData = savedData.filter(function (blockData) {\n\t            return blockData;\n\t        });\n\t\n\t        var items = savedData.map(function (blockData) {\n\t            return Object({ type: blockData.tool.name, data: blockData.data });\n\t        });\n\t\n\t        editor.state.jsonOutput = items;\n\t\n\t        return {\n\t            id: editor.state.blocks.id || null,\n\t            time: +new Date(),\n\t            version: editor.version,\n\t            items: items\n\t        };\n\t    };\n\t\n\t    return saver;\n\t};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor Content Module\n\t * Works with DOM\n\t *\n\t * @module Codex Editor content module\n\t *\n\t * @author Codex Team\n\t * @version 1.3.13\n\t *\n\t * @description Module works with Elements that have been appended to the main DOM\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var content = {};\n\t\n\t    var editor = this;\n\t\n\t    /**\n\t     * Links to current active block\n\t     * @type {null | Element}\n\t     */\n\t    content.currentNode = null;\n\t\n\t    /**\n\t     * clicked in redactor area\n\t     * @type {null | Boolean}\n\t     */\n\t    content.editorAreaHightlighted = null;\n\t\n\t    /**\n\t     * @deprecated\n\t     * Synchronizes redactor with original textarea\n\t     */\n\t    content.sync = function () {\n\t\n\t        editor.modules.core.log('syncing...');\n\t\n\t        /**\n\t         * Save redactor content to editor.state\n\t         */\n\t        editor.state.html = editor.nodes.redactor.innerHTML;\n\t    };\n\t\n\t    /**\n\t     * Appends background to the block\n\t     *\n\t     * @description add CSS class to highlight visually first-level block area\n\t     */\n\t    content.markBlock = function () {\n\t\n\t        editor.modules.content.currentNode.classList.add(editor.modules.ui.className.BLOCK_HIGHLIGHTED);\n\t    };\n\t\n\t    /**\n\t     * Clear background\n\t     *\n\t     * @description clears styles that highlights block\n\t     */\n\t    content.clearMark = function () {\n\t\n\t        if (editor.modules.content.currentNode) {\n\t\n\t            editor.modules.content.currentNode.classList.remove(editor.modules.ui.className.BLOCK_HIGHLIGHTED);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Finds first-level block\n\t     *\n\t     * @param {Element} node - selected or clicked in redactors area node\n\t     * @protected\n\t     *\n\t     * @description looks for first-level block.\n\t     * gets parent while node is not first-level\n\t     */\n\t    content.getFirstLevelBlock = function (node) {\n\t\n\t        if (!editor.modules.core.isDomNode(node)) {\n\t\n\t            node = node.parentNode;\n\t        }\n\t\n\t        if (node === editor.nodes.redactor || node === document.body) {\n\t\n\t            return null;\n\t        } else {\n\t\n\t            while (!node.classList.contains(editor.modules.ui.className.BLOCK_CLASSNAME)) {\n\t\n\t                node = node.parentNode;\n\t            }\n\t\n\t            return node;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Trigger this event when working node changed\n\t     * @param {Element} targetNode - first-level of this node will be current\n\t     * @protected\n\t     *\n\t     * @description If targetNode is first-level then we set it as current else we look for parents to find first-level\n\t     */\n\t    content.workingNodeChanged = function (targetNode) {\n\t\n\t        /** Clear background from previous marked block before we change */\n\t        editor.modules.content.clearMark();\n\t\n\t        if (!targetNode) {\n\t\n\t            return;\n\t        }\n\t\n\t        content.currentNode = content.getFirstLevelBlock(targetNode);\n\t    };\n\t\n\t    /**\n\t     * Replaces one redactor block with another\n\t     * @protected\n\t     * @param {Element} targetBlock - block to replace. Mostly currentNode.\n\t     * @param {Element} newBlock\n\t     * @param {string} newBlockType - type of new block; we need to store it to data-attribute\n\t     *\n\t     * [!] Function does not saves old block content.\n\t     *     You can get it manually and pass with newBlock.innerHTML\n\t     */\n\t    content.replaceBlock = function (targetBlock, newBlock) {\n\t\n\t        if (!targetBlock || !newBlock) {\n\t\n\t            editor.modules.core.log('replaceBlock: missed params');\n\t            return;\n\t        }\n\t\n\t        /** If target-block is not a frist-level block, then we iterate parents to find it */\n\t        while (!targetBlock.classList.contains(editor.modules.ui.className.BLOCK_CLASSNAME)) {\n\t\n\t            targetBlock = targetBlock.parentNode;\n\t        }\n\t\n\t        /** Replacing */\n\t        editor.nodes.redactor.replaceChild(newBlock, targetBlock);\n\t\n\t        /**\n\t         * Set new node as current\n\t         */\n\t        editor.modules.content.workingNodeChanged(newBlock);\n\t\n\t        /**\n\t         * Add block handlers\n\t         */\n\t        editor.modules.ui.addBlockHandlers(newBlock);\n\t\n\t        /**\n\t         * Save changes\n\t         */\n\t        editor.modules.ui.saveInputs();\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Inserts new block to redactor\n\t     * Wrapps block into a DIV with BLOCK_CLASSNAME class\n\t     *\n\t     * @param blockData          {object}\n\t     * @param blockData.block    {Element}   element with block content\n\t     * @param blockData.type     {string}    block plugin\n\t     * @param needPlaceCaret     {bool}      pass true to set caret in new block\n\t     *\n\t     */\n\t    content.insertBlock = function (blockData, needPlaceCaret) {\n\t\n\t        var workingBlock = editor.modules.content.currentNode,\n\t            newBlockContent = blockData.block,\n\t            blockType = blockData.type,\n\t            isStretched = blockData.stretched;\n\t\n\t        var newBlock = composeNewBlock_(newBlockContent, blockType, isStretched);\n\t\n\t        if (workingBlock) {\n\t\n\t            editor.modules.core.insertAfter(workingBlock, newBlock);\n\t        } else {\n\t\n\t            /**\n\t             * If redactor is empty, append as first child\n\t             */\n\t            editor.nodes.redactor.appendChild(newBlock);\n\t        }\n\t\n\t        /**\n\t         * Block handler\n\t         */\n\t        editor.modules.ui.addBlockHandlers(newBlock);\n\t\n\t        /**\n\t         * Set new node as current\n\t         */\n\t        editor.modules.content.workingNodeChanged(newBlock);\n\t\n\t        /**\n\t         * Save changes\n\t         */\n\t        editor.modules.ui.saveInputs();\n\t\n\t        if (needPlaceCaret) {\n\t\n\t            /**\n\t             * If we don't know input index then we set default value -1\n\t             */\n\t            var currentInputIndex = editor.modules.caret.getCurrentInputIndex() || -1;\n\t\n\t            if (currentInputIndex == -1) {\n\t\n\t                var editableElement = newBlock.querySelector('[contenteditable]'),\n\t                    emptyText = document.createTextNode('');\n\t\n\t                editableElement.appendChild(emptyText);\n\t                editor.modules.caret.set(editableElement, 0, 0);\n\t\n\t                editor.modules.toolbar.move();\n\t                editor.modules.toolbar.showPlusButton();\n\t            } else {\n\t\n\t                if (currentInputIndex === editor.state.inputs.length - 1) return;\n\t\n\t                /** Timeout for browsers execution */\n\t                window.setTimeout(function () {\n\t\n\t                    /** Setting to the new input */\n\t                    editor.modules.caret.setToNextBlock(currentInputIndex);\n\t                    editor.modules.toolbar.move();\n\t                    editor.modules.toolbar.open();\n\t                }, 10);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Block is inserted, wait for new click that defined focusing on editors area\n\t         * @type {boolean}\n\t         */\n\t        content.editorAreaHightlighted = false;\n\t    };\n\t\n\t    /**\n\t     * Replaces blocks with saving content\n\t     * @protected\n\t     * @param {Element} noteToReplace\n\t     * @param {Element} newNode\n\t     * @param {Element} blockType\n\t     */\n\t    content.switchBlock = function (blockToReplace, newBlock, tool) {\n\t\n\t        tool = tool || editor.modules.content.currentNode.dataset.tool;\n\t        var newBlockComposed = composeNewBlock_(newBlock, tool);\n\t\n\t        /** Replacing */\n\t        editor.modules.content.replaceBlock(blockToReplace, newBlockComposed);\n\t\n\t        /** Save new Inputs when block is changed */\n\t        editor.modules.ui.saveInputs();\n\t    };\n\t\n\t    /**\n\t     * Iterates between child noted and looking for #text node on deepest level\n\t     * @protected\n\t     *\n\t     * @param {Element} block - node where find\n\t     * @param {int} postiton - starting postion\n\t     *      Example: childNodex.length to find from the end\n\t     *               or 0 to find from the start\n\t     * @return {Text} block\n\t     * @uses DFS\n\t     */\n\t    content.getDeepestTextNodeFromPosition = function (block, position) {\n\t\n\t        /**\n\t         * Clear Block from empty and useless spaces with trim.\n\t         * Such nodes we should remove\n\t         */\n\t        var blockChilds = block.childNodes,\n\t            index,\n\t            node,\n\t            text;\n\t\n\t        for (index = 0; index < blockChilds.length; index++) {\n\t\n\t            node = blockChilds[index];\n\t\n\t            if (node.nodeType == editor.modules.core.nodeTypes.TEXT) {\n\t\n\t                text = node.textContent.trim();\n\t\n\t                /** Text is empty. We should remove this child from node before we start DFS\n\t                 * decrease the quantity of childs.\n\t                 */\n\t                if (text === '') {\n\t\n\t                    block.removeChild(node);\n\t                    position--;\n\t                }\n\t            }\n\t        }\n\t\n\t        if (block.childNodes.length === 0) {\n\t\n\t            return document.createTextNode('');\n\t        }\n\t\n\t        /** Setting default position when we deleted all empty nodes */\n\t        if (position < 0) position = 1;\n\t\n\t        var lookingFromStart = false;\n\t\n\t        /** For looking from START */\n\t        if (position === 0) {\n\t\n\t            lookingFromStart = true;\n\t            position = 1;\n\t        }\n\t\n\t        while (position) {\n\t\n\t            /** initial verticle of node. */\n\t            if (lookingFromStart) {\n\t\n\t                block = block.childNodes[0];\n\t            } else {\n\t\n\t                block = block.childNodes[position - 1];\n\t            }\n\t\n\t            if (block.nodeType == editor.core.nodeTypes.TAG) {\n\t\n\t                position = block.childNodes.length;\n\t            } else if (block.nodeType == editor.core.nodeTypes.TEXT) {\n\t\n\t                position = 0;\n\t            }\n\t        }\n\t\n\t        return block;\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     * @param {Element} block - current plugins render\n\t     * @param {String} tool - plugins name\n\t     * @param {Boolean} isStretched - make stretched block or not\n\t     *\n\t     * @description adds necessary information to wrap new created block by first-level holder\n\t     */\n\t    var composeNewBlock_ = function composeNewBlock_(block, tool, isStretched) {\n\t\n\t        var newBlock = editor.modules.draw.node('DIV', editor.modules.ui.className.BLOCK_CLASSNAME, {}),\n\t            blockContent = editor.modules.draw.node('DIV', editor.modules.ui.className.BLOCK_CONTENT, {});\n\t\n\t        blockContent.appendChild(block);\n\t        newBlock.appendChild(blockContent);\n\t\n\t        if (isStretched) {\n\t\n\t            blockContent.classList.add(editor.modules.ui.className.BLOCK_STRETCHED);\n\t        }\n\t\n\t        newBlock.dataset.tool = tool;\n\t        return newBlock;\n\t    };\n\t\n\t    /**\n\t     * Returns Range object of current selection\n\t     * @protected\n\t     */\n\t    content.getRange = function () {\n\t\n\t        var selection = window.getSelection().getRangeAt(0);\n\t\n\t        return selection;\n\t    };\n\t\n\t    /**\n\t     * Divides block in two blocks (after and before caret)\n\t     *\n\t     * @protected\n\t     * @param {int} inputIndex - target input index\n\t     *\n\t     * @description splits current input content to the separate blocks\n\t     * When enter is pressed among the words, that text will be splited.\n\t     */\n\t    content.splitBlock = function (inputIndex) {\n\t\n\t        var selection = window.getSelection(),\n\t            anchorNode = selection.anchorNode,\n\t            anchorNodeText = anchorNode.textContent,\n\t            caretOffset = selection.anchorOffset,\n\t            textBeforeCaret,\n\t            textNodeBeforeCaret,\n\t            textAfterCaret,\n\t            textNodeAfterCaret;\n\t\n\t        var currentBlock = editor.modules.content.currentNode.querySelector('[contentEditable]');\n\t\n\t        textBeforeCaret = anchorNodeText.substring(0, caretOffset);\n\t        textAfterCaret = anchorNodeText.substring(caretOffset);\n\t\n\t        textNodeBeforeCaret = document.createTextNode(textBeforeCaret);\n\t\n\t        if (textAfterCaret) {\n\t\n\t            textNodeAfterCaret = document.createTextNode(textAfterCaret);\n\t        }\n\t\n\t        var previousChilds = [],\n\t            nextChilds = [],\n\t            reachedCurrent = false;\n\t\n\t        if (textNodeAfterCaret) {\n\t\n\t            nextChilds.push(textNodeAfterCaret);\n\t        }\n\t\n\t        for (var i = 0, child; !!(child = currentBlock.childNodes[i]); i++) {\n\t\n\t            if (child != anchorNode) {\n\t\n\t                if (!reachedCurrent) {\n\t\n\t                    previousChilds.push(child);\n\t                } else {\n\t\n\t                    nextChilds.push(child);\n\t                }\n\t            } else {\n\t\n\t                reachedCurrent = true;\n\t            }\n\t        }\n\t\n\t        /** Clear current input */\n\t        editor.state.inputs[inputIndex].innerHTML = '';\n\t\n\t        /**\n\t         * Append all childs founded before anchorNode\n\t         */\n\t        var previousChildsLength = previousChilds.length;\n\t\n\t        for (i = 0; i < previousChildsLength; i++) {\n\t\n\t            editor.state.inputs[inputIndex].appendChild(previousChilds[i]);\n\t        }\n\t\n\t        editor.state.inputs[inputIndex].appendChild(textNodeBeforeCaret);\n\t\n\t        /**\n\t         * Append text node which is after caret\n\t         */\n\t        var nextChildsLength = nextChilds.length,\n\t            newNode = document.createElement('div');\n\t\n\t        for (i = 0; i < nextChildsLength; i++) {\n\t\n\t            newNode.appendChild(nextChilds[i]);\n\t        }\n\t\n\t        newNode = newNode.innerHTML;\n\t\n\t        /** This type of block creates when enter is pressed */\n\t        var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\t\n\t        /**\n\t         * Make new paragraph with text after caret\n\t         */\n\t        editor.modules.content.insertBlock({\n\t            type: NEW_BLOCK_TYPE,\n\t            block: editor.tools[NEW_BLOCK_TYPE].render({\n\t                text: newNode\n\t            })\n\t        }, true);\n\t    };\n\t\n\t    /**\n\t     * Merges two blocks — current and target\n\t     * If target index is not exist, then previous will be as target\n\t     *\n\t     * @protected\n\t     * @param {int} currentInputIndex\n\t     * @param {int} targetInputIndex\n\t     *\n\t     * @description gets two inputs indexes and merges into one\n\t     */\n\t    content.mergeBlocks = function (currentInputIndex, targetInputIndex) {\n\t\n\t        /** If current input index is zero, then prevent method execution */\n\t        if (currentInputIndex === 0) {\n\t\n\t            return;\n\t        }\n\t\n\t        var targetInput,\n\t            currentInputContent = editor.state.inputs[currentInputIndex].innerHTML;\n\t\n\t        if (!targetInputIndex) {\n\t\n\t            targetInput = editor.state.inputs[currentInputIndex - 1];\n\t        } else {\n\t\n\t            targetInput = editor.state.inputs[targetInputIndex];\n\t        }\n\t\n\t        targetInput.innerHTML += currentInputContent;\n\t    };\n\t\n\t    /**\n\t     * Iterates all right siblings and parents, which has right siblings\n\t     * while it does not reached the first-level block\n\t     *\n\t     * @param {Element} node\n\t     * @return {boolean}\n\t     */\n\t    content.isLastNode = function (node) {\n\t\n\t        // console.log('погнали перебор родителей');\n\t\n\t        var allChecked = false;\n\t\n\t        while (!allChecked) {\n\t\n\t            // console.log('Смотрим на %o', node);\n\t            // console.log('Проверим, пустые ли соседи справа');\n\t\n\t            if (!allSiblingsEmpty_(node)) {\n\t\n\t                // console.log('Есть непустые соседи. Узел не последний. Выходим.');\n\t                return false;\n\t            }\n\t\n\t            node = node.parentNode;\n\t\n\t            /**\n\t             * Проверяем родителей до тех пор, пока не найдем блок первого уровня\n\t             */\n\t            if (node.classList.contains(editor.modules.ui.className.BLOCK_CONTENT)) {\n\t\n\t                allChecked = true;\n\t            }\n\t        }\n\t\n\t        return true;\n\t    };\n\t\n\t    /**\n\t     * Checks if all element right siblings is empty\n\t     * @param node\n\t     */\n\t    var allSiblingsEmpty_ = function allSiblingsEmpty_(node) {\n\t\n\t        /**\n\t         * Нужно убедиться, что после пустого соседа ничего нет\n\t         */\n\t        var sibling = node.nextSibling;\n\t\n\t        while (sibling) {\n\t\n\t            if (sibling.textContent.length) {\n\t\n\t                return false;\n\t            }\n\t\n\t            sibling = sibling.nextSibling;\n\t        }\n\t\n\t        return true;\n\t    };\n\t\n\t    /**\n\t     * @public\n\t     *\n\t     * @param {string} htmlData - html content as string\n\t     * @param {string} plainData - plain text\n\t     * @return {string} - html content as string\n\t     */\n\t    content.wrapTextWithParagraphs = function (htmlData, plainData) {\n\t\n\t        if (!htmlData.trim()) {\n\t\n\t            return wrapPlainTextWithParagraphs(plainData);\n\t        }\n\t\n\t        var wrapper = document.createElement('DIV'),\n\t            newWrapper = document.createElement('DIV'),\n\t            i,\n\t            paragraph,\n\t            firstLevelBlocks = ['DIV', 'P'],\n\t            blockTyped,\n\t            node;\n\t\n\t        /**\n\t         * Make HTML Element to Wrap Text\n\t         * It allows us to work with input data as HTML content\n\t         */\n\t        wrapper.innerHTML = htmlData;\n\t        paragraph = document.createElement('P');\n\t\n\t        for (i = 0; i < wrapper.childNodes.length; i++) {\n\t\n\t            node = wrapper.childNodes[i];\n\t\n\t            blockTyped = firstLevelBlocks.indexOf(node.tagName) != -1;\n\t\n\t            /**\n\t             * If node is first-levet\n\t             * we add this node to our new wrapper\n\t             */\n\t            if (blockTyped) {\n\t\n\t                /**\n\t                 * If we had splitted inline nodes to paragraph before\n\t                 */\n\t                if (paragraph.childNodes.length) {\n\t\n\t                    newWrapper.appendChild(paragraph.cloneNode(true));\n\t\n\t                    /** empty paragraph */\n\t                    paragraph = null;\n\t                    paragraph = document.createElement('P');\n\t                }\n\t\n\t                newWrapper.appendChild(node.cloneNode(true));\n\t            } else {\n\t\n\t                /** Collect all inline nodes to one as paragraph */\n\t                paragraph.appendChild(node.cloneNode(true));\n\t\n\t                /** if node is last we should append this node to paragraph and paragraph to new wrapper */\n\t                if (i == wrapper.childNodes.length - 1) {\n\t\n\t                    newWrapper.appendChild(paragraph.cloneNode(true));\n\t                }\n\t            }\n\t        }\n\t\n\t        return newWrapper.innerHTML;\n\t    };\n\t\n\t    /**\n\t     * Splits strings on new line and wraps paragraphs with <p> tag\n\t     * @param plainText\n\t     * @returns {string}\n\t     */\n\t    var wrapPlainTextWithParagraphs = function wrapPlainTextWithParagraphs(plainText) {\n\t\n\t        return '<p>' + plainText.split('\\n\\n').join('</p><p>') + '</p>';\n\t    };\n\t\n\t    /**\n\t    * Finds closest Contenteditable parent from Element\n\t    * @param {Element} node     element looking from\n\t    * @return {Element} node    contenteditable\n\t    */\n\t    content.getEditableParent = function (node) {\n\t\n\t        while (node && node.contentEditable != 'true') {\n\t\n\t            node = node.parentNode;\n\t        }\n\t\n\t        return node;\n\t    };\n\t\n\t    /**\n\t    * Clear editors content\n\t     *\n\t     * @param {Boolean} all — if true, delete all article data (content, id, etc.)\n\t    */\n\t    content.clear = function (all) {\n\t\n\t        editor.nodes.redactor.innerHTML = '';\n\t        editor.modules.content.sync();\n\t        editor.modules.ui.saveInputs();\n\t        if (all) {\n\t\n\t            editor.state.blocks = {};\n\t        } else if (editor.state.blocks) {\n\t\n\t            editor.state.blocks.items = [];\n\t        }\n\t\n\t        editor.modules.content.currentNode = null;\n\t    };\n\t\n\t    /**\n\t    *\n\t     * Load new data to editor\n\t     * If editor is not empty, just append articleData.items\n\t     *\n\t    * @param articleData.items\n\t    */\n\t    content.load = function (articleData) {\n\t\n\t        var currentContent = Object.assign({}, editor.state.blocks);\n\t\n\t        editor.modules.content.clear();\n\t\n\t        if (!Object.keys(currentContent).length) {\n\t\n\t            editor.state.blocks = articleData;\n\t        } else if (!currentContent.items) {\n\t\n\t            currentContent.items = articleData.items;\n\t            editor.state.blocks = currentContent;\n\t        } else {\n\t\n\t            currentContent.items = currentContent.items.concat(articleData.items);\n\t            editor.state.blocks = currentContent;\n\t        }\n\t\n\t        editor.modules.renderer.makeBlocksFromData();\n\t    };\n\t\n\t    return content;\n\t};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor toolbar module\n\t *\n\t * Contains:\n\t *  - Inline toolbox\n\t *  - Toolbox within plus button\n\t *  - Settings section\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var toolbar = {};\n\t\n\t    var editor = this;\n\t\n\t    toolbar.settings = __webpack_require__(9).call(editor);\n\t    toolbar.inline = __webpack_require__(10).call(editor);\n\t    toolbar.toolbox = __webpack_require__(11).call(editor);\n\t\n\t    /**\n\t     * Margin between focused node and toolbar\n\t     */\n\t    toolbar.defaultToolbarHeight = 49;\n\t\n\t    toolbar.defaultOffset = 34;\n\t\n\t    toolbar.opened = false;\n\t\n\t    toolbar.current = null;\n\t\n\t    /**\n\t     * @protected\n\t     */\n\t    toolbar.open = function () {\n\t\n\t        if (editor.hideToolbar) {\n\t\n\t            return;\n\t        }\n\t\n\t        var tool = editor.modules.content.currentNode.childNodes[0].childNodes[0].tool;\n\t\n\t        if (!editor.tools[tool.name] || !tool.makeSettings || typeof tool.makeSettings !== 'function') {\n\t\n\t            editor.nodes.showSettingsButton.classList.add('hide');\n\t        } else {\n\t\n\t            editor.nodes.showSettingsButton.classList.remove('hide');\n\t        }\n\t\n\t        editor.nodes.toolbar.classList.add('opened');\n\t        this.opened = true;\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     */\n\t    toolbar.close = function () {\n\t\n\t        editor.nodes.toolbar.classList.remove('opened');\n\t\n\t        toolbar.opened = false;\n\t        toolbar.current = null;\n\t\n\t        for (var button in editor.nodes.toolbarButtons) {\n\t\n\t            editor.nodes.toolbarButtons[button].classList.remove('selected');\n\t        }\n\t\n\t        /** Close toolbox when toolbar is not displayed */\n\t        editor.modules.toolbar.toolbox.close();\n\t        editor.modules.toolbar.settings.close();\n\t    };\n\t\n\t    toolbar.toggle = function () {\n\t\n\t        if (!this.opened) {\n\t\n\t            this.open();\n\t        } else {\n\t\n\t            this.close();\n\t        }\n\t    };\n\t\n\t    toolbar.hidePlusButton = function () {\n\t\n\t        editor.nodes.plusButton.classList.add('hide');\n\t    };\n\t\n\t    toolbar.showPlusButton = function () {\n\t\n\t        editor.nodes.plusButton.classList.remove('hide');\n\t    };\n\t\n\t    /**\n\t     * Moving toolbar to the specified node\n\t     */\n\t    toolbar.move = function () {\n\t\n\t        /** Close Toolbox when we move toolbar */\n\t        editor.modules.toolbar.toolbox.close();\n\t\n\t        if (!editor.modules.content.currentNode) {\n\t\n\t            return;\n\t        }\n\t\n\t        var newYCoordinate = editor.modules.content.currentNode.offsetTop - editor.modules.toolbar.defaultToolbarHeight / 2 + editor.modules.toolbar.defaultOffset;\n\t\n\t        editor.nodes.toolbar.style.transform = 'translate3D(0, ' + Math.floor(newYCoordinate) + 'px, 0)';\n\t\n\t        /** Close trash actions */\n\t        editor.modules.toolbar.settings.hideRemoveActions();\n\t    };\n\t\n\t    return toolbar;\n\t};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Toolbar settings\n\t *\n\t * @version 1.0.5\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var settings = {};\n\t\n\t    var editor = this;\n\t\n\t    settings.opened = false;\n\t\n\t    settings.setting = null;\n\t    settings.actions = null;\n\t\n\t    /**\n\t     * Append and open settings\n\t     */\n\t    settings.open = function (tool) {\n\t\n\t        /**\n\t         * Append settings content\n\t         * It's stored in tool.settings\n\t         */\n\t        if (!editor.tools[tool.name] || !tool.makeSettings || typeof tool.makeSettings !== 'function') {\n\t\n\t            return;\n\t        }\n\t\n\t        /**\n\t         * Draw settings block\n\t         */\n\t        var settingsBlock = tool.makeSettings();\n\t\n\t        editor.nodes.pluginSettings.appendChild(settingsBlock);\n\t\n\t        /** Open settings block */\n\t        editor.nodes.blockSettings.classList.add('opened');\n\t        this.opened = true;\n\t    };\n\t\n\t    /**\n\t     * Close and clear settings\n\t     */\n\t    settings.close = function () {\n\t\n\t        editor.nodes.blockSettings.classList.remove('opened');\n\t        editor.nodes.pluginSettings.innerHTML = '';\n\t\n\t        this.opened = false;\n\t    };\n\t\n\t    /**\n\t     * @param {string} toolType - plugin type\n\t     */\n\t    settings.toggle = function (tool) {\n\t\n\t        if (!this.opened) {\n\t\n\t            this.open(tool);\n\t        } else {\n\t\n\t            this.close();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Here we will draw buttons and add listeners to components\n\t     */\n\t    settings.makeRemoveBlockButton = function () {\n\t\n\t        var removeBlockWrapper = editor.modules.draw.node('SPAN', 'ce-toolbar__remove-btn', {}),\n\t            settingButton = editor.modules.draw.node('SPAN', 'ce-toolbar__remove-setting', { innerHTML: '<i class=\"ce-icon-trash\"></i>' }),\n\t            actionWrapper = editor.modules.draw.node('DIV', 'ce-toolbar__remove-confirmation', {}),\n\t            confirmAction = editor.modules.draw.node('DIV', 'ce-toolbar__remove-confirm', { textContent: 'Удалить блок' }),\n\t            cancelAction = editor.modules.draw.node('DIV', 'ce-toolbar__remove-cancel', { textContent: 'Отмена' });\n\t\n\t        editor.modules.listeners.add(settingButton, 'click', editor.modules.toolbar.settings.removeButtonClicked, false);\n\t\n\t        editor.modules.listeners.add(confirmAction, 'click', editor.modules.toolbar.settings.confirmRemovingRequest, false);\n\t\n\t        editor.modules.listeners.add(cancelAction, 'click', editor.modules.toolbar.settings.cancelRemovingRequest, false);\n\t\n\t        actionWrapper.appendChild(confirmAction);\n\t        actionWrapper.appendChild(cancelAction);\n\t\n\t        removeBlockWrapper.appendChild(settingButton);\n\t        removeBlockWrapper.appendChild(actionWrapper);\n\t\n\t        /** Save setting */\n\t        editor.modules.toolbar.settings.setting = settingButton;\n\t        editor.modules.toolbar.settings.actions = actionWrapper;\n\t\n\t        return removeBlockWrapper;\n\t    };\n\t\n\t    settings.removeButtonClicked = function () {\n\t\n\t        var action = editor.modules.toolbar.settings.actions;\n\t\n\t        if (action.classList.contains('opened')) {\n\t\n\t            editor.modules.toolbar.settings.hideRemoveActions();\n\t        } else {\n\t\n\t            editor.modules.toolbar.settings.showRemoveActions();\n\t        }\n\t\n\t        editor.modules.toolbar.toolbox.close();\n\t        editor.modules.toolbar.settings.close();\n\t    };\n\t\n\t    settings.cancelRemovingRequest = function () {\n\t\n\t        editor.modules.toolbar.settings.actions.classList.remove('opened');\n\t    };\n\t\n\t    settings.confirmRemovingRequest = function () {\n\t\n\t        var currentBlock = editor.modules.content.currentNode,\n\t            firstLevelBlocksCount;\n\t\n\t        currentBlock.remove();\n\t\n\t        firstLevelBlocksCount = editor.nodes.redactor.childNodes.length;\n\t\n\t        /**\n\t         * If all blocks are removed\n\t         */\n\t        if (firstLevelBlocksCount === 0) {\n\t\n\t            /** update currentNode variable */\n\t            editor.modules.content.currentNode = null;\n\t\n\t            /** Inserting new empty initial block */\n\t            editor.modules.ui.addInitialBlock();\n\t        }\n\t\n\t        editor.modules.ui.saveInputs();\n\t\n\t        editor.modules.toolbar.close();\n\t    };\n\t\n\t    settings.showRemoveActions = function () {\n\t\n\t        editor.modules.toolbar.settings.actions.classList.add('opened');\n\t    };\n\t\n\t    settings.hideRemoveActions = function () {\n\t\n\t        editor.modules.toolbar.settings.actions.classList.remove('opened');\n\t    };\n\t\n\t    return settings;\n\t};\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Inline toolbar\n\t *\n\t * Contains from tools:\n\t * Bold, Italic, Underline and Anchor\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var inline = {};\n\t\n\t    var editor = this;\n\t\n\t    inline.buttonsOpened = null;\n\t    inline.actionsOpened = null;\n\t    inline.wrappersOffset = null;\n\t\n\t    /**\n\t     * saving selection that need for execCommand for styling\n\t     *\n\t     */\n\t    inline.storedSelection = null;\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Open inline toobar\n\t     */\n\t    inline.show = function () {\n\t\n\t        var currentNode = editor.modules.content.currentNode,\n\t            tool = currentNode.dataset.tool,\n\t            plugin;\n\t\n\t        /**\n\t         * tool allowed to open inline toolbar\n\t         */\n\t        plugin = editor.tools[tool];\n\t\n\t        if (!plugin.showInlineToolbar) return;\n\t\n\t        var selectedText = inline.getSelectionText(),\n\t            toolbar = editor.nodes.inlineToolbar.wrapper;\n\t\n\t        if (selectedText.length > 0) {\n\t\n\t            /** Move toolbar and open */\n\t            editor.modules.toolbar.inline.move();\n\t\n\t            /** Open inline toolbar */\n\t            toolbar.classList.add('opened');\n\t\n\t            /** show buttons of inline toolbar */\n\t            editor.modules.toolbar.inline.showButtons();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Closes inline toolbar\n\t     */\n\t    inline.close = function () {\n\t\n\t        var toolbar = editor.nodes.inlineToolbar.wrapper;\n\t\n\t        toolbar.classList.remove('opened');\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Moving toolbar\n\t     */\n\t    inline.move = function () {\n\t\n\t        if (!this.wrappersOffset) {\n\t\n\t            this.wrappersOffset = this.getWrappersOffset();\n\t        }\n\t\n\t        var coords = this.getSelectionCoords(),\n\t            defaultOffset = 0,\n\t            toolbar = editor.nodes.inlineToolbar.wrapper,\n\t            newCoordinateX,\n\t            newCoordinateY;\n\t\n\t        if (toolbar.offsetHeight === 0) {\n\t\n\t            defaultOffset = 40;\n\t        }\n\t\n\t        newCoordinateX = coords.x - this.wrappersOffset.left;\n\t        newCoordinateY = coords.y + window.scrollY - this.wrappersOffset.top - defaultOffset - toolbar.offsetHeight;\n\t\n\t        toolbar.style.transform = 'translate3D(' + Math.floor(newCoordinateX) + 'px, ' + Math.floor(newCoordinateY) + 'px, 0)';\n\t\n\t        /** Close everything */\n\t        editor.modules.toolbar.inline.closeButtons();\n\t        editor.modules.toolbar.inline.closeAction();\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Tool Clicked\n\t     */\n\t\n\t    inline.toolClicked = function (event, type) {\n\t\n\t        /**\n\t         * For simple tools we use default browser function\n\t         * For more complicated tools, we should write our own behavior\n\t         */\n\t        switch (type) {\n\t            case 'createLink':\n\t                editor.modules.toolbar.inline.createLinkAction(event, type);break;\n\t            default:\n\t                editor.modules.toolbar.inline.defaultToolAction(type);break;\n\t        }\n\t\n\t        /**\n\t         * highlight buttons\n\t         * after making some action\n\t         */\n\t        editor.nodes.inlineToolbar.buttons.childNodes.forEach(editor.modules.toolbar.inline.hightlight);\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Saving wrappers offset in DOM\n\t     */\n\t    inline.getWrappersOffset = function () {\n\t\n\t        var wrapper = editor.nodes.wrapper,\n\t            offset = this.getOffset(wrapper);\n\t\n\t        this.wrappersOffset = offset;\n\t        return offset;\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Calculates offset of DOM element\n\t     *\n\t     * @param el\n\t     * @returns {{top: number, left: number}}\n\t     */\n\t    inline.getOffset = function (el) {\n\t\n\t        var _x = 0;\n\t        var _y = 0;\n\t\n\t        while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {\n\t\n\t            _x += el.offsetLeft + el.clientLeft;\n\t            _y += el.offsetTop + el.clientTop;\n\t            el = el.offsetParent;\n\t        }\n\t        return { top: _y, left: _x };\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Calculates position of selected text\n\t     * @returns {{x: number, y: number}}\n\t     */\n\t    inline.getSelectionCoords = function () {\n\t\n\t        var sel = document.selection,\n\t            range;\n\t        var x = 0,\n\t            y = 0;\n\t\n\t        if (sel) {\n\t\n\t            if (sel.type != 'Control') {\n\t\n\t                range = sel.createRange();\n\t                range.collapse(true);\n\t                x = range.boundingLeft;\n\t                y = range.boundingTop;\n\t            }\n\t        } else if (window.getSelection) {\n\t\n\t            sel = window.getSelection();\n\t\n\t            if (sel.rangeCount) {\n\t\n\t                range = sel.getRangeAt(0).cloneRange();\n\t                if (range.getClientRects) {\n\t\n\t                    range.collapse(true);\n\t                    var rect = range.getClientRects()[0];\n\t\n\t                    if (!rect) {\n\t\n\t                        return;\n\t                    }\n\t\n\t                    x = rect.left;\n\t                    y = rect.top;\n\t                }\n\t            }\n\t        }\n\t        return { x: x, y: y };\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Returns selected text as String\n\t     * @returns {string}\n\t     */\n\t    inline.getSelectionText = function () {\n\t\n\t        var selectedText = '';\n\t\n\t        // all modern browsers and IE9+\n\t        if (window.getSelection) {\n\t\n\t            selectedText = window.getSelection().toString();\n\t        }\n\t\n\t        return selectedText;\n\t    };\n\t\n\t    /** Opens buttons block */\n\t    inline.showButtons = function () {\n\t\n\t        var buttons = editor.nodes.inlineToolbar.buttons;\n\t\n\t        buttons.classList.add('opened');\n\t\n\t        editor.modules.toolbar.inline.buttonsOpened = true;\n\t\n\t        /** highlight buttons */\n\t        editor.nodes.inlineToolbar.buttons.childNodes.forEach(editor.modules.toolbar.inline.hightlight);\n\t    };\n\t\n\t    /** Makes buttons disappear */\n\t    inline.closeButtons = function () {\n\t\n\t        var buttons = editor.nodes.inlineToolbar.buttons;\n\t\n\t        buttons.classList.remove('opened');\n\t\n\t        editor.modules.toolbar.inline.buttonsOpened = false;\n\t    };\n\t\n\t    /** Open buttons defined action if exist */\n\t    inline.showActions = function () {\n\t\n\t        var action = editor.nodes.inlineToolbar.actions;\n\t\n\t        action.classList.add('opened');\n\t\n\t        editor.modules.toolbar.inline.actionsOpened = true;\n\t    };\n\t\n\t    /** Close actions block */\n\t    inline.closeAction = function () {\n\t\n\t        var action = editor.nodes.inlineToolbar.actions;\n\t\n\t        action.innerHTML = '';\n\t        action.classList.remove('opened');\n\t        editor.modules.toolbar.inline.actionsOpened = false;\n\t    };\n\t\n\t    /**\n\t    * Callback for keydowns in inline toolbar \"Insert link...\" input\n\t    */\n\t    var inlineToolbarAnchorInputKeydown_ = function inlineToolbarAnchorInputKeydown_(event) {\n\t\n\t        if (event.keyCode != editor.core.keys.ENTER) {\n\t\n\t            return;\n\t        }\n\t\n\t        var editable = editor.modules.content.currentNode,\n\t            storedSelection = editor.modules.toolbar.inline.storedSelection;\n\t\n\t        editor.modules.toolbar.inline.restoreSelection(editable, storedSelection);\n\t        editor.modules.toolbar.inline.setAnchor(this.value);\n\t\n\t        /**\n\t         * Preventing events that will be able to happen\n\t         */\n\t        event.preventDefault();\n\t        event.stopImmediatePropagation();\n\t\n\t        editor.modules.toolbar.inline.clearRange();\n\t    };\n\t\n\t    /** Action for link creation or for setting anchor */\n\t    inline.createLinkAction = function (event) {\n\t\n\t        var isActive = this.isLinkActive();\n\t\n\t        var editable = editor.modules.content.currentNode,\n\t            storedSelection = editor.modules.toolbar.inline.saveSelection(editable);\n\t\n\t        /** Save globally selection */\n\t        editor.modules.toolbar.inline.storedSelection = storedSelection;\n\t\n\t        if (isActive) {\n\t\n\t            /**\n\t             * Changing stored selection. if we want to remove anchor from word\n\t             * we should remove anchor from whole word, not only selected part.\n\t             * The solution is than we get the length of current link\n\t             * Change start position to - end of selection minus length of anchor\n\t             */\n\t            editor.modules.toolbar.inline.restoreSelection(editable, storedSelection);\n\t\n\t            editor.modules.toolbar.inline.defaultToolAction('unlink');\n\t        } else {\n\t\n\t            /** Create input and close buttons */\n\t            var action = editor.draw.inputForLink();\n\t\n\t            editor.nodes.inlineToolbar.actions.appendChild(action);\n\t\n\t            editor.modules.toolbar.inline.closeButtons();\n\t            editor.modules.toolbar.inline.showActions();\n\t\n\t            /**\n\t             * focus to input\n\t             * Solution: https://developer.mozilla.org/ru/docs/Web/API/HTMLElement/focus\n\t             * Prevents event after showing input and when we need to focus an input which is in unexisted form\n\t             */\n\t            action.focus();\n\t            event.preventDefault();\n\t\n\t            /** Callback to link action */\n\t            editor.modules.listeners.add(action, 'keydown', inlineToolbarAnchorInputKeydown_, false);\n\t        }\n\t    };\n\t\n\t    inline.isLinkActive = function () {\n\t\n\t        var isActive = false;\n\t\n\t        editor.nodes.inlineToolbar.buttons.childNodes.forEach(function (tool) {\n\t\n\t            var dataType = tool.dataset.type;\n\t\n\t            if (dataType == 'link' && tool.classList.contains('hightlighted')) {\n\t\n\t                isActive = true;\n\t            }\n\t        });\n\t\n\t        return isActive;\n\t    };\n\t\n\t    /** default action behavior of tool */\n\t    inline.defaultToolAction = function (type) {\n\t\n\t        document.execCommand(type, false, null);\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Sets URL\n\t     *\n\t     * @param {String} url - URL\n\t     */\n\t    inline.setAnchor = function (url) {\n\t\n\t        document.execCommand('createLink', false, url);\n\t\n\t        /** Close after URL inserting */\n\t        editor.modules.toolbar.inline.closeAction();\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Saves selection\n\t     */\n\t    inline.saveSelection = function (containerEl) {\n\t\n\t        var range = window.getSelection().getRangeAt(0),\n\t            preSelectionRange = range.cloneRange(),\n\t            start;\n\t\n\t        preSelectionRange.selectNodeContents(containerEl);\n\t        preSelectionRange.setEnd(range.startContainer, range.startOffset);\n\t\n\t        start = preSelectionRange.toString().length;\n\t\n\t        return {\n\t            start: start,\n\t            end: start + range.toString().length\n\t        };\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Sets to previous selection (Range)\n\t     *\n\t     * @param {Element} containerEl - editable element where we restore range\n\t     * @param {Object} savedSel - range basic information to restore\n\t     */\n\t    inline.restoreSelection = function (containerEl, savedSel) {\n\t\n\t        var range = document.createRange(),\n\t            charIndex = 0;\n\t\n\t        range.setStart(containerEl, 0);\n\t        range.collapse(true);\n\t\n\t        var nodeStack = [containerEl],\n\t            node,\n\t            foundStart = false,\n\t            stop = false,\n\t            nextCharIndex;\n\t\n\t        while (!stop && (node = nodeStack.pop())) {\n\t\n\t            if (node.nodeType == 3) {\n\t\n\t                nextCharIndex = charIndex + node.length;\n\t\n\t                if (!foundStart && savedSel.start >= charIndex && savedSel.start <= nextCharIndex) {\n\t\n\t                    range.setStart(node, savedSel.start - charIndex);\n\t                    foundStart = true;\n\t                }\n\t                if (foundStart && savedSel.end >= charIndex && savedSel.end <= nextCharIndex) {\n\t\n\t                    range.setEnd(node, savedSel.end - charIndex);\n\t                    stop = true;\n\t                }\n\t                charIndex = nextCharIndex;\n\t            } else {\n\t\n\t                var i = node.childNodes.length;\n\t\n\t                while (i--) {\n\t\n\t                    nodeStack.push(node.childNodes[i]);\n\t                }\n\t            }\n\t        }\n\t\n\t        var sel = window.getSelection();\n\t\n\t        sel.removeAllRanges();\n\t        sel.addRange(range);\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Removes all ranges from window selection\n\t     */\n\t    inline.clearRange = function () {\n\t\n\t        var selection = window.getSelection();\n\t\n\t        selection.removeAllRanges();\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * sets or removes hightlight\n\t     */\n\t    inline.hightlight = function (tool) {\n\t\n\t        var dataType = tool.dataset.type;\n\t\n\t        if (document.queryCommandState(dataType)) {\n\t\n\t            editor.modules.toolbar.inline.setButtonHighlighted(tool);\n\t        } else {\n\t\n\t            editor.modules.toolbar.inline.removeButtonsHighLight(tool);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * hightlight for anchors\n\t         */\n\t        var selection = window.getSelection(),\n\t            tag = selection.anchorNode.parentNode;\n\t\n\t        if (tag.tagName == 'A' && dataType == 'link') {\n\t\n\t            editor.modules.toolbar.inline.setButtonHighlighted(tool);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Mark button if text is already executed\n\t     */\n\t    inline.setButtonHighlighted = function (button) {\n\t\n\t        button.classList.add('hightlighted');\n\t\n\t        /** At link tool we also change icon */\n\t        if (button.dataset.type == 'link') {\n\t\n\t            var icon = button.childNodes[0];\n\t\n\t            icon.classList.remove('ce-icon-link');\n\t            icon.classList.add('ce-icon-unlink');\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Removes hightlight\n\t     */\n\t    inline.removeButtonsHighLight = function (button) {\n\t\n\t        button.classList.remove('hightlighted');\n\t\n\t        /** At link tool we also change icon */\n\t        if (button.dataset.type == 'link') {\n\t\n\t            var icon = button.childNodes[0];\n\t\n\t            icon.classList.remove('ce-icon-unlink');\n\t            icon.classList.add('ce-icon-link');\n\t        }\n\t    };\n\t\n\t    return inline;\n\t};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor toolbox\n\t *\n\t * All tools be able to appended here\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var toolbox = {};\n\t\n\t    var editor = this;\n\t\n\t    toolbox.opened = false;\n\t    toolbox.openedOnBlock = null;\n\t\n\t    /** Shows toolbox */\n\t    toolbox.open = function () {\n\t\n\t        /** Close setting if toolbox is opened */\n\t        if (editor.modules.toolbar.settings.opened) {\n\t\n\t            editor.modules.toolbar.settings.close();\n\t        }\n\t\n\t        /** Add 'toolbar-opened' class for current block **/\n\t        toolbox.openedOnBlock = editor.modules.content.currentNode;\n\t        toolbox.openedOnBlock.classList.add('toolbar-opened');\n\t\n\t        /** display toolbox */\n\t        editor.nodes.toolbox.classList.add('opened');\n\t\n\t        /** Animate plus button */\n\t        editor.nodes.plusButton.classList.add('clicked');\n\t\n\t        /** toolbox state */\n\t        editor.modules.toolbar.toolbox.opened = true;\n\t    };\n\t\n\t    /** Closes toolbox */\n\t    toolbox.close = function () {\n\t\n\t        /** Remove 'toolbar-opened' class from current block **/\n\t        if (toolbox.openedOnBlock) toolbox.openedOnBlock.classList.remove('toolbar-opened');\n\t        toolbox.openedOnBlock = null;\n\t\n\t        /** Makes toolbox disappear */\n\t        editor.nodes.toolbox.classList.remove('opened');\n\t\n\t        /** Rotate plus button */\n\t        editor.nodes.plusButton.classList.remove('clicked');\n\t\n\t        /** toolbox state */\n\t        editor.modules.toolbar.toolbox.opened = false;\n\t\n\t        editor.modules.toolbar.current = null;\n\t    };\n\t\n\t    toolbox.leaf = function () {\n\t\n\t        var currentTool = editor.modules.toolbar.current,\n\t            tools = Object.keys(editor.tools),\n\t            barButtons = editor.nodes.toolbarButtons,\n\t            nextToolIndex = 0,\n\t            toolToSelect = void 0,\n\t            visibleTool = void 0,\n\t            tool = void 0;\n\t\n\t        if (!currentTool) {\n\t\n\t            /** Get first tool from object*/\n\t            for (tool in editor.tools) {\n\t\n\t                if (editor.tools[tool].displayInToolbox) {\n\t\n\t                    break;\n\t                }\n\t\n\t                nextToolIndex++;\n\t            }\n\t        } else {\n\t\n\t            nextToolIndex = (tools.indexOf(currentTool) + 1) % tools.length;\n\t            visibleTool = tools[nextToolIndex];\n\t\n\t            while (!editor.tools[visibleTool].displayInToolbox) {\n\t\n\t                nextToolIndex = (nextToolIndex + 1) % tools.length;\n\t                visibleTool = tools[nextToolIndex];\n\t            }\n\t        }\n\t\n\t        toolToSelect = tools[nextToolIndex];\n\t\n\t        for (var button in barButtons) {\n\t\n\t            barButtons[button].classList.remove('selected');\n\t        }\n\t\n\t        barButtons[toolToSelect].classList.add('selected');\n\t        editor.modules.toolbar.current = toolToSelect;\n\t    };\n\t\n\t    /**\n\t     * Transforming selected node type into selected toolbar element type\n\t     * @param {event} event\n\t     */\n\t    toolbox.toolClicked = function (event) {\n\t\n\t        /**\n\t         * UNREPLACEBLE_TOOLS this types of tools are forbidden to replace even they are empty\n\t         */\n\t        var UNREPLACEBLE_TOOLS = ['image', 'link', 'list', 'instagram', 'twitter', 'embed'],\n\t            tool = editor.tools[editor.modules.toolbar.current],\n\t            workingNode = editor.modules.content.currentNode,\n\t            currentInputIndex = editor.modules.caret.inputIndex,\n\t            newBlockContent,\n\t            appendCallback,\n\t            blockData;\n\t\n\t        /** Make block from plugin */\n\t        newBlockContent = editor.modules.renderer.makeBlockFromData({ type: tool.type });\n\t\n\t        /** information about block */\n\t        blockData = {\n\t            block: newBlockContent,\n\t            type: tool.type,\n\t            stretched: false\n\t        };\n\t\n\t        if (workingNode && UNREPLACEBLE_TOOLS.indexOf(workingNode.dataset.tool) === -1 && workingNode.textContent.trim() === '') {\n\t\n\t            /** Replace current block */\n\t            editor.modules.content.switchBlock(workingNode, newBlockContent, tool.type);\n\t        } else {\n\t\n\t            /** Insert new Block from plugin */\n\t            editor.modules.content.insertBlock(blockData);\n\t\n\t            /** increase input index */\n\t            currentInputIndex++;\n\t        }\n\t\n\t        /** Fire tool append callback  */\n\t        appendCallback = tool.appendCallback;\n\t\n\t        if (appendCallback && typeof appendCallback == 'function') {\n\t\n\t            appendCallback.call(event);\n\t        }\n\t\n\t        window.setTimeout(function () {\n\t\n\t            /** Set caret to current block */\n\t            editor.modules.caret.setToBlock(currentInputIndex);\n\t        }, 10);\n\t\n\t        /**\n\t         * Changing current Node\n\t         */\n\t        editor.modules.content.workingNodeChanged();\n\t\n\t        /**\n\t         * Move toolbar when node is changed\n\t         */\n\t        editor.modules.toolbar.move();\n\t    };\n\t\n\t    return toolbox;\n\t};\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * @module Codex Editor Callbacks module\n\t * @description Module works with editor added Elements\n\t *\n\t * @author Codex Team\n\t * @version 1.4.0\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var callbacks = {};\n\t\n\t    var editor = this;\n\t\n\t    /**\n\t     * used by UI module\n\t     * @description Routes all keydowns on document\n\t     * @param {Object} event\n\t     */\n\t    callbacks.globalKeydown = function (event) {\n\t\n\t        switch (event.keyCode) {\n\t            case editor.modules.core.keys.ENTER:\n\t                enterKeyPressed_(event);break;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * used by UI module\n\t     * @description Routes all keydowns on redactors area\n\t     * @param {Object} event\n\t     */\n\t    callbacks.redactorKeyDown = function (event) {\n\t\n\t        switch (event.keyCode) {\n\t            case editor.modules.core.keys.TAB:\n\t                tabKeyPressedOnRedactorsZone_(event);break;\n\t            case editor.modules.core.keys.ENTER:\n\t                enterKeyPressedOnRedactorsZone_(event);break;\n\t            case editor.modules.core.keys.ESC:\n\t                escapeKeyPressedOnRedactorsZone_(event);break;\n\t            default:\n\t                defaultKeyPressedOnRedactorsZone_(event);break;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * used by UI module\n\t     * @description Routes all keyup events\n\t     * @param {Object} event\n\t     */\n\t    callbacks.globalKeyup = function (event) {\n\t\n\t        switch (event.keyCode) {\n\t            case editor.modules.core.keys.UP:\n\t            case editor.modules.core.keys.LEFT:\n\t            case editor.modules.core.keys.RIGHT:\n\t            case editor.modules.core.keys.DOWN:\n\t                arrowKeyPressed_(event);break;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {Object} event\n\t     * @private\n\t     *\n\t     * Handles behaviour when tab pressed\n\t     * @description if Content is empty show toolbox (if it is closed) or leaf tools\n\t     * uses Toolbars toolbox module to handle the situation\n\t     */\n\t    var tabKeyPressedOnRedactorsZone_ = function tabKeyPressedOnRedactorsZone_(event) {\n\t\n\t        /**\n\t         * Wait for solution. Would like to know the behaviour\n\t         * @todo Add spaces\n\t         */\n\t        event.preventDefault();\n\t\n\t        if (!editor.modules.core.isBlockEmpty(editor.modules.content.currentNode)) {\n\t\n\t            return;\n\t        }\n\t\n\t        if (!editor.modules.toolbar.opened) {\n\t\n\t            editor.modules.toolbar.open();\n\t        }\n\t\n\t        if (editor.modules.toolbar.opened && !editor.modules.toolbar.toolbox.opened) {\n\t\n\t            editor.modules.toolbar.toolbox.open();\n\t        } else {\n\t\n\t            editor.modules.toolbar.toolbox.leaf();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Handles global EnterKey Press\n\t     * @see enterPressedOnBlock_\n\t     * @param {Object} event\n\t     */\n\t    var enterKeyPressed_ = function enterKeyPressed_() {\n\t\n\t        if (editor.modules.content.editorAreaHightlighted) {\n\t\n\t            /**\n\t             * it means that we lose input index, saved index before is not correct\n\t             * therefore we need to set caret when we insert new block\n\t             */\n\t            editor.modules.caret.inputIndex = -1;\n\t\n\t            enterPressedOnBlock_();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Callback for enter key pressing in first-level block area\n\t     *\n\t     * @param {Event} event\n\t     * @private\n\t     *\n\t     * @description Inserts new block with initial type from settings\n\t     */\n\t    var enterPressedOnBlock_ = function enterPressedOnBlock_() {\n\t\n\t        var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\t\n\t        editor.modules.content.insertBlock({\n\t            type: NEW_BLOCK_TYPE,\n\t            block: editor.tools[NEW_BLOCK_TYPE].render()\n\t        }, true);\n\t\n\t        editor.modules.toolbar.move();\n\t        editor.modules.toolbar.open();\n\t    };\n\t\n\t    /**\n\t     * ENTER key handler\n\t     *\n\t     * @param {Object} event\n\t     * @private\n\t     *\n\t     * @description Makes new block with initial type from settings\n\t     */\n\t    var enterKeyPressedOnRedactorsZone_ = function enterKeyPressedOnRedactorsZone_(event) {\n\t\n\t        if (event.target.contentEditable == 'true') {\n\t\n\t            /** Update input index */\n\t            editor.modules.caret.saveCurrentInputIndex();\n\t        }\n\t\n\t        var currentInputIndex = editor.modules.caret.getCurrentInputIndex() || 0,\n\t            workingNode = editor.modules.content.currentNode,\n\t            tool = workingNode.dataset.tool,\n\t            isEnterPressedOnToolbar = editor.modules.toolbar.opened && editor.modules.toolbar.current && event.target == editor.state.inputs[currentInputIndex];\n\t\n\t        /** The list of tools which needs the default browser behaviour */\n\t        var enableLineBreaks = editor.tools[tool].enableLineBreaks;\n\t\n\t        /** This type of block creates when enter is pressed */\n\t        var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\t\n\t        /**\n\t         * When toolbar is opened, select tool instead of making new paragraph\n\t         */\n\t        if (isEnterPressedOnToolbar) {\n\t\n\t            event.preventDefault();\n\t\n\t            editor.modules.toolbar.toolbox.toolClicked(event);\n\t\n\t            editor.modules.toolbar.close();\n\t\n\t            /**\n\t             * Stop other listeners callback executions\n\t             */\n\t            event.stopPropagation();\n\t            event.stopImmediatePropagation();\n\t\n\t            return;\n\t        }\n\t\n\t        /**\n\t         * Allow paragraph lineBreaks with shift enter\n\t         * Or if shiftkey pressed and enter and enabledLineBreaks, the let new block creation\n\t         */\n\t        if (event.shiftKey || enableLineBreaks) {\n\t\n\t            event.stopPropagation();\n\t            event.stopImmediatePropagation();\n\t            return;\n\t        }\n\t\n\t        var currentSelection = window.getSelection(),\n\t            currentSelectedNode = currentSelection.anchorNode,\n\t            caretAtTheEndOfText = editor.modules.caret.position.atTheEnd(),\n\t            isTextNodeHasParentBetweenContenteditable = false;\n\t\n\t        /**\n\t         * Allow making new <p> in same block by SHIFT+ENTER and forbids to prevent default browser behaviour\n\t         */\n\t        if (event.shiftKey && !enableLineBreaks) {\n\t\n\t            editor.modules.callback.enterPressedOnBlock(editor.modules.content.currentBlock, event);\n\t            event.preventDefault();\n\t            return;\n\t        }\n\t\n\t        /**\n\t         * Workaround situation when caret at the Text node that has some wrapper Elements\n\t         * Split block cant handle this.\n\t         * We need to save default behavior\n\t         */\n\t        isTextNodeHasParentBetweenContenteditable = currentSelectedNode && currentSelectedNode.parentNode.contentEditable != 'true';\n\t\n\t        /**\n\t         * Split blocks when input has several nodes and caret placed in textNode\n\t         */\n\t        if (currentSelectedNode.nodeType == editor.modules.core.nodeTypes.TEXT && !isTextNodeHasParentBetweenContenteditable && !caretAtTheEndOfText) {\n\t\n\t            event.preventDefault();\n\t\n\t            editor.modules.core.log('Splitting Text node...');\n\t\n\t            editor.modules.content.splitBlock(currentInputIndex);\n\t\n\t            /** Show plus button when next input after split is empty*/\n\t            if (!editor.state.inputs[currentInputIndex + 1].textContent.trim()) {\n\t\n\t                editor.modules.toolbar.showPlusButton();\n\t            }\n\t        } else {\n\t\n\t            var islastNode = editor.modules.content.isLastNode(currentSelectedNode);\n\t\n\t            if (islastNode && caretAtTheEndOfText) {\n\t\n\t                event.preventDefault();\n\t                event.stopPropagation();\n\t                event.stopImmediatePropagation();\n\t\n\t                editor.modules.core.log('ENTER clicked in last textNode. Create new BLOCK');\n\t\n\t                editor.modules.content.insertBlock({\n\t                    type: NEW_BLOCK_TYPE,\n\t                    block: editor.modules.renderer.makeBlockFromData({ type: NEW_BLOCK_TYPE })\n\t                }, true);\n\t\n\t                editor.modules.toolbar.move();\n\t                editor.modules.toolbar.open();\n\t\n\t                /** Show plus button with empty block */\n\t                editor.modules.toolbar.showPlusButton();\n\t            }\n\t        }\n\t\n\t        /** get all inputs after new appending block */\n\t        editor.modules.ui.saveInputs();\n\t    };\n\t\n\t    /**\n\t     * Escape behaviour\n\t     * @param event\n\t     * @private\n\t     *\n\t     * @description Closes toolbox and toolbar. Prevents default behaviour\n\t     */\n\t    var escapeKeyPressedOnRedactorsZone_ = function escapeKeyPressedOnRedactorsZone_(event) {\n\t\n\t        /** Close all toolbar */\n\t        editor.modules.toolbar.close();\n\t\n\t        /** Close toolbox */\n\t        editor.modules.toolbar.toolbox.close();\n\t\n\t        event.preventDefault();\n\t    };\n\t\n\t    /**\n\t     * @param {Event} event\n\t     * @private\n\t     *\n\t     * closes and moves toolbar\n\t     */\n\t    var arrowKeyPressed_ = function arrowKeyPressed_(event) {\n\t\n\t        editor.modules.content.workingNodeChanged();\n\t\n\t        /* Closing toolbar */\n\t        editor.modules.toolbar.close();\n\t        editor.modules.toolbar.move();\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     * @param {Event} event\n\t     *\n\t     * @description Closes all opened bars from toolbar.\n\t     * If block is mark, clears highlightning\n\t     */\n\t    var defaultKeyPressedOnRedactorsZone_ = function defaultKeyPressedOnRedactorsZone_() {\n\t\n\t        editor.modules.toolbar.close();\n\t\n\t        if (!editor.modules.toolbar.inline.actionsOpened) {\n\t\n\t            editor.modules.toolbar.inline.close();\n\t            editor.modules.content.clearMark();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Handler when clicked on redactors area\n\t     *\n\t     * @protected\n\t     * @param event\n\t     *\n\t     * @description Detects clicked area. If it is first-level block area, marks as detected and\n\t     * on next enter press will be inserted new block\n\t     * Otherwise, save carets position (input index) and put caret to the editable zone.\n\t     *\n\t     * @see detectWhenClickedOnFirstLevelBlockArea_\n\t     *\n\t     */\n\t    callbacks.redactorClicked = function (event) {\n\t\n\t        detectWhenClickedOnFirstLevelBlockArea_();\n\t\n\t        editor.modules.content.workingNodeChanged(event.target);\n\t        editor.modules.ui.saveInputs();\n\t\n\t        var selectedText = editor.modules.toolbar.inline.getSelectionText(),\n\t            firstLevelBlock;\n\t\n\t        /** If selection range took off, then we hide inline toolbar */\n\t        if (selectedText.length === 0) {\n\t\n\t            editor.modules.toolbar.inline.close();\n\t        }\n\t\n\t        /** Update current input index in memory when caret focused into existed input */\n\t        if (event.target.contentEditable == 'true') {\n\t\n\t            editor.modules.caret.saveCurrentInputIndex();\n\t        }\n\t\n\t        if (editor.modules.content.currentNode === null) {\n\t\n\t            /**\n\t             * If inputs in redactor does not exits, then we put input index 0 not -1\n\t             */\n\t            var indexOfLastInput = editor.state.inputs.length > 0 ? editor.state.inputs.length - 1 : 0;\n\t\n\t            /** If we have any inputs */\n\t            if (editor.state.inputs.length) {\n\t\n\t                /** getting firstlevel parent of input */\n\t                firstLevelBlock = editor.modules.content.getFirstLevelBlock(editor.state.inputs[indexOfLastInput]);\n\t            }\n\t\n\t            /** If input is empty, then we set caret to the last input */\n\t            if (editor.state.inputs.length && editor.state.inputs[indexOfLastInput].textContent === '' && firstLevelBlock.dataset.tool == editor.settings.initialBlockPlugin) {\n\t\n\t                editor.modules.caret.setToBlock(indexOfLastInput);\n\t            } else {\n\t\n\t                /** Create new input when caret clicked in redactors area */\n\t                var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\t\n\t                editor.modules.content.insertBlock({\n\t                    type: NEW_BLOCK_TYPE,\n\t                    block: editor.modules.renderer.makeBlockFromData({ type: NEW_BLOCK_TYPE })\n\t                });\n\t\n\t                /** If there is no inputs except inserted */\n\t                if (editor.state.inputs.length === 1) {\n\t\n\t                    editor.modules.caret.setToBlock(indexOfLastInput);\n\t                } else {\n\t\n\t                    /** Set caret to this appended input */\n\t                    editor.modules.caret.setToNextBlock(indexOfLastInput);\n\t                }\n\t            }\n\t        } else {\n\t\n\t            /** Close all panels */\n\t            editor.modules.toolbar.settings.close();\n\t            editor.modules.toolbar.toolbox.close();\n\t        }\n\t\n\t        /**\n\t         * Move toolbar and open\n\t         */\n\t        editor.modules.toolbar.move();\n\t        editor.modules.toolbar.open();\n\t\n\t        var inputIsEmpty = !editor.modules.content.currentNode.textContent.trim(),\n\t            currentNodeType = editor.modules.content.currentNode.dataset.tool,\n\t            isInitialType = currentNodeType == editor.settings.initialBlockPlugin;\n\t\n\t        /** Hide plus buttons */\n\t        editor.modules.toolbar.hidePlusButton();\n\t\n\t        if (!inputIsEmpty) {\n\t\n\t            /** Mark current block */\n\t            editor.modules.content.markBlock();\n\t        }\n\t\n\t        if (isInitialType && inputIsEmpty) {\n\t\n\t            /** Show plus button */\n\t            editor.modules.toolbar.showPlusButton();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * This method allows to define, is caret in contenteditable element or not.\n\t     *\n\t     * @private\n\t     *\n\t     * @description Otherwise, if we get TEXT node from range container, that will means we have input index.\n\t     * In this case we use default browsers behaviour (if plugin allows that) or overwritten action.\n\t     * Therefore, to be sure that we've clicked first-level block area, we should have currentNode, which always\n\t     * specifies to the first-level block. Other cases we just ignore.\n\t     */\n\t    var detectWhenClickedOnFirstLevelBlockArea_ = function detectWhenClickedOnFirstLevelBlockArea_() {\n\t\n\t        var selection = window.getSelection(),\n\t            anchorNode = selection.anchorNode,\n\t            flag = false;\n\t\n\t        if (selection.rangeCount === 0) {\n\t\n\t            editor.modules.content.editorAreaHightlighted = true;\n\t        } else {\n\t\n\t            if (!editor.modules.core.isDomNode(anchorNode)) {\n\t\n\t                anchorNode = anchorNode.parentNode;\n\t            }\n\t\n\t            /** Already founded, without loop */\n\t            if (anchorNode.contentEditable == 'true') {\n\t\n\t                flag = true;\n\t            }\n\t\n\t            while (anchorNode.contentEditable != 'true') {\n\t\n\t                anchorNode = anchorNode.parentNode;\n\t\n\t                if (anchorNode.contentEditable == 'true') {\n\t\n\t                    flag = true;\n\t                }\n\t\n\t                if (anchorNode == document.body) {\n\t\n\t                    break;\n\t                }\n\t            }\n\t\n\t            /** If editable element founded, flag is \"TRUE\", Therefore we return \"FALSE\" */\n\t            editor.modules.content.editorAreaHightlighted = !flag;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Toolbar button click handler\n\t     *\n\t     * @param {Object} event - cursor to the button\n\t     * @protected\n\t     *\n\t     * @description gets current tool and calls render method\n\t     */\n\t    callbacks.toolbarButtonClicked = function (event) {\n\t\n\t        var button = this;\n\t\n\t        editor.modules.toolbar.current = button.dataset.type;\n\t\n\t        editor.modules.toolbar.toolbox.toolClicked(event);\n\t        editor.modules.toolbar.close();\n\t    };\n\t\n\t    /**\n\t     * Show or Hide toolbox when plus button is clicked\n\t     */\n\t    callbacks.plusButtonClicked = function () {\n\t\n\t        if (!editor.nodes.toolbox.classList.contains('opened')) {\n\t\n\t            editor.modules.toolbar.toolbox.open();\n\t        } else {\n\t\n\t            editor.modules.toolbar.toolbox.close();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Block handlers for KeyDown events\n\t     *\n\t     * @protected\n\t     * @param {Object} event\n\t     *\n\t     * Handles keydowns on block\n\t     * @see blockRightOrDownArrowPressed_\n\t     * @see backspacePressed_\n\t     * @see blockLeftOrUpArrowPressed_\n\t     */\n\t    callbacks.blockKeydown = function (event) {\n\t\n\t        var block = event.target; // event.target is input\n\t\n\t        switch (event.keyCode) {\n\t\n\t            case editor.modules.core.keys.DOWN:\n\t            case editor.modules.core.keys.RIGHT:\n\t                blockRightOrDownArrowPressed_(event);\n\t                break;\n\t\n\t            case editor.modules.core.keys.BACKSPACE:\n\t                backspacePressed_(block, event);\n\t                break;\n\t\n\t            case editor.modules.core.keys.UP:\n\t            case editor.modules.core.keys.LEFT:\n\t                blockLeftOrUpArrowPressed_(event);\n\t                break;\n\t\n\t        }\n\t    };\n\t\n\t    /**\n\t     * RIGHT or DOWN keydowns on block\n\t     *\n\t     * @param {Object} event\n\t     * @private\n\t     *\n\t     * @description watches the selection and gets closest editable element.\n\t     * Uses method getDeepestTextNodeFromPosition to get the last node of next block\n\t     * Sets caret if it is contenteditable\n\t     */\n\t    var blockRightOrDownArrowPressed_ = function blockRightOrDownArrowPressed_(event) {\n\t\n\t        var selection = window.getSelection(),\n\t            inputs = editor.state.inputs,\n\t            focusedNode = selection.anchorNode,\n\t            focusedNodeHolder;\n\t\n\t        /** Check for caret existance */\n\t        if (!focusedNode) {\n\t\n\t            return false;\n\t        }\n\t\n\t        /** Looking for closest (parent) contentEditable element of focused node */\n\t        while (focusedNode.contentEditable != 'true') {\n\t\n\t            focusedNodeHolder = focusedNode.parentNode;\n\t            focusedNode = focusedNodeHolder;\n\t        }\n\t\n\t        /** Input index in DOM level */\n\t        var editableElementIndex = 0;\n\t\n\t        while (focusedNode != inputs[editableElementIndex]) {\n\t\n\t            editableElementIndex++;\n\t        }\n\t\n\t        /**\n\t         * Founded contentEditable element doesn't have childs\n\t         * Or maybe New created block\n\t         */\n\t        if (!focusedNode.textContent) {\n\t\n\t            editor.modules.caret.setToNextBlock(editableElementIndex);\n\t            return;\n\t        }\n\t\n\t        /**\n\t         * Do nothing when caret doesn not reaches the end of last child\n\t         */\n\t        var caretInLastChild = false,\n\t            caretAtTheEndOfText = false;\n\t\n\t        var lastChild, deepestTextnode;\n\t\n\t        lastChild = focusedNode.childNodes[focusedNode.childNodes.length - 1];\n\t\n\t        if (editor.core.isDomNode(lastChild)) {\n\t\n\t            deepestTextnode = editor.modules.content.getDeepestTextNodeFromPosition(lastChild, lastChild.childNodes.length);\n\t        } else {\n\t\n\t            deepestTextnode = lastChild;\n\t        }\n\t\n\t        caretInLastChild = selection.anchorNode == deepestTextnode;\n\t        caretAtTheEndOfText = deepestTextnode.length == selection.anchorOffset;\n\t\n\t        if (!caretInLastChild || !caretAtTheEndOfText) {\n\t\n\t            editor.modules.core.log('arrow [down|right] : caret does not reached the end');\n\t            return false;\n\t        }\n\t\n\t        editor.modules.caret.setToNextBlock(editableElementIndex);\n\t    };\n\t\n\t    /**\n\t     * LEFT or UP keydowns on block\n\t     *\n\t     * @param {Object} event\n\t     * @private\n\t     *\n\t     * watches the selection and gets closest editable element.\n\t     * Uses method getDeepestTextNodeFromPosition to get the last node of previous block\n\t     * Sets caret if it is contenteditable\n\t     *\n\t     */\n\t    var blockLeftOrUpArrowPressed_ = function blockLeftOrUpArrowPressed_(event) {\n\t\n\t        var selection = window.getSelection(),\n\t            inputs = editor.state.inputs,\n\t            focusedNode = selection.anchorNode,\n\t            focusedNodeHolder;\n\t\n\t        /** Check for caret existance */\n\t        if (!focusedNode) {\n\t\n\t            return false;\n\t        }\n\t\n\t        /**\n\t         * LEFT or UP not at the beginning\n\t         */\n\t        if (selection.anchorOffset !== 0) {\n\t\n\t            return false;\n\t        }\n\t\n\t        /** Looking for parent contentEditable block */\n\t        while (focusedNode.contentEditable != 'true') {\n\t\n\t            focusedNodeHolder = focusedNode.parentNode;\n\t            focusedNode = focusedNodeHolder;\n\t        }\n\t\n\t        /** Input index in DOM level */\n\t        var editableElementIndex = 0;\n\t\n\t        while (focusedNode != inputs[editableElementIndex]) {\n\t\n\t            editableElementIndex++;\n\t        }\n\t\n\t        /**\n\t         * Do nothing if caret is not at the beginning of first child\n\t         */\n\t        var caretInFirstChild = false,\n\t            caretAtTheBeginning = false;\n\t\n\t        var firstChild, deepestTextnode;\n\t\n\t        /**\n\t         * Founded contentEditable element doesn't have childs\n\t         * Or maybe New created block\n\t         */\n\t        if (!focusedNode.textContent) {\n\t\n\t            editor.modules.caret.setToPreviousBlock(editableElementIndex);\n\t            return;\n\t        }\n\t\n\t        firstChild = focusedNode.childNodes[0];\n\t\n\t        if (editor.modules.core.isDomNode(firstChild)) {\n\t\n\t            deepestTextnode = editor.modules.content.getDeepestTextNodeFromPosition(firstChild, 0);\n\t        } else {\n\t\n\t            deepestTextnode = firstChild;\n\t        }\n\t\n\t        caretInFirstChild = selection.anchorNode == deepestTextnode;\n\t        caretAtTheBeginning = selection.anchorOffset === 0;\n\t\n\t        if (caretInFirstChild && caretAtTheBeginning) {\n\t\n\t            editor.modules.caret.setToPreviousBlock(editableElementIndex);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Handles backspace keydown\n\t     *\n\t     * @param {Element} block\n\t     * @param {Object} event\n\t     * @private\n\t     *\n\t     * @description if block is empty, delete the block and set caret to the previous block\n\t     * If block is not empty, try to merge two blocks - current and previous\n\t     * But it we try'n to remove first block, then we should set caret to the next block, not previous.\n\t     * If we removed the last block, create new one\n\t     */\n\t    var backspacePressed_ = function backspacePressed_(block, event) {\n\t\n\t        var currentInputIndex = editor.modules.caret.getCurrentInputIndex(),\n\t            range,\n\t            selectionLength,\n\t            firstLevelBlocksCount;\n\t\n\t        if (editor.modules.core.isNativeInput(event.target)) {\n\t\n\t            /** If input value is empty - remove block */\n\t            if (event.target.value.trim() == '') {\n\t\n\t                block.remove();\n\t            } else {\n\t\n\t                return;\n\t            }\n\t        }\n\t\n\t        if (block.textContent.trim()) {\n\t\n\t            range = editor.modules.content.getRange();\n\t            selectionLength = range.endOffset - range.startOffset;\n\t\n\t            if (editor.modules.caret.position.atStart() && !selectionLength && editor.state.inputs[currentInputIndex - 1]) {\n\t\n\t                editor.modules.content.mergeBlocks(currentInputIndex);\n\t            } else {\n\t\n\t                return;\n\t            }\n\t        }\n\t\n\t        if (!selectionLength) {\n\t\n\t            block.remove();\n\t        }\n\t\n\t        firstLevelBlocksCount = editor.nodes.redactor.childNodes.length;\n\t\n\t        /**\n\t         * If all blocks are removed\n\t         */\n\t        if (firstLevelBlocksCount === 0) {\n\t\n\t            /** update currentNode variable */\n\t            editor.modules.content.currentNode = null;\n\t\n\t            /** Inserting new empty initial block */\n\t            editor.modules.ui.addInitialBlock();\n\t\n\t            /** Updating inputs state after deleting last block */\n\t            editor.modules.ui.saveInputs();\n\t\n\t            /** Set to current appended block */\n\t            window.setTimeout(function () {\n\t\n\t                editor.modules.caret.setToPreviousBlock(1);\n\t            }, 10);\n\t        } else {\n\t\n\t            if (editor.modules.caret.inputIndex !== 0) {\n\t\n\t                /** Target block is not first */\n\t                editor.modules.caret.setToPreviousBlock(editor.modules.caret.inputIndex);\n\t            } else {\n\t\n\t                /** If we try to delete first block */\n\t                editor.modules.caret.setToNextBlock(editor.modules.caret.inputIndex);\n\t            }\n\t        }\n\t\n\t        editor.modules.toolbar.move();\n\t\n\t        if (!editor.modules.toolbar.opened) {\n\t\n\t            editor.modules.toolbar.open();\n\t        }\n\t\n\t        /** Updating inputs state */\n\t        editor.modules.ui.saveInputs();\n\t\n\t        /** Prevent default browser behaviour */\n\t        event.preventDefault();\n\t    };\n\t\n\t    /**\n\t     * used by UI module\n\t     * Clicks on block settings button\n\t     *\n\t     * @param {Object} event\n\t     * @protected\n\t     * @description Opens toolbar settings\n\t     */\n\t    callbacks.showSettingsButtonClicked = function (event) {\n\t\n\t        /**\n\t         * Get type of current block\n\t         * It uses to append settings from tool.settings property.\n\t         * ...\n\t         * Type is stored in data-type attribute on block\n\t         */\n\t        var currentTool = editor.modules.content.currentNode.childNodes[0].childNodes[0].tool;\n\t\n\t        editor.modules.toolbar.settings.toggle(currentTool);\n\t\n\t        /** Close toolbox when settings button is active */\n\t        editor.modules.toolbar.toolbox.close();\n\t        editor.modules.toolbar.settings.hideRemoveActions();\n\t    };\n\t\n\t    return callbacks;\n\t};\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor Draw module\n\t *\n\t * @author Codex Team\n\t * @version 1.0.\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var draw = {};\n\t\n\t    /**\n\t     * Base editor wrapper\n\t     */\n\t    draw.wrapper = function () {\n\t\n\t        var wrapper = document.createElement('div');\n\t\n\t        wrapper.className += 'codex-editor';\n\t\n\t        return wrapper;\n\t    };\n\t\n\t    /**\n\t     * Content-editable holder\n\t     */\n\t    draw.redactor = function () {\n\t\n\t        var redactor = document.createElement('div');\n\t\n\t        redactor.className += 'ce-redactor';\n\t\n\t        return redactor;\n\t    };\n\t\n\t    draw.ceBlock = function () {\n\t\n\t        var block = document.createElement('DIV');\n\t\n\t        block.className += 'ce_block';\n\t\n\t        return block;\n\t    };\n\t\n\t    /**\n\t     * Empty toolbar with toggler\n\t     */\n\t    draw.toolbar = function () {\n\t\n\t        var bar = document.createElement('div');\n\t\n\t        bar.className += 'ce-toolbar';\n\t\n\t        return bar;\n\t    };\n\t\n\t    draw.toolbarContent = function () {\n\t\n\t        var wrapper = document.createElement('DIV');\n\t\n\t        wrapper.classList.add('ce-toolbar__content');\n\t\n\t        return wrapper;\n\t    };\n\t\n\t    /**\n\t     * Inline toolbar\n\t     */\n\t    draw.inlineToolbar = function () {\n\t\n\t        var bar = document.createElement('DIV');\n\t\n\t        bar.className += 'ce-toolbar-inline';\n\t\n\t        return bar;\n\t    };\n\t\n\t    /**\n\t     * Wrapper for inline toobar buttons\n\t     */\n\t    draw.inlineToolbarButtons = function () {\n\t\n\t        var wrapper = document.createElement('DIV');\n\t\n\t        wrapper.className += 'ce-toolbar-inline__buttons';\n\t\n\t        return wrapper;\n\t    };\n\t\n\t    /**\n\t     * For some actions\n\t     */\n\t    draw.inlineToolbarActions = function () {\n\t\n\t        var wrapper = document.createElement('DIV');\n\t\n\t        wrapper.className += 'ce-toolbar-inline__actions';\n\t\n\t        return wrapper;\n\t    };\n\t\n\t    draw.inputForLink = function () {\n\t\n\t        var input = document.createElement('INPUT');\n\t\n\t        input.type = 'input';\n\t        input.className += 'inputForLink';\n\t        input.placeholder = 'Вставьте ссылку ...';\n\t        input.setAttribute('form', 'defaultForm');\n\t\n\t        input.setAttribute('autofocus', 'autofocus');\n\t\n\t        return input;\n\t    };\n\t\n\t    /**\n\t     * @todo Desc\n\t     */\n\t    draw.blockButtons = function () {\n\t\n\t        var block = document.createElement('div');\n\t\n\t        block.className += 'ce-toolbar__actions';\n\t\n\t        return block;\n\t    };\n\t\n\t    /**\n\t     * Block settings panel\n\t     */\n\t    draw.blockSettings = function () {\n\t\n\t        var settings = document.createElement('div');\n\t\n\t        settings.className += 'ce-settings';\n\t\n\t        return settings;\n\t    };\n\t\n\t    draw.defaultSettings = function () {\n\t\n\t        var div = document.createElement('div');\n\t\n\t        div.classList.add('ce-settings_default');\n\t\n\t        return div;\n\t    };\n\t\n\t    draw.pluginsSettings = function () {\n\t\n\t        var div = document.createElement('div');\n\t\n\t        div.classList.add('ce-settings_plugin');\n\t\n\t        return div;\n\t    };\n\t\n\t    draw.plusButton = function () {\n\t\n\t        var button = document.createElement('span');\n\t\n\t        button.className = 'ce-toolbar__plus';\n\t        // button.innerHTML = '<i class=\"ce-icon-plus\"></i>';\n\t\n\t        return button;\n\t    };\n\t\n\t    /**\n\t     * Settings button in toolbar\n\t     */\n\t    draw.settingsButton = function () {\n\t\n\t        var toggler = document.createElement('span');\n\t\n\t        toggler.className = 'ce-toolbar__settings-btn';\n\t\n\t        /** Toggler button*/\n\t        toggler.innerHTML = '<i class=\"ce-icon-cog\"></i>';\n\t\n\t        return toggler;\n\t    };\n\t\n\t    /**\n\t     * Redactor tools wrapper\n\t     */\n\t\n\t    draw.toolbox = function () {\n\t\n\t        var wrapper = document.createElement('div');\n\t\n\t        wrapper.className = 'ce-toolbar__tools';\n\t\n\t        return wrapper;\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Draws tool buttons for toolbox\n\t     *\n\t     * @param {String} type\n\t     * @param {String} classname\n\t     * @returns {Element}\n\t     */\n\t    draw.toolbarButton = function (type, classname) {\n\t\n\t        var button = document.createElement('li'),\n\t            toolIcon = document.createElement('i'),\n\t            toolTitle = document.createElement('span');\n\t\n\t        button.dataset.type = type;\n\t        button.setAttribute('title', type);\n\t\n\t        toolIcon.classList.add(classname);\n\t        toolTitle.classList.add('ce_toolbar_tools--title');\n\t\n\t        button.appendChild(toolIcon);\n\t        button.appendChild(toolTitle);\n\t\n\t        return button;\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Draws tools for inline toolbar\n\t     *\n\t     * @param {String} type\n\t     * @param {String} classname\n\t     */\n\t    draw.toolbarButtonInline = function (type, classname) {\n\t\n\t        var button = document.createElement('BUTTON'),\n\t            toolIcon = document.createElement('I');\n\t\n\t        button.type = 'button';\n\t        button.dataset.type = type;\n\t        toolIcon.classList.add(classname);\n\t\n\t        button.appendChild(toolIcon);\n\t\n\t        return button;\n\t    };\n\t\n\t    /**\n\t     * Redactor block\n\t     */\n\t    draw.block = function (tagName, content) {\n\t\n\t        var node = document.createElement(tagName);\n\t\n\t        node.innerHTML = content || '';\n\t\n\t        return node;\n\t    };\n\t\n\t    /**\n\t     * Creates Node with passed tagName and className\n\t     * @param {string}  tagName\n\t     * @param {string} className\n\t     * @param {object} properties - allow to assign properties\n\t     */\n\t    draw.node = function (tagName, className, properties) {\n\t\n\t        var el = document.createElement(tagName);\n\t\n\t        if (className) el.className = className;\n\t\n\t        if (properties) {\n\t\n\t            for (var name in properties) {\n\t\n\t                el[name] = properties[name];\n\t            }\n\t        }\n\t\n\t        return el;\n\t    };\n\t\n\t    /**\n\t    * Unavailable plugin block\n\t    */\n\t    draw.unavailableBlock = function () {\n\t\n\t        var wrapper = document.createElement('DIV');\n\t\n\t        wrapper.classList.add('cdx-unavailable-block');\n\t\n\t        return wrapper;\n\t    };\n\t\n\t    return draw;\n\t};\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor Caret Module\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var caret = {};\n\t\n\t    var editor = this;\n\t\n\t    /**\n\t     * @var {int} InputIndex - editable element in DOM\n\t     */\n\t    caret.inputIndex = null;\n\t\n\t    /**\n\t     * @var {int} offset - caret position in a text node.\n\t     */\n\t    caret.offset = null;\n\t\n\t    /**\n\t     * @var {int} focusedNodeIndex - we get index of child node from first-level block\n\t     */\n\t    caret.focusedNodeIndex = null;\n\t\n\t    /**\n\t     * Creates Document Range and sets caret to the element.\n\t     * @protected\n\t     * @uses caret.save — if you need to save caret position\n\t     * @param {Element} el - Changed Node.\n\t     */\n\t    caret.set = function (el, index, offset) {\n\t\n\t        offset = offset || caret.offset || 0;\n\t        index = index || caret.focusedNodeIndex || 0;\n\t\n\t        var childs = el.childNodes,\n\t            nodeToSet;\n\t\n\t        if (childs.length === 0) {\n\t\n\t            nodeToSet = el;\n\t        } else {\n\t\n\t            nodeToSet = childs[index];\n\t        }\n\t\n\t        /** If Element is INPUT */\n\t        if (el.contentEditable != 'true') {\n\t\n\t            el.focus();\n\t            return;\n\t        }\n\t\n\t        if (editor.modules.core.isDomNode(nodeToSet)) {\n\t\n\t            nodeToSet = editor.modules.content.getDeepestTextNodeFromPosition(nodeToSet, nodeToSet.childNodes.length);\n\t        }\n\t\n\t        var range = document.createRange(),\n\t            selection = window.getSelection();\n\t\n\t        window.setTimeout(function () {\n\t\n\t            range.setStart(nodeToSet, offset);\n\t            range.setEnd(nodeToSet, offset);\n\t\n\t            selection.removeAllRanges();\n\t            selection.addRange(range);\n\t\n\t            editor.modules.caret.saveCurrentInputIndex();\n\t        }, 20);\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     * Updates index of input and saves it in caret object\n\t     */\n\t    caret.saveCurrentInputIndex = function () {\n\t\n\t        /** Index of Input that we paste sanitized content */\n\t        var selection = window.getSelection(),\n\t            inputs = editor.state.inputs,\n\t            focusedNode = selection.anchorNode,\n\t            focusedNodeHolder;\n\t\n\t        if (!focusedNode) {\n\t\n\t            return;\n\t        }\n\t\n\t        /** Looking for parent contentEditable block */\n\t        while (focusedNode.contentEditable != 'true') {\n\t\n\t            focusedNodeHolder = focusedNode.parentNode;\n\t            focusedNode = focusedNodeHolder;\n\t        }\n\t\n\t        /** Input index in DOM level */\n\t        var editableElementIndex = 0;\n\t\n\t        while (focusedNode != inputs[editableElementIndex]) {\n\t\n\t            editableElementIndex++;\n\t        }\n\t\n\t        caret.inputIndex = editableElementIndex;\n\t    };\n\t\n\t    /**\n\t     * Returns current input index (caret object)\n\t     */\n\t    caret.getCurrentInputIndex = function () {\n\t\n\t        return caret.inputIndex;\n\t    };\n\t\n\t    /**\n\t     * @param {int} index - index of first-level block after that we set caret into next input\n\t     */\n\t    caret.setToNextBlock = function (index) {\n\t\n\t        var inputs = editor.state.inputs,\n\t            nextInput = inputs[index + 1];\n\t\n\t        if (!nextInput) {\n\t\n\t            editor.modules.core.log('We are reached the end');\n\t            return;\n\t        }\n\t\n\t        /**\n\t         * When new Block created or deleted content of input\n\t         * We should add some text node to set caret\n\t         */\n\t        if (!nextInput.childNodes.length) {\n\t\n\t            var emptyTextElement = document.createTextNode('');\n\t\n\t            nextInput.appendChild(emptyTextElement);\n\t        }\n\t\n\t        editor.modules.caret.inputIndex = index + 1;\n\t        editor.modules.caret.set(nextInput, 0, 0);\n\t        editor.modules.content.workingNodeChanged(nextInput);\n\t    };\n\t\n\t    /**\n\t     * @param {int} index - index of target input.\n\t     * Sets caret to input with this index\n\t     */\n\t    caret.setToBlock = function (index) {\n\t\n\t        var inputs = editor.state.inputs,\n\t            targetInput = inputs[index];\n\t\n\t        if (!targetInput) {\n\t\n\t            return;\n\t        }\n\t\n\t        /**\n\t         * When new Block created or deleted content of input\n\t         * We should add some text node to set caret\n\t         */\n\t        if (!targetInput.childNodes.length) {\n\t\n\t            var emptyTextElement = document.createTextNode('');\n\t\n\t            targetInput.appendChild(emptyTextElement);\n\t        }\n\t\n\t        editor.modules.caret.inputIndex = index;\n\t        editor.modules.caret.set(targetInput, 0, 0);\n\t        editor.modules.content.workingNodeChanged(targetInput);\n\t    };\n\t\n\t    /**\n\t     * @param {int} index - index of input\n\t     */\n\t    caret.setToPreviousBlock = function (index) {\n\t\n\t        index = index || 0;\n\t\n\t        var inputs = editor.state.inputs,\n\t            previousInput = inputs[index - 1],\n\t            lastChildNode,\n\t            lengthOfLastChildNode,\n\t            emptyTextElement;\n\t\n\t        if (!previousInput) {\n\t\n\t            editor.modules.core.log('We are reached first node');\n\t            return;\n\t        }\n\t\n\t        lastChildNode = editor.modules.content.getDeepestTextNodeFromPosition(previousInput, previousInput.childNodes.length);\n\t        lengthOfLastChildNode = lastChildNode.length;\n\t\n\t        /**\n\t         * When new Block created or deleted content of input\n\t         * We should add some text node to set caret\n\t         */\n\t        if (!previousInput.childNodes.length) {\n\t\n\t            emptyTextElement = document.createTextNode('');\n\t            previousInput.appendChild(emptyTextElement);\n\t        }\n\t        editor.modules.caret.inputIndex = index - 1;\n\t        editor.modules.caret.set(previousInput, previousInput.childNodes.length - 1, lengthOfLastChildNode);\n\t        editor.modules.content.workingNodeChanged(inputs[index - 1]);\n\t    };\n\t\n\t    caret.position = {\n\t\n\t        atStart: function atStart() {\n\t\n\t            var selection = window.getSelection(),\n\t                anchorOffset = selection.anchorOffset,\n\t                anchorNode = selection.anchorNode,\n\t                firstLevelBlock = editor.modules.content.getFirstLevelBlock(anchorNode),\n\t                pluginsRender = firstLevelBlock.childNodes[0];\n\t\n\t            if (!editor.modules.core.isDomNode(anchorNode)) {\n\t\n\t                anchorNode = anchorNode.parentNode;\n\t            }\n\t\n\t            var isFirstNode = anchorNode === pluginsRender.childNodes[0],\n\t                isOffsetZero = anchorOffset === 0;\n\t\n\t            return isFirstNode && isOffsetZero;\n\t        },\n\t\n\t        atTheEnd: function atTheEnd() {\n\t\n\t            var selection = window.getSelection(),\n\t                anchorOffset = selection.anchorOffset,\n\t                anchorNode = selection.anchorNode;\n\t\n\t            /** Caret is at the end of input */\n\t            return !anchorNode || !anchorNode.length || anchorOffset === anchorNode.length;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Inserts node at the caret location\n\t     * @param {HTMLElement|DocumentFragment} node\n\t     */\n\t    caret.insertNode = function (node) {\n\t\n\t        var selection,\n\t            range,\n\t            lastNode = node;\n\t\n\t        if (node.nodeType == editor.modules.core.nodeTypes.DOCUMENT_FRAGMENT) {\n\t\n\t            lastNode = node.lastChild;\n\t        }\n\t\n\t        selection = window.getSelection();\n\t\n\t        range = selection.getRangeAt(0);\n\t        range.deleteContents();\n\t\n\t        range.insertNode(node);\n\t\n\t        range.setStartAfter(lastNode);\n\t        range.collapse(true);\n\t\n\t        selection.removeAllRanges();\n\t        selection.addRange(range);\n\t    };\n\t\n\t    return caret;\n\t};\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor Notification Module\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var notifications = {};\n\t\n\t    var editor = this;\n\t\n\t    var queue = [];\n\t\n\t    var addToQueue = function addToQueue(settings) {\n\t\n\t        queue.push(settings);\n\t\n\t        var index = 0;\n\t\n\t        while (index < queue.length && queue.length > 5) {\n\t\n\t            if (queue[index].type == 'confirm' || queue[index].type == 'prompt') {\n\t\n\t                index++;\n\t                continue;\n\t            }\n\t\n\t            queue[index].close();\n\t            queue.splice(index, 1);\n\t        }\n\t    };\n\t\n\t    notifications.createHolder = function () {\n\t\n\t        var holder = editor.modules.draw.node('DIV', 'cdx-notifications-block');\n\t\n\t        editor.nodes.notifications = document.body.appendChild(holder);\n\t\n\t        return holder;\n\t    };\n\t\n\t    /**\n\t     * Error notificator. Shows block with message\n\t     * @protected\n\t     */\n\t    notifications.errorThrown = function (errorMsg, event) {\n\t\n\t        editor.modules.notifications.notification({ message: 'This action is not available currently', type: event.type });\n\t    };\n\t\n\t    /**\n\t     *\n\t     * Appends notification\n\t     *\n\t     *  settings = {\n\t     *      type        - notification type (reserved types: alert, confirm, prompt). Just add class 'cdx-notification-'+type\n\t     *      message     - notification message\n\t     *      okMsg       - confirm button text (default - 'Ok')\n\t     *      cancelBtn   - cancel button text (default - 'Cancel'). Only for confirm and prompt types\n\t     *      confirm     - function-handler for ok button click\n\t     *      cancel      - function-handler for cancel button click. Only for confirm and prompt types\n\t     *      time        - time (in seconds) after which notification will close (default - 10s)\n\t     *  }\n\t     *\n\t     * @param settings\n\t     */\n\t    notifications.notification = function (constructorSettings) {\n\t\n\t        /** Private vars and methods */\n\t        var notification = null,\n\t            cancel = null,\n\t            type = null,\n\t            confirm = null,\n\t            inputField = null;\n\t\n\t        var confirmHandler = function confirmHandler() {\n\t\n\t            close();\n\t\n\t            if (typeof confirm !== 'function') {\n\t\n\t                return;\n\t            }\n\t\n\t            if (type == 'prompt') {\n\t\n\t                confirm(inputField.value);\n\t                return;\n\t            }\n\t\n\t            confirm();\n\t        };\n\t\n\t        var cancelHandler = function cancelHandler() {\n\t\n\t            close();\n\t\n\t            if (typeof cancel !== 'function') {\n\t\n\t                return;\n\t            }\n\t\n\t            cancel();\n\t        };\n\t\n\t        /** Public methods */\n\t        function create(settings) {\n\t\n\t            if (!(settings && settings.message)) {\n\t\n\t                editor.modules.core.log('Can\\'t create notification. Message is missed');\n\t                return;\n\t            }\n\t\n\t            settings.type = settings.type || 'alert';\n\t            settings.time = settings.time * 1000 || 10000;\n\t\n\t            var wrapper = editor.modules.draw.node('DIV', 'cdx-notification'),\n\t                message = editor.modules.draw.node('DIV', 'cdx-notification__message'),\n\t                input = editor.modules.draw.node('INPUT', 'cdx-notification__input'),\n\t                okBtn = editor.modules.draw.node('SPAN', 'cdx-notification__ok-btn'),\n\t                cancelBtn = editor.modules.draw.node('SPAN', 'cdx-notification__cancel-btn');\n\t\n\t            message.textContent = settings.message;\n\t            okBtn.textContent = settings.okMsg || 'ОК';\n\t            cancelBtn.textContent = settings.cancelMsg || 'Отмена';\n\t\n\t            editor.modules.listeners.add(okBtn, 'click', confirmHandler);\n\t            editor.modules.listeners.add(cancelBtn, 'click', cancelHandler);\n\t\n\t            wrapper.appendChild(message);\n\t\n\t            if (settings.type == 'prompt') {\n\t\n\t                wrapper.appendChild(input);\n\t            }\n\t\n\t            wrapper.appendChild(okBtn);\n\t\n\t            if (settings.type == 'prompt' || settings.type == 'confirm') {\n\t\n\t                wrapper.appendChild(cancelBtn);\n\t            }\n\t\n\t            wrapper.classList.add('cdx-notification-' + settings.type);\n\t            wrapper.dataset.type = settings.type;\n\t\n\t            notification = wrapper;\n\t            type = settings.type;\n\t            confirm = settings.confirm;\n\t            cancel = settings.cancel;\n\t            inputField = input;\n\t\n\t            if (settings.type != 'prompt' && settings.type != 'confirm') {\n\t\n\t                window.setTimeout(close, settings.time);\n\t            }\n\t        };\n\t\n\t        function send() {\n\t\n\t            editor.nodes.notifications.appendChild(notification);\n\t            inputField.focus();\n\t\n\t            editor.nodes.notifications.classList.add('cdx-notification__notification-appending');\n\t\n\t            window.setTimeout(function () {\n\t\n\t                editor.nodes.notifications.classList.remove('cdx-notification__notification-appending');\n\t            }, 100);\n\t\n\t            addToQueue({ type: type, close: close });\n\t        };\n\t\n\t        function close() {\n\t\n\t            notification.remove();\n\t        };\n\t\n\t        if (constructorSettings) {\n\t\n\t            create(constructorSettings);\n\t            send();\n\t        }\n\t\n\t        return {\n\t            create: create,\n\t            send: send,\n\t            close: close\n\t        };\n\t    };\n\t\n\t    notifications.clear = function () {\n\t\n\t        editor.nodes.notifications.innerHTML = '';\n\t        queue = [];\n\t    };\n\t\n\t    return notifications;\n\t};\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * Codex Editor Parser Module\n\t *\n\t * @author Codex Team\n\t * @version 1.1\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var parser = {};\n\t\n\t    var editor = this;\n\t\n\t    /** inserting text */\n\t    parser.insertPastedContent = function (blockType, tag) {\n\t\n\t        editor.modules.content.insertBlock({\n\t            type: blockType.type,\n\t            block: blockType.render({\n\t                text: tag.innerHTML\n\t            })\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Check DOM node for display style: separated block or child-view\n\t     */\n\t    parser.isFirstLevelBlock = function (node) {\n\t\n\t        return node.nodeType == editor.modules.core.nodeTypes.TAG && node.classList.contains(editor.modules.ui.className.BLOCK_CLASSNAME);\n\t    };\n\t\n\t    return parser;\n\t};\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Sanitizer\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var sanitizer = {};\n\t\n\t    /** HTML Janitor library */\n\t    var janitor = __webpack_require__(18);\n\t\n\t    /** Codex Editor */\n\t    var editor = this;\n\t\n\t    sanitizer.prepare = function () {\n\t\n\t        if (editor.settings.sanitizer && !editor.modules.core.isEmpty(editor.settings.sanitizer)) {\n\t\n\t            Config.CUSTOM = editor.settings.sanitizer;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Basic config\n\t     */\n\t    var Config = {\n\t\n\t        /** User configuration */\n\t        CUSTOM: null,\n\t\n\t        BASIC: {\n\t\n\t            tags: {\n\t                p: {},\n\t                a: {\n\t                    href: true,\n\t                    target: '_blank',\n\t                    rel: 'nofollow'\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    sanitizer.Config = Config;\n\t\n\t    /**\n\t     *\n\t     * @param userCustomConfig\n\t     * @returns {*}\n\t     * @private\n\t     *\n\t     * @description If developer uses editor's API, then he can customize sane restrictions.\n\t     * Or, sane config can be defined globally in editors initialization. That config will be used everywhere\n\t     * At least, if there is no config overrides, that API uses BASIC Default configation\n\t     */\n\t    var init_ = function init_(userCustomConfig) {\n\t\n\t        var configuration = userCustomConfig || Config.CUSTOM || Config.BASIC;\n\t\n\t        return new janitor(configuration);\n\t    };\n\t\n\t    /**\n\t     * Cleans string from unwanted tags\n\t     * @protected\n\t     * @param {String} dirtyString - taint string\n\t     * @param {Object} customConfig - allowed tags\n\t     */\n\t    sanitizer.clean = function (dirtyString, customConfig) {\n\t\n\t        var janitorInstance = init_(customConfig);\n\t\n\t        return janitorInstance.clean(dirtyString);\n\t    };\n\t\n\t    return sanitizer;\n\t};\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports === 'object') {\n\t    module.exports = factory();\n\t  } else {\n\t    root.HTMLJanitor = factory();\n\t  }\n\t}(this, function () {\n\t\n\t  /**\n\t   * @param {Object} config.tags Dictionary of allowed tags.\n\t   * @param {boolean} config.keepNestedBlockElements Default false.\n\t   */\n\t  function HTMLJanitor(config) {\n\t\n\t    var tagDefinitions = config['tags'];\n\t    var tags = Object.keys(tagDefinitions);\n\t\n\t    var validConfigValues = tags\n\t      .map(function(k) { return typeof tagDefinitions[k]; })\n\t      .every(function(type) { return type === 'object' || type === 'boolean' || type === 'function'; });\n\t\n\t    if(!validConfigValues) {\n\t      throw new Error(\"The configuration was invalid\");\n\t    }\n\t\n\t    this.config = config;\n\t  }\n\t\n\t  // TODO: not exhaustive?\n\t  var blockElementNames = ['P', 'LI', 'TD', 'TH', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'PRE'];\n\t  function isBlockElement(node) {\n\t    return blockElementNames.indexOf(node.nodeName) !== -1;\n\t  }\n\t\n\t  var inlineElementNames = ['A', 'B', 'STRONG', 'I', 'EM', 'SUB', 'SUP', 'U', 'STRIKE'];\n\t  function isInlineElement(node) {\n\t    return inlineElementNames.indexOf(node.nodeName) !== -1;\n\t  }\n\t\n\t  HTMLJanitor.prototype.clean = function (html) {\n\t    var sandbox = document.createElement('div');\n\t    sandbox.innerHTML = html;\n\t\n\t    this._sanitize(sandbox);\n\t\n\t    return sandbox.innerHTML;\n\t  };\n\t\n\t  HTMLJanitor.prototype._sanitize = function (parentNode) {\n\t    var treeWalker = createTreeWalker(parentNode);\n\t    var node = treeWalker.firstChild();\n\t    if (!node) { return; }\n\t\n\t    do {\n\t      // Ignore nodes that have already been sanitized\n\t      if (node._sanitized) {\n\t        continue;\n\t      }\n\t\n\t      if (node.nodeType === Node.TEXT_NODE) {\n\t        // If this text node is just whitespace and the previous or next element\n\t        // sibling is a block element, remove it\n\t        // N.B.: This heuristic could change. Very specific to a bug with\n\t        // `contenteditable` in Firefox: http://jsbin.com/EyuKase/1/edit?js,output\n\t        // FIXME: make this an option?\n\t        if (node.data.trim() === ''\n\t            && ((node.previousElementSibling && isBlockElement(node.previousElementSibling))\n\t                 || (node.nextElementSibling && isBlockElement(node.nextElementSibling)))) {\n\t          parentNode.removeChild(node);\n\t          this._sanitize(parentNode);\n\t          break;\n\t        } else {\n\t          continue;\n\t        }\n\t      }\n\t\n\t      // Remove all comments\n\t      if (node.nodeType === Node.COMMENT_NODE) {\n\t        parentNode.removeChild(node);\n\t        this._sanitize(parentNode);\n\t        break;\n\t      }\n\t\n\t      var isInline = isInlineElement(node);\n\t      var containsBlockElement;\n\t      if (isInline) {\n\t        containsBlockElement = Array.prototype.some.call(node.childNodes, isBlockElement);\n\t      }\n\t\n\t      // Block elements should not be nested (e.g. <li><p>...); if\n\t      // they are, we want to unwrap the inner block element.\n\t      var isNotTopContainer = !! parentNode.parentNode;\n\t      var isNestedBlockElement =\n\t            isBlockElement(parentNode) &&\n\t            isBlockElement(node) &&\n\t            isNotTopContainer;\n\t\n\t      var nodeName = node.nodeName.toLowerCase();\n\t\n\t      var allowedAttrs = getAllowedAttrs(this.config, nodeName, node);\n\t\n\t      var isInvalid = isInline && containsBlockElement;\n\t\n\t      // Drop tag entirely according to the whitelist *and* if the markup\n\t      // is invalid.\n\t      if (isInvalid || shouldRejectNode(node, allowedAttrs)\n\t          || (!this.config.keepNestedBlockElements && isNestedBlockElement)) {\n\t        // Do not keep the inner text of SCRIPT/STYLE elements.\n\t        if (! (node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE')) {\n\t          while (node.childNodes.length > 0) {\n\t            parentNode.insertBefore(node.childNodes[0], node);\n\t          }\n\t        }\n\t        parentNode.removeChild(node);\n\t\n\t        this._sanitize(parentNode);\n\t        break;\n\t      }\n\t\n\t      // Sanitize attributes\n\t      for (var a = 0; a < node.attributes.length; a += 1) {\n\t        var attr = node.attributes[a];\n\t\n\t        if (shouldRejectAttr(attr, allowedAttrs, node)) {\n\t          node.removeAttribute(attr.name);\n\t          // Shift the array to continue looping.\n\t          a = a - 1;\n\t        }\n\t      }\n\t\n\t      // Sanitize children\n\t      this._sanitize(node);\n\t\n\t      // Mark node as sanitized so it's ignored in future runs\n\t      node._sanitized = true;\n\t    } while ((node = treeWalker.nextSibling()));\n\t  };\n\t\n\t  function createTreeWalker(node) {\n\t    return document.createTreeWalker(node,\n\t                                     NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,\n\t                                     null, false);\n\t  }\n\t\n\t  function getAllowedAttrs(config, nodeName, node){\n\t    if (typeof config.tags[nodeName] === 'function') {\n\t      return config.tags[nodeName](node);\n\t    } else {\n\t      return config.tags[nodeName];\n\t    }\n\t  }\n\t\n\t  function shouldRejectNode(node, allowedAttrs){\n\t    if (typeof allowedAttrs === 'undefined') {\n\t      return true;\n\t    } else if (typeof allowedAttrs === 'boolean') {\n\t      return !allowedAttrs;\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  function shouldRejectAttr(attr, allowedAttrs, node){\n\t    var attrName = attr.name.toLowerCase();\n\t\n\t    if (allowedAttrs === true){\n\t      return false;\n\t    } else if (typeof allowedAttrs[attrName] === 'function'){\n\t      return !allowedAttrs[attrName](attr.value, node);\n\t    } else if (typeof allowedAttrs[attrName] === 'undefined'){\n\t      return true;\n\t    } else if (allowedAttrs[attrName] === false) {\n\t      return true;\n\t    } else if (typeof allowedAttrs[attrName] === 'string') {\n\t      return (allowedAttrs[attrName] !== attr.value);\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  return HTMLJanitor;\n\t\n\t}));\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * Codex Editor Listeners module\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\t\n\t/**\n\t * Module-decorator for event listeners assignment\n\t */\n\tmodule.exports = function () {\n\t\n\t    var listeners = {};\n\t\n\t    var allListeners = [];\n\t\n\t    /**\n\t     * Search methods\n\t     *\n\t     * byElement, byType and byHandler returns array of suitable listeners\n\t     * one and all takes element, eventType, and handler and returns first (all) suitable listener\n\t     *\n\t     */\n\t    listeners.search = function () {\n\t\n\t        var byElement = function byElement(element, context) {\n\t\n\t            var listenersOnElement = [];\n\t\n\t            context = context || allListeners;\n\t\n\t            for (var i = 0; i < context.length; i++) {\n\t\n\t                var listener = context[i];\n\t\n\t                if (listener.element === element) {\n\t\n\t                    listenersOnElement.push(listener);\n\t                }\n\t            }\n\t\n\t            return listenersOnElement;\n\t        };\n\t\n\t        var byType = function byType(eventType, context) {\n\t\n\t            var listenersWithType = [];\n\t\n\t            context = context || allListeners;\n\t\n\t            for (var i = 0; i < context.length; i++) {\n\t\n\t                var listener = context[i];\n\t\n\t                if (listener.type === eventType) {\n\t\n\t                    listenersWithType.push(listener);\n\t                }\n\t            }\n\t\n\t            return listenersWithType;\n\t        };\n\t\n\t        var byHandler = function byHandler(handler, context) {\n\t\n\t            var listenersWithHandler = [];\n\t\n\t            context = context || allListeners;\n\t\n\t            for (var i = 0; i < context.length; i++) {\n\t\n\t                var listener = context[i];\n\t\n\t                if (listener.handler === handler) {\n\t\n\t                    listenersWithHandler.push(listener);\n\t                }\n\t            }\n\t\n\t            return listenersWithHandler;\n\t        };\n\t\n\t        var one = function one(element, eventType, handler) {\n\t\n\t            var result = allListeners;\n\t\n\t            if (element) result = byElement(element, result);\n\t\n\t            if (eventType) result = byType(eventType, result);\n\t\n\t            if (handler) result = byHandler(handler, result);\n\t\n\t            return result[0];\n\t        };\n\t\n\t        var all = function all(element, eventType, handler) {\n\t\n\t            var result = allListeners;\n\t\n\t            if (element) result = byElement(element, result);\n\t\n\t            if (eventType) result = byType(eventType, result);\n\t\n\t            if (handler) result = byHandler(handler, result);\n\t\n\t            return result;\n\t        };\n\t\n\t        return {\n\t            byElement: byElement,\n\t            byType: byType,\n\t            byHandler: byHandler,\n\t            one: one,\n\t            all: all\n\t        };\n\t    }();\n\t\n\t    listeners.add = function (element, eventType, handler, isCapture) {\n\t\n\t        element.addEventListener(eventType, handler, isCapture);\n\t\n\t        var data = {\n\t            element: element,\n\t            type: eventType,\n\t            handler: handler\n\t        };\n\t\n\t        var alreadyAddedListener = listeners.search.one(element, eventType, handler);\n\t\n\t        if (!alreadyAddedListener) {\n\t\n\t            allListeners.push(data);\n\t        }\n\t    };\n\t\n\t    listeners.remove = function (element, eventType, handler) {\n\t\n\t        element.removeEventListener(eventType, handler);\n\t\n\t        var existingListeners = listeners.search.all(element, eventType, handler);\n\t\n\t        for (var i = 0; i < existingListeners.length; i++) {\n\t\n\t            var index = allListeners.indexOf(existingListeners[i]);\n\t\n\t            if (index > 0) {\n\t\n\t                allListeners.splice(index, 1);\n\t            }\n\t        }\n\t    };\n\t\n\t    listeners.removeAll = function () {\n\t\n\t        allListeners.map(function (current) {\n\t\n\t            listeners.remove(current.element, current.type, current.handler);\n\t        });\n\t    };\n\t\n\t    listeners.get = function (element, eventType, handler) {\n\t\n\t        return listeners.search.all(element, eventType, handler);\n\t    };\n\t\n\t    return listeners;\n\t};\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/**\n\t * Codex Editor Destroyer module\n\t *\n\t * @auhor Codex Team\n\t * @version 1.0\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var destroyer = {};\n\t\n\t    var editor = this;\n\t\n\t    destroyer.removeNodes = function () {\n\t\n\t        editor.nodes.wrapper.remove();\n\t        editor.nodes.notifications.remove();\n\t    };\n\t\n\t    destroyer.destroyPlugins = function () {\n\t\n\t        for (var tool in editor.tools) {\n\t\n\t            if (typeof editor.tools[tool].destroy === 'function') {\n\t\n\t                editor.tools[tool].destroy();\n\t            }\n\t        }\n\t    };\n\t\n\t    destroyer.destroyScripts = function () {\n\t\n\t        var scripts = document.getElementsByTagName('SCRIPT');\n\t\n\t        for (var i = 0; i < scripts.length; i++) {\n\t\n\t            if (scripts[i].id.indexOf(editor.scriptPrefix) + 1) {\n\t\n\t                scripts[i].remove();\n\t                i--;\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Delete editor data from webpage.\n\t     * You should send settings argument with boolean flags:\n\t     * @param settings.ui- remove redactor event listeners and DOM nodes\n\t     * @param settings.scripts - remove redactor scripts from DOM\n\t     * @param settings.plugins - remove plugin's objects\n\t     * @param settings.core - remove editor core. You can remove core only if UI and scripts flags is true\n\t     * }\n\t     *\n\t     */\n\t    destroyer.destroy = function (settings) {\n\t\n\t        if (!settings || (typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n\t\n\t            return;\n\t        }\n\t\n\t        if (settings.ui) {\n\t\n\t            destroyer.removeNodes();\n\t            editor.modules.listeners.removeAll();\n\t        }\n\t\n\t        if (settings.scripts) {\n\t\n\t            destroyer.destroyScripts();\n\t        }\n\t\n\t        if (settings.plugins) {\n\t\n\t            destroyer.destroyPlugins();\n\t        }\n\t\n\t        if (settings.ui && settings.scripts && settings.core) {\n\t\n\t            editor = null;\n\t        }\n\t    };\n\t\n\t    return destroyer;\n\t};\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor Paste module\n\t *\n\t * @author Codex Team\n\t * @version 1.1.1\n\t */\n\t\n\tmodule.exports = function () {\n\t\n\t    var paste = {};\n\t\n\t    var editor = this;\n\t\n\t    var patterns = [];\n\t\n\t    paste.prepare = function () {\n\t\n\t        var tools = editor.tools;\n\t\n\t        for (var tool in tools) {\n\t\n\t            if (!tools[tool].renderOnPastePatterns || !Array.isArray(tools[tool].renderOnPastePatterns)) {\n\t\n\t                continue;\n\t            }\n\t\n\t            tools[tool].renderOnPastePatterns.map(function (pattern) {\n\t\n\t                patterns.push(pattern);\n\t            });\n\t        }\n\t\n\t        return Promise.resolve();\n\t    };\n\t\n\t    /**\n\t     * Saves data\n\t     * @param event\n\t     */\n\t    paste.pasted = function (event) {\n\t\n\t        var clipBoardData = event.clipboardData || window.clipboardData,\n\t            content = clipBoardData.getData('Text');\n\t\n\t        var result = analize(content);\n\t\n\t        if (result) {\n\t\n\t            event.preventDefault();\n\t            event.stopImmediatePropagation();\n\t        }\n\t\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * Analizes pated string and calls necessary method\n\t     */\n\t\n\t    var analize = function analize(string) {\n\t\n\t        var result = false,\n\t            content = editor.modules.content.currentNode,\n\t            plugin = content.dataset.tool;\n\t\n\t        patterns.map(function (pattern) {\n\t\n\t            var execArray = pattern.regex.exec(string),\n\t                match = execArray && execArray[0];\n\t\n\t            if (match && match === string.trim()) {\n\t\n\t                /** current block is not empty */\n\t                if (content.textContent.trim() && plugin == editor.settings.initialBlockPlugin) {\n\t\n\t                    pasteToNewBlock_();\n\t                }\n\t\n\t                pattern.callback(string, pattern);\n\t                result = true;\n\t            }\n\t        });\n\t\n\t        return result;\n\t    };\n\t\n\t    var pasteToNewBlock_ = function pasteToNewBlock_() {\n\t\n\t        /** Create new initial block */\n\t        editor.modules.content.insertBlock({\n\t\n\t            type: editor.settings.initialBlockPlugin,\n\t            block: editor.tools[editor.settings.initialBlockPlugin].render({\n\t                text: ''\n\t            })\n\t\n\t        }, false);\n\t    };\n\t\n\t    /**\n\t     * This method prevents default behaviour.\n\t     *\n\t     * @param {Object} event\n\t     * @protected\n\t     *\n\t     * @description We get from clipboard pasted data, sanitize, make a fragment that contains of this sanitized nodes.\n\t     * Firstly, we need to memorize the caret position. We can do that by getting the range of selection.\n\t     * After all, we insert clear fragment into caret placed position. Then, we should move the caret to the last node\n\t     */\n\t    paste.blockPasteCallback = function (event) {\n\t\n\t        if (!needsToHandlePasteEvent(event.target)) {\n\t\n\t            return;\n\t        }\n\t\n\t        /** Prevent default behaviour */\n\t        event.preventDefault();\n\t\n\t        /** get html pasted data - dirty data */\n\t        var htmlData = event.clipboardData.getData('text/html'),\n\t            plainData = event.clipboardData.getData('text/plain');\n\t\n\t        /** Temporary DIV that is used to work with text's paragraphs as DOM-elements*/\n\t        var paragraphs = editor.modules.draw.node('DIV', '', {}),\n\t            cleanData,\n\t            wrappedData;\n\t\n\t        /** Create fragment, that we paste to range after proccesing */\n\t        cleanData = editor.modules.sanitizer.clean(htmlData);\n\t\n\t        /**\n\t         * We wrap pasted text with <p> tags to split it logically\n\t         * @type {string}\n\t         */\n\t        wrappedData = editor.modules.content.wrapTextWithParagraphs(cleanData, plainData);\n\t        paragraphs.innerHTML = wrappedData;\n\t\n\t        /**\n\t         * If there only one paragraph, just insert in at the caret location\n\t         */\n\t        if (paragraphs.childNodes.length == 1) {\n\t\n\t            emulateUserAgentBehaviour(paragraphs.firstChild);\n\t            return;\n\t        }\n\t\n\t        insertPastedParagraphs(paragraphs.childNodes);\n\t    };\n\t\n\t    /**\n\t     * Checks if we should handle paste event on block\n\t     * @param block\n\t     *\n\t     * @return {boolean}\n\t     */\n\t    var needsToHandlePasteEvent = function needsToHandlePasteEvent(block) {\n\t\n\t        /** If area is input or textarea then allow default behaviour */\n\t        if (editor.modules.core.isNativeInput(block)) {\n\t\n\t            return false;\n\t        }\n\t\n\t        var editableParent = editor.modules.content.getEditableParent(block);\n\t\n\t        /** Allow paste when event target placed in Editable element */\n\t        if (!editableParent) {\n\t\n\t            return false;\n\t        }\n\t\n\t        return true;\n\t    };\n\t\n\t    /**\n\t     * Inserts new initial plugin blocks with data in paragraphs\n\t     *\n\t     * @param {Array} paragraphs - array of paragraphs (<p></p>) whit content, that should be inserted\n\t     */\n\t    var insertPastedParagraphs = function insertPastedParagraphs(paragraphs) {\n\t\n\t        var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin,\n\t            currentNode = editor.modules.content.currentNode;\n\t\n\t        paragraphs.forEach(function (paragraph) {\n\t\n\t            /** Don't allow empty paragraphs */\n\t            if (editor.modules.core.isBlockEmpty(paragraph)) {\n\t\n\t                return;\n\t            }\n\t\n\t            editor.modules.content.insertBlock({\n\t                type: NEW_BLOCK_TYPE,\n\t                block: editor.tools[NEW_BLOCK_TYPE].render({\n\t                    text: paragraph.innerHTML\n\t                })\n\t            });\n\t\n\t            editor.modules.caret.inputIndex++;\n\t        });\n\t\n\t        editor.modules.caret.setToPreviousBlock(editor.modules.caret.getCurrentInputIndex() + 1);\n\t\n\t        /**\n\t         * If there was no data in working node, remove it\n\t         */\n\t        if (editor.modules.core.isBlockEmpty(currentNode)) {\n\t\n\t            currentNode.remove();\n\t            editor.modules.ui.saveInputs();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Inserts node content at the caret position\n\t     *\n\t     * @param {Node} node - DOM node (could be DocumentFragment), that should be inserted at the caret location\n\t     */\n\t    var emulateUserAgentBehaviour = function emulateUserAgentBehaviour(node) {\n\t\n\t        var newNode;\n\t\n\t        if (node.childElementCount) {\n\t\n\t            newNode = document.createDocumentFragment();\n\t\n\t            node.childNodes.forEach(function (current) {\n\t\n\t                if (!editor.modules.core.isDomNode(current) && current.data.trim() === '') {\n\t\n\t                    return;\n\t                }\n\t\n\t                newNode.appendChild(current.cloneNode(true));\n\t            });\n\t        } else {\n\t\n\t            newNode = document.createTextNode(node.textContent);\n\t        }\n\t\n\t        editor.modules.caret.insertNode(newNode);\n\t    };\n\t\n\t    return paste;\n\t};\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// codex-editor.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 286dd833be57efe302e0","/**\n *\n * Codex Editor\n *\n * @author Codex Team\n */\n\nmodule.exports = (function (userSettings) {\n\n    'use strict';\n\n    let self = this;\n\n    self.version = VERSION;\n    self.scriptPrefix = 'cdx-script-';\n\n\n\n    self.modules = {\n        core: require('./modules/core'),\n        tools: require('./modules/tools'),\n        ui: require('./modules/ui'),\n        transport: require('./modules/transport'),\n        renderer: require('./modules/renderer'),\n        saver: require('./modules/saver'),\n        content: require('./modules/content'),\n        toolbar: require('./modules/toolbar/toolbar'),\n        callback: require('./modules/callbacks'),\n        draw: require('./modules/draw'),\n        caret: require('./modules/caret'),\n        notifications: require('./modules/notifications'),\n        parser: require('./modules/parser'),\n        sanitizer: require('./modules/sanitizer'),\n        listeners: require('./modules/listeners'),\n        destroyer: require('./modules/destroyer'),\n        paste: require('./modules/paste'),\n    };\n\n    for (let module in self.modules) {\n\n        self.modules[module] = self.modules[module].call(self);\n\n    }\n\n\n    /**\n     * @public\n     * holds initial settings\n     */\n    self.settings = {\n        tools     : ['paragraph', 'header', 'picture', 'list', 'quote', 'code', 'twitter', 'instagram', 'smile'],\n        holderId  : 'codex-editor',\n\n        // Type of block showing on empty editor\n        initialBlockPlugin: 'paragraph'\n    };\n\n    /**\n     * public\n     *\n     * Static nodes\n     */\n    self.nodes = {\n        holder            : null,\n        wrapper           : null,\n        toolbar           : null,\n        inlineToolbar     : {\n            wrapper : null,\n            buttons : null,\n            actions : null\n        },\n        toolbox           : null,\n        notifications     : null,\n        plusButton        : null,\n        showSettingsButton: null,\n        showTrashButton   : null,\n        blockSettings     : null,\n        pluginSettings    : null,\n        defaultSettings   : null,\n        toolbarButtons    : {}, // { type : DomEl, ... }\n        redactor          : null\n    };\n\n    /**\n     * @public\n     *\n     * Output state\n     */\n    self.state = {\n        jsonOutput  : [],\n        blocks      : [],\n        inputs      : []\n    };\n\n    /**\n    * @public\n    * Editor plugins\n    */\n    self.tools = {};\n\n    /**\n     * Initialization\n     * @uses Promise cEditor.core.prepare\n     * @param {Object} userSettings\n     * @param {Array}  userSettings.tools       list of plugins\n     * @param {String} userSettings.holderId    Element's id to append editor\n     *\n     * Load user defined tools\n     * Tools must contain this important objects :\n     *  @param {String} type - this is a type of plugin. It can be used as plugin name\n     *  @param {String} iconClassname - this a icon in toolbar\n     *  @param {Object} make - what should plugin do, when it is clicked\n     *  @param {Object} appendCallback - callback after clicking\n     *  @param {Element} settings - what settings does it have\n     *  @param {Object} render - plugin get JSON, and should return HTML\n     *  @param {Object} save - plugin gets HTML content, returns JSON\n     *  @param {Boolean} displayInToolbox - will be displayed in toolbox. Default value is TRUE\n     *  @param {Boolean} enableLineBreaks - inserts new block or break lines. Default value is FALSE\n     *\n     * @example\n     *   -  type             : 'header',\n     *   -  iconClassname    : 'ce-icon-header',\n     *   -  make             : headerTool.make,\n     *   -  appendCallback   : headerTool.appendCallback,\n     *   -  settings         : headerTool.makeSettings(),\n     *   -  render           : headerTool.render,\n     *   -  save             : headerTool.save,\n     *   -  displayInToolbox : true,\n     *   -  enableLineBreaks : false\n     */\n    self.start = function (userSettings_) {\n\n        self.modules.core.prepare(userSettings_)\n\n        // If all ok, make UI, bind events and parse initial-content\n            .then(self.modules.ui.prepare)\n            // .then(self.modules.tools.prepare)\n            .then(self.modules.sanitizer.prepare)\n            .then(self.modules.paste.prepare)\n            .then(self.modules.transport.prepare)\n            .then(self.modules.renderer.makeBlocksFromData)\n            .then(self.modules.ui.saveInputs)\n            .catch(function (error) {\n\n                self.modules.core.log('Initialization failed with error: %o', 'warn', error);\n\n            });\n\n    };\n\n    self.start(userSettings);\n\n    return {save: self.modules.saver.save};\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./codex.js","/**\n * Codex Editor Core\n *\n * @author Codex Team\n * @version 1.1.3\n */\n\nmodule.exports = (function () {\n\n    let core = {};\n\n    let editor = this;\n\n    /**\n     * @public\n     *\n     * Editor preparing method\n     * @return Promise\n     */\n    core.prepare = function (userSettings) {\n\n        return new Promise(function (resolve, reject) {\n\n            if ( userSettings ) {\n\n                editor.settings.tools = userSettings.tools || editor.settings.tools;\n\n            }\n\n            if (userSettings.data) {\n\n                editor.state.blocks = userSettings.data;\n\n            }\n\n            if (userSettings.initialBlockPlugin) {\n\n                editor.settings.initialBlockPlugin = userSettings.initialBlockPlugin;\n\n            }\n\n            if (userSettings.sanitizer) {\n\n                editor.settings.sanitizer = userSettings.sanitizer;\n\n            }\n\n            editor.hideToolbar = userSettings.hideToolbar;\n\n            editor.settings.placeholder = userSettings.placeholder || '';\n\n            editor.nodes.holder = document.getElementById(userSettings.holderId || editor.settings.holderId);\n\n            if (typeof editor.nodes.holder === undefined || editor.nodes.holder === null) {\n\n                reject(Error(\"Holder wasn't found by ID: #\" + userSettings.holderId));\n\n            } else {\n\n                resolve();\n\n            }\n\n        });\n\n    };\n\n    /**\n     * Logging method\n     * @param type = ['log', 'info', 'warn']\n     */\n    core.log = function (msg, type, arg) {\n\n        type = type || 'log';\n\n        if (!arg) {\n\n            arg  = msg || 'undefined';\n            msg  = '[codex-editor]:      %o';\n\n        } else {\n\n            msg  = '[codex-editor]:      ' + msg;\n\n        }\n\n        try{\n\n            if ( 'console' in window && window.console[ type ] ) {\n\n                if ( arg ) window.console[ type ]( msg, arg );\n                else window.console[ type ]( msg );\n\n            }\n\n        }catch(e) {}\n\n    };\n\n    /**\n     * @protected\n     *\n     * Helper for insert one element after another\n     */\n    core.insertAfter = function (target, element) {\n\n        target.parentNode.insertBefore(element, target.nextSibling);\n\n    };\n\n    /**\n     * @const\n     *\n     * Readable DOM-node types map\n     */\n    core.nodeTypes = {\n        TAG     : 1,\n        TEXT    : 3,\n        COMMENT : 8,\n        DOCUMENT_FRAGMENT: 11\n    };\n\n    /**\n     * @const\n     * Readable keys map\n     */\n    core.keys = { BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, ESC: 27, SPACE: 32, LEFT: 37, UP: 38, DOWN: 40, RIGHT: 39, DELETE: 46, META: 91 };\n\n    /**\n     * @protected\n     *\n     * Check object for DOM node\n     */\n    core.isDomNode = function (el) {\n\n        return el && typeof el === 'object' && el.nodeType && el.nodeType == this.nodeTypes.TAG;\n\n    };\n\n    /**\n    * Checks passed object for emptiness\n    * @require ES5 - Object.keys\n    * @param {object}\n    */\n    core.isEmpty = function ( obj ) {\n\n        return Object.keys(obj).length === 0;\n\n    };\n\n    /**\n     * Native Ajax\n     * @param {String}   settings.url         - request URL\n     * @param {function} settings.beforeSend  - returned value will be passed as context to the Success, Error and Progress callbacks\n     * @param {function} settings.success\n     * @param {function} settings.progress\n     */\n    core.ajax = function (settings) {\n\n        if (!settings || !settings.url) {\n\n            return;\n\n        }\n\n        var XMLHTTP = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP'),\n            encodedString,\n            isFormData,\n            prop;\n\n\n        settings.async           = true;\n        settings.type            = settings.type || 'GET';\n        settings.data            = settings.data || '';\n        settings['content-type'] = settings['content-type'] || 'application/json; charset=utf-8';\n\n        if (settings.type == 'GET' && settings.data) {\n\n            settings.url = /\\?/.test(settings.url) ? settings.url + '&' + settings.data : settings.url + '?' + settings.data;\n\n        } else {\n\n            encodedString = '';\n            for(prop in settings.data) {\n\n                encodedString += (prop + '=' + encodeURIComponent(settings.data[prop]) + '&');\n\n            }\n\n        }\n\n        if (settings.withCredentials) {\n\n            XMLHTTP.withCredentials = true;\n\n        }\n\n        /**\n         * Value returned in beforeSend funtion will be passed as context to the other response callbacks\n         * If beforeSend returns false, AJAX will be blocked\n         */\n        let responseContext,\n            beforeSendResult;\n\n        if (typeof settings.beforeSend === 'function') {\n\n            beforeSendResult = settings.beforeSend.call();\n\n            if (beforeSendResult === false) {\n\n                return;\n\n            }\n\n        }\n\n        XMLHTTP.open( settings.type, settings.url, settings.async );\n\n        /**\n         * If we send FormData, we need no content-type header\n         */\n        isFormData = isFormData_(settings.data);\n\n        if (!isFormData) {\n\n            if (settings.type !== 'POST') {\n\n                XMLHTTP.setRequestHeader('Content-type', settings['content-type']);\n\n            } else {\n\n                XMLHTTP.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n\n            }\n\n        }\n\n        XMLHTTP.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\n        responseContext = beforeSendResult || XMLHTTP;\n\n        if (typeof settings.progress === 'function') {\n\n            XMLHTTP.upload.onprogress = settings.progress.bind(responseContext);\n\n        }\n\n        XMLHTTP.onreadystatechange = function () {\n\n            if (XMLHTTP.readyState === 4) {\n\n                if (XMLHTTP.status === 200) {\n\n                    if (typeof settings.success === 'function') {\n\n                        settings.success.call(responseContext, XMLHTTP.responseText);\n\n                    }\n\n                } else {\n\n                    if (typeof settings.error === 'function') {\n\n                        settings.error.call(responseContext, XMLHTTP.responseText, XMLHTTP.status);\n\n                    }\n\n                }\n\n            }\n\n        };\n\n        if (isFormData) {\n\n            // Sending FormData\n            XMLHTTP.send(settings.data);\n\n        } else {\n\n            // POST requests\n            XMLHTTP.send(encodedString);\n\n        }\n\n        return XMLHTTP;\n\n    };\n\n    /**\n    * Appends script to head of document\n    * @return Promise\n    */\n    core.importScript = function (scriptPath, instanceName) {\n\n        return new Promise(function (resolve, reject) {\n\n            let script;\n\n            /** Script is already loaded */\n            if ( !instanceName ) {\n\n                reject('Instance name is missed');\n\n            } else if ( document.getElementById(editor.scriptPrefix + instanceName) ) {\n\n                resolve(scriptPath);\n\n            }\n\n            script = document.createElement('SCRIPT');\n            script.async = true;\n            script.defer = true;\n            script.id = editor.scriptPrefix + instanceName;\n\n            script.onload = function () {\n\n                resolve(scriptPath);\n\n            };\n\n            script.onerror = function () {\n\n                reject(scriptPath);\n\n            };\n\n            script.src = scriptPath;\n            document.head.appendChild(script);\n\n        });\n\n    };\n\n    /**\n     * Function for checking is it FormData object to send.\n     * @param {Object} object to check\n     * @return boolean\n     */\n    var isFormData_ = function (object) {\n\n        return object instanceof FormData;\n\n    };\n\n    /**\n     * Check block\n     * @param target\n     * @description Checks target is it native input\n     */\n    core.isNativeInput = function (target) {\n\n        var nativeInputAreas = ['INPUT', 'TEXTAREA'];\n\n        return nativeInputAreas.indexOf(target.tagName) != -1;\n\n    };\n\n    /**\n     * Check if block is empty\n     * We should check block textContent, child native inputs and some exceptions like IMG and IFRAME\n     *\n     * @param block\n     * @returns {boolean}\n     */\n    core.isBlockEmpty = function (block) {\n\n        const EXCEPTION_TAGS = ['IMG', 'IFRAME'];\n\n        var nativeInputs         = block.querySelectorAll('textarea, input'),\n            nativeInputsAreEmpty = true,\n            textContentIsEmpty   = !block.textContent.trim();\n\n        Array.prototype.forEach.call(nativeInputs, function (input) {\n\n            if (input.type == 'textarea' || input.type == 'text') {\n\n                nativeInputsAreEmpty = nativeInputsAreEmpty && !input.value.trim();\n\n            }\n\n        });\n\n        return textContentIsEmpty && nativeInputsAreEmpty && !EXCEPTION_TAGS.includes(block.tagName);\n\n    };\n\n\n    return core;\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./modules/core.js","/**\n* Module working with plugins\n*/\nmodule.exports = (function () {\n\n    let editor = this;\n\n    /**\n     * Initialize plugins before using\n     * Ex. Load scripts or call some internal methods\n     * @return Promise\n     */\n    function prepare() {\n\n        return new Promise(function (resolve_, reject_) {\n\n            Promise.resolve()\n\n                /**\n                * Compose a sequence of plugins that requires preparation\n                */\n                .then(function () {\n\n                    let pluginsRequiresPreparation = [],\n                        allPlugins = editor.tools;\n\n                    for ( let pluginName in allPlugins ) {\n\n                        let plugin = allPlugins[pluginName];\n\n                        if (plugin.prepare && typeof plugin.prepare !== 'function' || !plugin.prepare) {\n\n                            continue;\n\n                        }\n\n                        pluginsRequiresPreparation.push(plugin);\n\n                    }\n\n                    /**\n                    * If no one passed plugins requires preparation, finish prepare() and go ahead\n                    */\n                    if (!pluginsRequiresPreparation.length) {\n\n                        resolve_();\n\n                    }\n\n                    return pluginsRequiresPreparation;\n\n                })\n\n                /** Wait plugins while they prepares */\n                .then(waitAllPluginsPreparation_)\n\n                .then(function () {\n\n                    editor.modules.core.log('Plugins loaded', 'info');\n                    resolve_();\n\n                }).catch(function (error) {\n\n                    reject_(error);\n\n                });\n\n        });\n\n    }\n\n    /**\n    * @param {array} plugins - list of tools that requires preparation\n    * @return {Promise} resolved while all plugins will be ready or failed\n    */\n    function waitAllPluginsPreparation_(plugins) {\n\n        /**\n        * @calls allPluginsProcessed__ when all plugins prepared or failed\n        */\n        return new Promise (function (allPluginsProcessed__) {\n\n            /**\n             * pluck each element from queue\n             * First, send resolved Promise as previous value\n             * Each plugins \"prepare\" method returns a Promise, that's why\n             * reduce current element will not be able to continue while can't get\n             * a resolved Promise\n             *\n             * If last plugin is \"prepared\" then go to the next stage of initialization\n             */\n            plugins.reduce(function (previousValue, plugin, iteration) {\n\n                return previousValue.then(function () {\n\n                    /**\n                    * Wait till plugins prepared\n                    * @calls pluginIsReady__ when plugin is ready or failed\n                    */\n                    return new Promise ( function (pluginIsReady__) {\n\n                        callPluginsPrepareMethod_( plugin )\n\n                            .then( pluginIsReady__ )\n                            .then( function () {\n\n                                plugin.available = true;\n\n                            })\n\n                            .catch(function (error) {\n\n                                editor.modules.core.log(`Plugin «${plugin.type}» was not loaded. Preparation failed because %o`, 'warn', error);\n                                plugin.available = false;\n                                plugin.loadingMessage = error;\n\n                                /** Go ahead even some plugin has problems */\n                                pluginIsReady__();\n\n                            })\n\n                            .then(function () {\n\n                                /** If last plugin has problems then just ignore and continue */\n                                if (iteration == plugins.length - 1) {\n\n                                    allPluginsProcessed__();\n\n                                }\n\n                            });\n\n                    });\n\n                });\n\n            }, Promise.resolve() );\n\n        });\n\n    }\n\n    var callPluginsPrepareMethod_ = function (plugin) {\n\n        return plugin.prepare( plugin.config || {} );\n\n    };\n\n    return {\n        prepare: prepare\n    };\n\n});\n\n\n// WEBPACK FOOTER //\n// ./modules/tools.js","/**\n * Codex Editor UI module\n *\n * @author Codex Team\n * @version 1.2.0\n */\n\nmodule.exports = (function () {\n\n    let ui = {};\n\n    let editor = this;\n\n    /**\n     * Basic editor classnames\n     */\n    ui.className = {\n\n        /**\n         * @const {string} BLOCK_CLASSNAME - redactor blocks name\n         */\n        BLOCK_CLASSNAME : 'ce-block',\n\n        /**\n         * @const {String} wrapper for plugins content\n         */\n        BLOCK_CONTENT : 'ce-block__content',\n\n        /**\n         * @const {String} BLOCK_STRETCHED - makes block stretched\n         */\n        BLOCK_STRETCHED : 'ce-block--stretched',\n\n        /**\n         * @const {String} BLOCK_HIGHLIGHTED - adds background\n         */\n        BLOCK_HIGHLIGHTED : 'ce-block--focused',\n\n        /**\n         * @const {String} - for all default settings\n         */\n        SETTINGS_ITEM : 'ce-settings__item'\n\n    };\n\n    /**\n     * @protected\n     *\n     * Making main interface\n     */\n    ui.prepare = function () {\n\n        return new Promise(function (resolve) {\n\n            let wrapper  = editor.modules.draw.wrapper(),\n                redactor = editor.modules.draw.redactor(),\n                toolbar  = makeToolBar_();\n\n            wrapper.appendChild(toolbar);\n            wrapper.appendChild(redactor);\n\n            /** Save created ui-elements to static nodes state */\n            editor.nodes.wrapper  = wrapper;\n            editor.nodes.redactor = redactor;\n\n            /** Append editor wrapper with redactor zone into holder */\n            editor.nodes.holder.appendChild(wrapper);\n\n            resolve();\n\n        })\n\n        /** Add toolbox tools */\n        .then(addTools_)\n\n        /** Make container for inline toolbar */\n        .then(makeInlineToolbar_)\n\n        /** Add inline toolbar tools */\n        .then(addInlineToolbarTools_)\n\n        /** Draw wrapper for notifications */\n        .then(makeNotificationHolder_)\n\n        /** Add eventlisteners to redactor elements */\n        .then(bindEvents_)\n\n        .catch( function (e) {\n\n            editor.modules.core.log(\"Can't draw editor interface %o\", 'warn', e);\n\n        });\n\n    };\n\n    /**\n     * @private\n     * Draws inline toolbar zone\n     */\n    var makeInlineToolbar_ = function () {\n\n        var container = editor.modules.draw.inlineToolbar();\n\n        /** Append to redactor new inline block */\n        editor.nodes.inlineToolbar.wrapper = container;\n\n        /** Draw toolbar buttons */\n        editor.nodes.inlineToolbar.buttons = editor.modules.draw.inlineToolbarButtons();\n\n        /** Buttons action or settings */\n        editor.nodes.inlineToolbar.actions = editor.modules.draw.inlineToolbarActions();\n\n        /** Append to inline toolbar buttons as part of it */\n        editor.nodes.inlineToolbar.wrapper.appendChild(editor.nodes.inlineToolbar.buttons);\n        editor.nodes.inlineToolbar.wrapper.appendChild(editor.nodes.inlineToolbar.actions);\n\n        editor.nodes.wrapper.appendChild(editor.nodes.inlineToolbar.wrapper);\n\n    };\n\n    var makeToolBar_ = function () {\n\n        let toolbar         = editor.modules.draw.toolbar(),\n            blockButtons    = makeToolbarSettings_(),\n            toolbarContent  = makeToolbarContent_();\n\n        /** Appending first-level block buttons */\n        toolbar.appendChild(blockButtons);\n\n        /** Append toolbarContent to toolbar */\n        toolbar.appendChild(toolbarContent);\n\n        /** Make toolbar global */\n        editor.nodes.toolbar = toolbar;\n\n        return toolbar;\n\n    };\n\n    var makeToolbarContent_ = function () {\n\n        let toolbarContent = editor.modules.draw.toolbarContent(),\n            toolbox        = editor.modules.draw.toolbox(),\n            plusButton     = editor.modules.draw.plusButton();\n\n        /** Append plus button */\n        toolbarContent.appendChild(plusButton);\n\n        /** Appending toolbar tools */\n        toolbarContent.appendChild(toolbox);\n\n        /** Make Toolbox and plusButton global */\n        editor.nodes.toolbox    = toolbox;\n        editor.nodes.plusButton = plusButton;\n\n        return toolbarContent;\n\n    };\n\n    var makeToolbarSettings_ = function () {\n\n        let blockSettings       = editor.modules.draw.blockSettings(),\n            blockButtons        = editor.modules.draw.blockButtons(),\n            defaultSettings     = editor.modules.draw.defaultSettings(),\n            showSettingsButton  = editor.modules.draw.settingsButton(),\n            showTrashButton     = editor.modules.toolbar.settings.makeRemoveBlockButton(),\n            pluginSettings      = editor.modules.draw.pluginsSettings();\n\n        /** Add default and plugins settings */\n        blockSettings.appendChild(pluginSettings);\n        blockSettings.appendChild(defaultSettings);\n\n        /**\n         * Make blocks buttons\n         * This block contains settings button and remove block button\n         */\n        blockButtons.appendChild(showSettingsButton);\n        blockButtons.appendChild(showTrashButton);\n        blockButtons.appendChild(blockSettings);\n\n        /** Make BlockSettings, PluginSettings, DefaultSettings global */\n        editor.nodes.blockSettings      = blockSettings;\n        editor.nodes.pluginSettings     = pluginSettings;\n        editor.nodes.defaultSettings    = defaultSettings;\n        editor.nodes.showSettingsButton = showSettingsButton;\n        editor.nodes.showTrashButton    = showTrashButton;\n\n        return blockButtons;\n\n    };\n\n    /** Draw notifications holder */\n    var makeNotificationHolder_ = function () {\n\n        /** Append block with notifications to the document */\n        editor.nodes.notifications = editor.modules.notifications.createHolder();\n\n    };\n\n    /**\n     * @private\n     * Append tools passed in editor.tools\n     */\n    var addTools_ = function () {\n\n        var tool,\n            toolName,\n            toolButton;\n\n        for ( toolName in editor.settings.tools ) {\n\n            tool = editor.settings.tools[toolName];\n\n            editor.tools[toolName] = tool;\n            let toolInstance = tool.instance();\n\n            if (!tool.iconClassname && tool.displayInToolbox) {\n\n                editor.modules.core.log('Toolbar icon classname missed. Tool %o skipped', 'warn', toolName);\n                continue;\n\n            }\n\n            if (typeof toolInstance.render != 'function') {\n\n                editor.modules.core.log('render method missed. Tool %o skipped', 'warn', toolName);\n                continue;\n\n            }\n\n            if (!tool.displayInToolbox) {\n\n                continue;\n\n            } else {\n\n                /** if tools is for toolbox */\n                toolButton = editor.modules.draw.toolbarButton(toolName, tool.iconClassname);\n\n                editor.nodes.toolbox.appendChild(toolButton);\n\n                editor.nodes.toolbarButtons[toolName] = toolButton;\n\n            }\n\n        }\n\n    };\n\n    var addInlineToolbarTools_ = function () {\n\n        var tools = {\n\n            bold: {\n                icon    : 'ce-icon-bold',\n                command : 'bold'\n            },\n\n            italic: {\n                icon    : 'ce-icon-italic',\n                command : 'italic'\n            },\n\n            link: {\n                icon    : 'ce-icon-link',\n                command : 'createLink'\n            }\n        };\n\n        var toolButton,\n            tool;\n\n        for(var name in tools) {\n\n            tool = tools[name];\n\n            toolButton = editor.modules.draw.toolbarButtonInline(name, tool.icon);\n\n            editor.nodes.inlineToolbar.buttons.appendChild(toolButton);\n            /**\n             * Add callbacks to this buttons\n             */\n            editor.modules.ui.setInlineToolbarButtonBehaviour(toolButton, tool.command);\n\n        }\n\n    };\n\n    /**\n     * @private\n     * Bind editor UI events\n     */\n    var bindEvents_ = function () {\n\n        editor.modules.core.log('ui.bindEvents fired', 'info');\n\n        // window.addEventListener('error', function (errorMsg, url, lineNumber) {\n        //     editor.notifications.errorThrown(errorMsg, event);\n        // }, false );\n\n        /** All keydowns on Document */\n        editor.modules.listeners.add(document, 'keydown', editor.modules.callback.globalKeydown, false);\n\n        /** All keydowns on Redactor zone */\n        editor.modules.listeners.add(editor.nodes.redactor, 'keydown', editor.modules.callback.redactorKeyDown, false);\n\n        /** All keydowns on Document */\n        editor.modules.listeners.add(document, 'keyup', editor.modules.callback.globalKeyup, false );\n\n        /**\n         * Mouse click to radactor\n         */\n        editor.modules.listeners.add(editor.nodes.redactor, 'click', editor.modules.callback.redactorClicked, false );\n\n        /**\n         * Clicks to the Plus button\n         */\n        editor.modules.listeners.add(editor.nodes.plusButton, 'click', editor.modules.callback.plusButtonClicked, false);\n\n        /**\n         * Clicks to SETTINGS button in toolbar\n         */\n        editor.modules.listeners.add(editor.nodes.showSettingsButton, 'click', editor.modules.callback.showSettingsButtonClicked, false );\n\n        /** Bind click listeners on toolbar buttons */\n        for (var button in editor.nodes.toolbarButtons) {\n\n            editor.modules.listeners.add(editor.nodes.toolbarButtons[button], 'click', editor.modules.callback.toolbarButtonClicked, false);\n\n        }\n\n    };\n\n    ui.addBlockHandlers = function (block) {\n\n        if (!block) return;\n\n        /**\n         * Block keydowns\n         */\n        editor.modules.listeners.add(block, 'keydown', editor.modules.callback.blockKeydown, false);\n\n        /**\n         * Pasting content from another source\n         * We have two type of sanitization\n         * First - uses deep-first search algorithm to get sub nodes,\n         * sanitizes whole Block_content and replaces cleared nodes\n         * This method is deprecated\n         * Method is used in editor.callback.blockPaste(event)\n         *\n         * Secont - uses Mutation observer.\n         * Observer \"observe\" DOM changes and send changings to callback.\n         * Callback gets changed node, not whole Block_content.\n         * Inserted or changed node, which we've gotten have been cleared and replaced with diry node\n         *\n         * Method is used in editor.callback.blockPasteViaSanitize(event)\n         *\n         * @uses html-janitor\n         * @example editor.callback.blockPasteViaSanitize(event), the second method.\n         *\n         */\n        editor.modules.listeners.add(block, 'paste', editor.modules.paste.blockPasteCallback, false);\n\n        /**\n         * Show inline toolbar for selected text\n         */\n        editor.modules.listeners.add(block, 'mouseup', editor.modules.toolbar.inline.show, false);\n        editor.modules.listeners.add(block, 'keyup', editor.modules.toolbar.inline.show, false);\n\n    };\n\n    /** getting all contenteditable elements */\n    ui.saveInputs = function () {\n\n        var redactor = editor.nodes.redactor;\n\n        editor.state.inputs = [];\n\n        /** Save all inputs in global variable state */\n        var inputs = redactor.querySelectorAll('[contenteditable], input, textarea');\n\n        Array.prototype.map.call(inputs, function (current) {\n\n            if (!current.type || current.type == 'text' || current.type == 'textarea') {\n\n                editor.state.inputs.push(current);\n\n            }\n\n        });\n\n    };\n\n    /**\n     * Adds first initial block on empty redactor\n     */\n    ui.addInitialBlock = function () {\n\n        var initialBlockType = editor.settings.initialBlockPlugin,\n            initialBlock;\n\n        if ( !editor.tools[initialBlockType] ) {\n\n            editor.modules.core.log('Plugin %o was not implemented and can\\'t be used as initial block', 'warn', initialBlockType);\n            return;\n\n        }\n\n        initialBlock = editor.modules.renderer.makeBlockFromData({type: initialBlockType});\n\n        initialBlock.setAttribute('data-placeholder', editor.settings.placeholder);\n\n        editor.modules.content.insertBlock({\n            type  : initialBlockType,\n            block : initialBlock\n        });\n\n        editor.modules.content.workingNodeChanged(initialBlock);\n\n    };\n\n    ui.setInlineToolbarButtonBehaviour = function (button, type) {\n\n        editor.modules.listeners.add(button, 'mousedown', function (event) {\n\n            editor.modules.toolbar.inline.toolClicked(event, type);\n\n        }, false);\n\n    };\n\n    return ui;\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./modules/ui.js","/**\n *\n * Codex.Editor Transport Module\n *\n * @copyright 2017 Codex-Team\n * @version 1.2.0\n */\n\nmodule.exports = (function () {\n\n    let transport = {};\n\n    let editor = this;\n\n\n    /**\n     * @private {Object} current XmlHttpRequest instance\n     */\n    var currentRequest = null;\n\n\n    /**\n     * @type {null} | {DOMElement} input - keeps input element in memory\n     */\n    transport.input = null;\n\n    /**\n     * @property {Object} arguments - keep plugin settings and defined callbacks\n     */\n    transport.arguments = null;\n\n    /**\n     * Prepares input element where will be files\n     */\n    transport.prepare = function () {\n\n        let input = editor.modules.draw.node( 'INPUT', '', { type : 'file' } );\n\n        editor.modules.listeners.add(input, 'change', editor.modules.transport.fileSelected);\n        editor.modules.transport.input = input;\n\n    };\n\n    /** Clear input when files is uploaded */\n    transport.clearInput = function () {\n\n        /** Remove old input */\n        transport.input = null;\n\n        /** Prepare new one */\n        transport.prepare();\n\n    };\n\n    /**\n     * Callback for file selection\n     * @param {Event} event\n     */\n    transport.fileSelected = function () {\n\n        var input       = this,\n            i,\n            files       = input.files,\n            formData   = new FormData();\n\n        if (editor.modules.transport.arguments.multiple === true) {\n\n            for ( i = 0; i < files.length; i++) {\n\n                formData.append('files[]', files[i], files[i].name);\n\n            }\n\n        } else {\n\n            formData.append('files', files[0], files[0].name);\n\n        }\n\n        currentRequest = editor.core.ajax({\n            type : 'POST',\n            data : formData,\n            url        : editor.modules.transport.arguments.url,\n            beforeSend : editor.modules.transport.arguments.beforeSend,\n            success    : editor.modules.transport.arguments.success,\n            error      : editor.modules.transport.arguments.error,\n            progress   : editor.modules.transport.arguments.progress\n        });\n\n        /** Clear input */\n        transport.clearInput();\n\n    };\n\n    /**\n     * Use plugin callbacks\n     * @protected\n     *\n     * @param {Object} args - can have :\n     * @param {String} args.url - fetch URL\n     * @param {Function} args.beforeSend - function calls before sending ajax\n     * @param {Function} args.success - success callback\n     * @param {Function} args.error - on error handler\n     * @param {Function} args.progress - xhr onprogress handler\n     * @param {Boolean} args.multiple - allow select several files\n     * @param {String} args.accept - adds accept attribute\n     */\n    transport.selectAndUpload = function (args) {\n\n        transport.arguments = args;\n\n        if ( args.multiple === true) {\n\n            transport.input.setAttribute('multiple', 'multiple');\n\n        }\n\n        if ( args.accept ) {\n\n            transport.input.setAttribute('accept', args.accept);\n\n        }\n\n        transport.input.click();\n\n    };\n\n    transport.abort = function () {\n\n        currentRequest.abort();\n\n        currentRequest = null;\n\n    };\n\n    return transport;\n\n});\n\n\n// WEBPACK FOOTER //\n// ./modules/transport.js","/**\n * Codex Editor Renderer Module\n *\n * @author Codex Team\n * @version 1.0\n */\n\nmodule.exports = (function () {\n\n    let renderer = {};\n\n    let editor = this;\n\n    /**\n     * Asyncronously parses input JSON to redactor blocks\n     */\n    renderer.makeBlocksFromData = function () {\n\n        /**\n         * If redactor is empty, add first paragraph to start writing\n         */\n        if (editor.modules.core.isEmpty(editor.state.blocks) || !editor.state.blocks.items.length) {\n\n            editor.modules.ui.addInitialBlock();\n            return;\n\n        }\n\n        return renderer.appendBlocks(editor.state.blocks)\n            /** Write log if something goes wrong */\n            .catch(function (error) {\n\n                editor.modules.core.log('Error while parsing JSON: %o', 'error', error);\n\n            });\n\n    };\n\n    /**\n     * Parses JSON to blocks\n     * @param {object} data\n     * @return Primise -> nodeList\n     */\n    renderer.appendBlocks = function (data) {\n\n        let blocksData = data.items;\n\n        /**\n         * Sequence of one-by-one blocks appending\n         * Uses to save blocks order after async-handler\n         */\n        var blocks = [];\n\n        for (var index = 0; index < blocksData.length ; index++ ) {\n\n            blocks.push(Promise.resolve(blocksData[index])\n              .then(makeBlockFromData));\n\n        }\n\n        return Promise.all(blocks)\n          .then(elements => {\n\n              elements.forEach(element => {\n\n                  editor.modules.content.insertBlock({\n                      block: element,\n                      type: element.tool.name\n                  });\n\n              });\n\n          });\n\n    };\n\n    /**\n     * Append node at specified index\n     */\n    renderer.appendNodeAtIndex = function (nodeSequence, blocks, index) {\n\n        /** We need to append node to sequence */\n        nodeSequence\n\n        /** first, get node async-aware */\n            .then(function () {\n\n                return editor.modules.renderer.getNodeAsync(blocks, index);\n\n            })\n\n            /**\n             * second, compose editor-block from JSON object\n             */\n            .then(editor.modules.renderer.createBlockFromData)\n\n            /**\n             * now insert block to redactor\n             */\n            .then(function (blockData) {\n\n                /**\n                 * blockData has 'block', 'type' and 'stretched' information\n                 */\n                editor.modules.content.insertBlock(blockData);\n\n                /** Pass created block to next step */\n                return blockData.block;\n\n            })\n\n            /** Log if something wrong with node */\n            .catch(function (error) {\n\n                editor.modules.core.log('Node skipped while parsing because %o', 'error', error);\n\n            });\n\n    };\n\n    /**\n     * Creates editor block by JSON-data\n     *\n     * @uses render method of each plugin\n     *\n     * @param {Object} toolData.tool\n     *                              { header : {\n     *                                                text: '',\n     *                                                type: 'H3', ...\n     *                                            }\n     *                               }\n     * @param {Number} toolData.position - index in input-blocks array\n     * @return {Object} with type and Element\n     */\n    renderer.createBlockFromData = function ( toolData ) {\n\n        /** New parser */\n        var block,\n            tool = toolData.tool,\n            pluginName = tool.type;\n\n        /** Get first key of object that stores plugin name */\n        // for (var pluginName in blockData) break;\n\n        /** Check for plugin existance */\n        if (!editor.tools[pluginName]) {\n\n            throw Error(`Plugin «${pluginName}» not found`);\n\n        }\n\n        /** Check for plugin having render method */\n        if (typeof editor.tools[pluginName].render != 'function') {\n\n            throw Error(`Plugin «${pluginName}» must have «render» method`);\n\n        }\n\n        if ( editor.tools[pluginName].available === false ) {\n\n            block = editor.modules.draw.unavailableBlock();\n\n            block.innerHTML = editor.tools[pluginName].loadingMessage;\n\n            /**\n            * Saver will extract data from initial block data by position in array\n            */\n            block.dataset.inputPosition = toolData.position;\n\n        } else {\n\n            /** New Parser */\n            block = editor.tools[pluginName].render(tool.data);\n\n        }\n\n        /** is first-level block stretched */\n        var stretched = editor.tools[pluginName].isStretched || false;\n\n        /** Retrun type and block */\n        return {\n            type      : pluginName,\n            block     : block,\n            stretched : stretched\n        };\n\n    };\n\n    function makeBlockFromData(blockData) {\n\n        let toolName = blockData.type,\n            data = blockData.data;\n\n        if (!editor.tools[toolName]) {\n\n            // throw Error(`Plugin «${toolName}» not found`);\n            return;\n\n        }\n\n        let tool = editor.tools[toolName];\n\n        let toolInstance = tool.instance();\n\n        if (typeof toolInstance.render != 'function') {\n\n            // throw Error(`Plugin «${toolName}» must have «render» method`);\n            return;\n\n        }\n\n        let DOMElement = toolInstance.render(data);\n\n        DOMElement.tool = toolInstance;\n\n        return DOMElement;\n\n    }\n\n    renderer.makeBlockFromData = makeBlockFromData;\n\n    return renderer;\n\n});\n\n\n// WEBPACK FOOTER //\n// ./modules/renderer.js","/**\n * Codex Editor Saver\n *\n * @author Codex Team\n * @version 1.1.0\n */\n\nmodule.exports = (function () {\n\n    let saver = {};\n\n    let editor = this;\n\n    /**\n     * @public\n     * Save blocks\n     */\n    saver.save = function () {\n\n        /** Save html content of redactor to memory */\n        editor.state.html = editor.nodes.redactor.innerHTML;\n\n        /** Clean jsonOutput state */\n        editor.state.jsonOutput = [];\n\n        return saveBlocks(editor.nodes.redactor.childNodes);\n\n    };\n\n    /**\n     * @private\n     * Save each block data\n     *\n     * @param blocks\n     * @returns {Promise.<TResult>}\n     */\n    let saveBlocks = function (blocks) {\n\n        let data = [];\n\n        for(let index = 0; index < blocks.length; index++) {\n\n            data.push(getBlockData(blocks[index]));\n\n        }\n\n        return Promise.all(data)\n            .then(makeOutput)\n            .catch(editor.modules.core.log);\n\n    };\n\n    /** Save and validate block data */\n    let getBlockData = function (block) {\n\n        return saveBlockData(block)\n          .then(validateBlockData)\n          .catch(editor.modules.core.log);\n\n    };\n\n   /**\n    * @private\n    * Call block`s plugin save method and return saved data\n    *\n    * @param block\n    * @returns {Object}\n    */\n    let saveBlockData = function (block) {\n\n        let tool = block.childNodes[0].childNodes[0].tool;\n\n        /** Check for plugin existence */\n        if (!editor.tools[tool.name]) {\n\n            editor.modules.core.log(`Plugin «${tool.name}» not found`, 'error');\n            return {data: null, tool: null};\n\n        }\n\n        /** Check for plugin having save method */\n        if (typeof tool.save !== 'function') {\n\n            editor.modules.core.log(`Plugin «${tool.name}» must have save method`, 'error');\n            return {data: null, tool: null};\n\n        }\n\n        /** Result saver */\n        let blockContent   = block.childNodes[0],\n            pluginsContent = blockContent.childNodes[0],\n            position = pluginsContent.dataset.inputPosition;\n\n        /** If plugin wasn't available then return data from cache */\n        if ( editor.tools[tool.name].available === false ) {\n\n            return Promise.resolve({data: codex.editor.state.blocks.items[position].data, tool});\n\n        }\n\n        return Promise.resolve(pluginsContent)\n            .then(tool.save)\n            .then(data => Object({data, tool}));\n\n    };\n\n   /**\n    * Call plugin`s validate method. Return false if validation failed\n    *\n    * @param data\n    * @param tool\n    * @returns {Object|Boolean}\n    */\n    let validateBlockData = function ({data, tool}) {\n\n        if (!data || !tool) {\n\n            return false;\n\n        }\n\n        if (tool.validate && typeof tool.validate === 'function') {\n\n            let result = tool.validate(data);\n\n            /**\n             * Do not allow invalid data\n             */\n            if (!result) {\n\n                return false;\n\n            }\n\n        }\n\n        return {data, tool};\n\n\n    };\n\n   /**\n    * Compile article output\n    *\n    * @param savedData\n    * @returns {{time: number, version, items: (*|Array)}}\n    */\n    let makeOutput = function (savedData) {\n\n        savedData = savedData.filter(blockData => blockData);\n\n        let items = savedData.map(blockData => Object({type: blockData.tool.name, data: blockData.data}));\n\n        editor.state.jsonOutput = items;\n\n        return {\n            id: editor.state.blocks.id || null,\n            time: +new Date(),\n            version: editor.version,\n            items\n        };\n\n    };\n\n    return saver;\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./modules/saver.js","/**\n * Codex Editor Content Module\n * Works with DOM\n *\n * @module Codex Editor content module\n *\n * @author Codex Team\n * @version 1.3.13\n *\n * @description Module works with Elements that have been appended to the main DOM\n */\n\nmodule.exports = (function () {\n\n    let content = {};\n\n    let editor = this;\n\n    /**\n     * Links to current active block\n     * @type {null | Element}\n     */\n    content.currentNode = null;\n\n    /**\n     * clicked in redactor area\n     * @type {null | Boolean}\n     */\n    content.editorAreaHightlighted = null;\n\n    /**\n     * @deprecated\n     * Synchronizes redactor with original textarea\n     */\n    content.sync = function () {\n\n        editor.modules.core.log('syncing...');\n\n        /**\n         * Save redactor content to editor.state\n         */\n        editor.state.html = editor.nodes.redactor.innerHTML;\n\n    };\n\n    /**\n     * Appends background to the block\n     *\n     * @description add CSS class to highlight visually first-level block area\n     */\n    content.markBlock = function () {\n\n        editor.modules.content.currentNode.classList.add(editor.modules.ui.className.BLOCK_HIGHLIGHTED);\n\n    };\n\n    /**\n     * Clear background\n     *\n     * @description clears styles that highlights block\n     */\n    content.clearMark = function () {\n\n        if (editor.modules.content.currentNode) {\n\n            editor.modules.content.currentNode.classList.remove(editor.modules.ui.className.BLOCK_HIGHLIGHTED);\n\n        }\n\n    };\n\n    /**\n     * Finds first-level block\n     *\n     * @param {Element} node - selected or clicked in redactors area node\n     * @protected\n     *\n     * @description looks for first-level block.\n     * gets parent while node is not first-level\n     */\n    content.getFirstLevelBlock = function (node) {\n\n        if (!editor.modules.core.isDomNode(node)) {\n\n            node = node.parentNode;\n\n        }\n\n        if (node === editor.nodes.redactor || node === document.body) {\n\n            return null;\n\n        } else {\n\n            while(!node.classList.contains(editor.modules.ui.className.BLOCK_CLASSNAME)) {\n\n                node = node.parentNode;\n\n            }\n\n            return node;\n\n        }\n\n    };\n\n    /**\n     * Trigger this event when working node changed\n     * @param {Element} targetNode - first-level of this node will be current\n     * @protected\n     *\n     * @description If targetNode is first-level then we set it as current else we look for parents to find first-level\n     */\n    content.workingNodeChanged = function (targetNode) {\n\n        /** Clear background from previous marked block before we change */\n        editor.modules.content.clearMark();\n\n        if (!targetNode) {\n\n            return;\n\n        }\n\n        content.currentNode = content.getFirstLevelBlock(targetNode);\n\n    };\n\n    /**\n     * Replaces one redactor block with another\n     * @protected\n     * @param {Element} targetBlock - block to replace. Mostly currentNode.\n     * @param {Element} newBlock\n     * @param {string} newBlockType - type of new block; we need to store it to data-attribute\n     *\n     * [!] Function does not saves old block content.\n     *     You can get it manually and pass with newBlock.innerHTML\n     */\n    content.replaceBlock = function (targetBlock, newBlock) {\n\n        if (!targetBlock || !newBlock) {\n\n            editor.modules.core.log('replaceBlock: missed params');\n            return;\n\n        }\n\n        /** If target-block is not a frist-level block, then we iterate parents to find it */\n        while(!targetBlock.classList.contains(editor.modules.ui.className.BLOCK_CLASSNAME)) {\n\n            targetBlock = targetBlock.parentNode;\n\n        }\n\n        /** Replacing */\n        editor.nodes.redactor.replaceChild(newBlock, targetBlock);\n\n        /**\n         * Set new node as current\n         */\n        editor.modules.content.workingNodeChanged(newBlock);\n\n        /**\n         * Add block handlers\n         */\n        editor.modules.ui.addBlockHandlers(newBlock);\n\n        /**\n         * Save changes\n         */\n        editor.modules.ui.saveInputs();\n\n    };\n\n    /**\n     * @protected\n     *\n     * Inserts new block to redactor\n     * Wrapps block into a DIV with BLOCK_CLASSNAME class\n     *\n     * @param blockData          {object}\n     * @param blockData.block    {Element}   element with block content\n     * @param blockData.type     {string}    block plugin\n     * @param needPlaceCaret     {bool}      pass true to set caret in new block\n     *\n     */\n    content.insertBlock = function ( blockData, needPlaceCaret ) {\n\n        var workingBlock    = editor.modules.content.currentNode,\n            newBlockContent = blockData.block,\n            blockType       = blockData.type,\n            isStretched     = blockData.stretched;\n\n        var newBlock = composeNewBlock_(newBlockContent, blockType, isStretched);\n\n        if (workingBlock) {\n\n            editor.modules.core.insertAfter(workingBlock, newBlock);\n\n        } else {\n\n            /**\n             * If redactor is empty, append as first child\n             */\n            editor.nodes.redactor.appendChild(newBlock);\n\n        }\n\n        /**\n         * Block handler\n         */\n        editor.modules.ui.addBlockHandlers(newBlock);\n\n        /**\n         * Set new node as current\n         */\n        editor.modules.content.workingNodeChanged(newBlock);\n\n        /**\n         * Save changes\n         */\n        editor.modules.ui.saveInputs();\n\n\n        if ( needPlaceCaret ) {\n\n            /**\n             * If we don't know input index then we set default value -1\n             */\n            var currentInputIndex = editor.modules.caret.getCurrentInputIndex() || -1;\n\n\n            if (currentInputIndex == -1) {\n\n\n                var editableElement = newBlock.querySelector('[contenteditable]'),\n                    emptyText       = document.createTextNode('');\n\n                editableElement.appendChild(emptyText);\n                editor.modules.caret.set(editableElement, 0, 0);\n\n                editor.modules.toolbar.move();\n                editor.modules.toolbar.showPlusButton();\n\n\n            } else {\n\n                if (currentInputIndex === editor.state.inputs.length - 1)\n                    return;\n\n                /** Timeout for browsers execution */\n                window.setTimeout(function () {\n\n                    /** Setting to the new input */\n                    editor.modules.caret.setToNextBlock(currentInputIndex);\n                    editor.modules.toolbar.move();\n                    editor.modules.toolbar.open();\n\n                }, 10);\n\n            }\n\n        }\n\n        /**\n         * Block is inserted, wait for new click that defined focusing on editors area\n         * @type {boolean}\n         */\n        content.editorAreaHightlighted = false;\n\n    };\n\n    /**\n     * Replaces blocks with saving content\n     * @protected\n     * @param {Element} noteToReplace\n     * @param {Element} newNode\n     * @param {Element} blockType\n     */\n    content.switchBlock = function (blockToReplace, newBlock, tool) {\n\n        tool = tool || editor.modules.content.currentNode.dataset.tool;\n        var newBlockComposed = composeNewBlock_(newBlock, tool);\n\n        /** Replacing */\n        editor.modules.content.replaceBlock(blockToReplace, newBlockComposed);\n\n        /** Save new Inputs when block is changed */\n        editor.modules.ui.saveInputs();\n\n    };\n\n    /**\n     * Iterates between child noted and looking for #text node on deepest level\n     * @protected\n     *\n     * @param {Element} block - node where find\n     * @param {int} postiton - starting postion\n     *      Example: childNodex.length to find from the end\n     *               or 0 to find from the start\n     * @return {Text} block\n     * @uses DFS\n     */\n    content.getDeepestTextNodeFromPosition = function (block, position) {\n\n        /**\n         * Clear Block from empty and useless spaces with trim.\n         * Such nodes we should remove\n         */\n        var blockChilds = block.childNodes,\n            index,\n            node,\n            text;\n\n        for(index = 0; index < blockChilds.length; index++) {\n\n            node = blockChilds[index];\n\n            if (node.nodeType == editor.modules.core.nodeTypes.TEXT) {\n\n                text = node.textContent.trim();\n\n                /** Text is empty. We should remove this child from node before we start DFS\n                 * decrease the quantity of childs.\n                 */\n                if (text === '') {\n\n                    block.removeChild(node);\n                    position--;\n\n                }\n\n            }\n\n        }\n\n        if (block.childNodes.length === 0) {\n\n            return document.createTextNode('');\n\n        }\n\n        /** Setting default position when we deleted all empty nodes */\n        if ( position < 0 )\n            position = 1;\n\n        var lookingFromStart = false;\n\n        /** For looking from START */\n        if (position === 0) {\n\n            lookingFromStart = true;\n            position = 1;\n\n        }\n\n        while ( position ) {\n\n            /** initial verticle of node. */\n            if ( lookingFromStart ) {\n\n                block = block.childNodes[0];\n\n            } else {\n\n                block = block.childNodes[position - 1];\n\n            }\n\n            if ( block.nodeType == editor.core.nodeTypes.TAG ) {\n\n                position = block.childNodes.length;\n\n            } else if (block.nodeType == editor.core.nodeTypes.TEXT ) {\n\n                position = 0;\n\n            }\n\n        }\n\n        return block;\n\n    };\n\n    /**\n     * @private\n     * @param {Element} block - current plugins render\n     * @param {String} tool - plugins name\n     * @param {Boolean} isStretched - make stretched block or not\n     *\n     * @description adds necessary information to wrap new created block by first-level holder\n     */\n    var composeNewBlock_ = function (block, tool, isStretched) {\n\n        var newBlock     = editor.modules.draw.node('DIV', editor.modules.ui.className.BLOCK_CLASSNAME, {}),\n            blockContent = editor.modules.draw.node('DIV', editor.modules.ui.className.BLOCK_CONTENT, {});\n\n        blockContent.appendChild(block);\n        newBlock.appendChild(blockContent);\n\n        if (isStretched) {\n\n            blockContent.classList.add(editor.modules.ui.className.BLOCK_STRETCHED);\n\n        }\n\n        newBlock.dataset.tool   = tool;\n        return newBlock;\n\n    };\n\n    /**\n     * Returns Range object of current selection\n     * @protected\n     */\n    content.getRange = function () {\n\n        var selection = window.getSelection().getRangeAt(0);\n\n        return selection;\n\n    };\n\n    /**\n     * Divides block in two blocks (after and before caret)\n     *\n     * @protected\n     * @param {int} inputIndex - target input index\n     *\n     * @description splits current input content to the separate blocks\n     * When enter is pressed among the words, that text will be splited.\n     */\n    content.splitBlock = function (inputIndex) {\n\n        var selection      = window.getSelection(),\n            anchorNode     = selection.anchorNode,\n            anchorNodeText = anchorNode.textContent,\n            caretOffset    = selection.anchorOffset,\n            textBeforeCaret,\n            textNodeBeforeCaret,\n            textAfterCaret,\n            textNodeAfterCaret;\n\n        var currentBlock = editor.modules.content.currentNode.querySelector('[contentEditable]');\n\n\n        textBeforeCaret     = anchorNodeText.substring(0, caretOffset);\n        textAfterCaret      = anchorNodeText.substring(caretOffset);\n\n        textNodeBeforeCaret = document.createTextNode(textBeforeCaret);\n\n        if (textAfterCaret) {\n\n            textNodeAfterCaret  = document.createTextNode(textAfterCaret);\n\n        }\n\n        var previousChilds = [],\n            nextChilds     = [],\n            reachedCurrent = false;\n\n        if (textNodeAfterCaret) {\n\n            nextChilds.push(textNodeAfterCaret);\n\n        }\n\n        for ( var i = 0, child; !!(child = currentBlock.childNodes[i]); i++) {\n\n            if ( child != anchorNode ) {\n\n                if ( !reachedCurrent ) {\n\n                    previousChilds.push(child);\n\n                } else {\n\n                    nextChilds.push(child);\n\n                }\n\n            } else {\n\n                reachedCurrent = true;\n\n            }\n\n        }\n\n        /** Clear current input */\n        editor.state.inputs[inputIndex].innerHTML = '';\n\n        /**\n         * Append all childs founded before anchorNode\n         */\n        var previousChildsLength = previousChilds.length;\n\n        for(i = 0; i < previousChildsLength; i++) {\n\n            editor.state.inputs[inputIndex].appendChild(previousChilds[i]);\n\n        }\n\n        editor.state.inputs[inputIndex].appendChild(textNodeBeforeCaret);\n\n        /**\n         * Append text node which is after caret\n         */\n        var nextChildsLength = nextChilds.length,\n            newNode          = document.createElement('div');\n\n        for(i = 0; i < nextChildsLength; i++) {\n\n            newNode.appendChild(nextChilds[i]);\n\n        }\n\n        newNode = newNode.innerHTML;\n\n        /** This type of block creates when enter is pressed */\n        var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\n        /**\n         * Make new paragraph with text after caret\n         */\n        editor.modules.content.insertBlock({\n            type  : NEW_BLOCK_TYPE,\n            block : editor.tools[NEW_BLOCK_TYPE].render({\n                text : newNode\n            })\n        }, true );\n\n    };\n\n    /**\n     * Merges two blocks — current and target\n     * If target index is not exist, then previous will be as target\n     *\n     * @protected\n     * @param {int} currentInputIndex\n     * @param {int} targetInputIndex\n     *\n     * @description gets two inputs indexes and merges into one\n     */\n    content.mergeBlocks = function (currentInputIndex, targetInputIndex) {\n\n        /** If current input index is zero, then prevent method execution */\n        if (currentInputIndex === 0) {\n\n            return;\n\n        }\n\n        var targetInput,\n            currentInputContent = editor.state.inputs[currentInputIndex].innerHTML;\n\n        if (!targetInputIndex) {\n\n            targetInput = editor.state.inputs[currentInputIndex - 1];\n\n        } else {\n\n            targetInput = editor.state.inputs[targetInputIndex];\n\n        }\n\n        targetInput.innerHTML += currentInputContent;\n\n    };\n\n    /**\n     * Iterates all right siblings and parents, which has right siblings\n     * while it does not reached the first-level block\n     *\n     * @param {Element} node\n     * @return {boolean}\n     */\n    content.isLastNode = function (node) {\n\n        // console.log('погнали перебор родителей');\n\n        var allChecked = false;\n\n        while ( !allChecked ) {\n\n            // console.log('Смотрим на %o', node);\n            // console.log('Проверим, пустые ли соседи справа');\n\n            if ( !allSiblingsEmpty_(node) ) {\n\n                // console.log('Есть непустые соседи. Узел не последний. Выходим.');\n                return false;\n\n            }\n\n            node = node.parentNode;\n\n            /**\n             * Проверяем родителей до тех пор, пока не найдем блок первого уровня\n             */\n            if ( node.classList.contains(editor.modules.ui.className.BLOCK_CONTENT) ) {\n\n                allChecked = true;\n\n            }\n\n        }\n\n        return true;\n\n    };\n\n    /**\n     * Checks if all element right siblings is empty\n     * @param node\n     */\n    var allSiblingsEmpty_ = function (node) {\n\n        /**\n         * Нужно убедиться, что после пустого соседа ничего нет\n         */\n        var sibling = node.nextSibling;\n\n        while ( sibling ) {\n\n            if (sibling.textContent.length) {\n\n                return false;\n\n            }\n\n            sibling = sibling.nextSibling;\n\n        }\n\n        return true;\n\n    };\n\n    /**\n     * @public\n     *\n     * @param {string} htmlData - html content as string\n     * @param {string} plainData - plain text\n     * @return {string} - html content as string\n     */\n    content.wrapTextWithParagraphs = function (htmlData, plainData) {\n\n        if (!htmlData.trim()) {\n\n            return wrapPlainTextWithParagraphs(plainData);\n\n        }\n\n        var wrapper = document.createElement('DIV'),\n            newWrapper = document.createElement('DIV'),\n            i,\n            paragraph,\n            firstLevelBlocks = ['DIV', 'P'],\n            blockTyped,\n            node;\n\n        /**\n         * Make HTML Element to Wrap Text\n         * It allows us to work with input data as HTML content\n         */\n        wrapper.innerHTML = htmlData;\n        paragraph = document.createElement('P');\n\n        for (i = 0; i < wrapper.childNodes.length; i++) {\n\n            node = wrapper.childNodes[i];\n\n            blockTyped = firstLevelBlocks.indexOf(node.tagName) != -1;\n\n            /**\n             * If node is first-levet\n             * we add this node to our new wrapper\n             */\n            if ( blockTyped ) {\n\n                /**\n                 * If we had splitted inline nodes to paragraph before\n                 */\n                if ( paragraph.childNodes.length ) {\n\n                    newWrapper.appendChild(paragraph.cloneNode(true));\n\n                    /** empty paragraph */\n                    paragraph = null;\n                    paragraph = document.createElement('P');\n\n                }\n\n                newWrapper.appendChild(node.cloneNode(true));\n\n            } else {\n\n                /** Collect all inline nodes to one as paragraph */\n                paragraph.appendChild(node.cloneNode(true));\n\n                /** if node is last we should append this node to paragraph and paragraph to new wrapper */\n                if ( i == wrapper.childNodes.length - 1 ) {\n\n                    newWrapper.appendChild(paragraph.cloneNode(true));\n\n                }\n\n            }\n\n        }\n\n        return newWrapper.innerHTML;\n\n    };\n\n    /**\n     * Splits strings on new line and wraps paragraphs with <p> tag\n     * @param plainText\n     * @returns {string}\n     */\n    var wrapPlainTextWithParagraphs = function (plainText) {\n\n        return '<p>' + plainText.split('\\n\\n').join('</p><p>') + '</p>';\n\n    };\n\n    /**\n    * Finds closest Contenteditable parent from Element\n    * @param {Element} node     element looking from\n    * @return {Element} node    contenteditable\n    */\n    content.getEditableParent = function (node) {\n\n        while (node && node.contentEditable != 'true') {\n\n            node = node.parentNode;\n\n        }\n\n        return node;\n\n    };\n\n    /**\n    * Clear editors content\n     *\n     * @param {Boolean} all — if true, delete all article data (content, id, etc.)\n    */\n    content.clear = function (all) {\n\n        editor.nodes.redactor.innerHTML = '';\n        editor.modules.content.sync();\n        editor.modules.ui.saveInputs();\n        if (all) {\n\n            editor.state.blocks = {};\n\n        } else if (editor.state.blocks) {\n\n            editor.state.blocks.items = [];\n\n        }\n\n        editor.modules.content.currentNode = null;\n\n    };\n\n    /**\n    *\n     * Load new data to editor\n     * If editor is not empty, just append articleData.items\n     *\n    * @param articleData.items\n    */\n    content.load = function (articleData) {\n\n        var currentContent = Object.assign({}, editor.state.blocks);\n\n        editor.modules.content.clear();\n\n        if (!Object.keys(currentContent).length) {\n\n            editor.state.blocks = articleData;\n\n        } else if (!currentContent.items) {\n\n            currentContent.items = articleData.items;\n            editor.state.blocks = currentContent;\n\n        } else {\n\n            currentContent.items = currentContent.items.concat(articleData.items);\n            editor.state.blocks = currentContent;\n\n        }\n\n        editor.modules.renderer.makeBlocksFromData();\n\n    };\n\n    return content;\n\n});\n\n\n// WEBPACK FOOTER //\n// ./modules/content.js","/**\n * Codex Editor toolbar module\n *\n * Contains:\n *  - Inline toolbox\n *  - Toolbox within plus button\n *  - Settings section\n *\n * @author Codex Team\n * @version 1.0\n */\n\nmodule.exports = (function () {\n\n    let toolbar = {};\n\n    let editor = this;\n\n    toolbar.settings = require('./settings').call(editor);\n    toolbar.inline   = require('./inline').call(editor);\n    toolbar.toolbox  = require('./toolbox').call(editor);\n\n    /**\n     * Margin between focused node and toolbar\n     */\n    toolbar.defaultToolbarHeight = 49;\n\n    toolbar.defaultOffset = 34;\n\n    toolbar.opened = false;\n\n    toolbar.current = null;\n\n    /**\n     * @protected\n     */\n    toolbar.open = function () {\n\n        if (editor.hideToolbar) {\n\n            return;\n\n        }\n\n        let tool = editor.modules.content.currentNode.childNodes[0].childNodes[0].tool;\n\n        if (!editor.tools[tool.name] || !tool.makeSettings || typeof tool.makeSettings !== 'function') {\n\n            editor.nodes.showSettingsButton.classList.add('hide');\n\n        } else {\n\n            editor.nodes.showSettingsButton.classList.remove('hide');\n\n        }\n\n        editor.nodes.toolbar.classList.add('opened');\n        this.opened = true;\n\n    };\n\n    /**\n     * @protected\n     */\n    toolbar.close = function () {\n\n        editor.nodes.toolbar.classList.remove('opened');\n\n        toolbar.opened  = false;\n        toolbar.current = null;\n\n        for (var button in editor.nodes.toolbarButtons) {\n\n            editor.nodes.toolbarButtons[button].classList.remove('selected');\n\n        }\n\n        /** Close toolbox when toolbar is not displayed */\n        editor.modules.toolbar.toolbox.close();\n        editor.modules.toolbar.settings.close();\n\n    };\n\n    toolbar.toggle = function () {\n\n        if ( !this.opened ) {\n\n            this.open();\n\n        } else {\n\n            this.close();\n\n        }\n\n    };\n\n    toolbar.hidePlusButton = function () {\n\n        editor.nodes.plusButton.classList.add('hide');\n\n    };\n\n    toolbar.showPlusButton = function () {\n\n        editor.nodes.plusButton.classList.remove('hide');\n\n    };\n\n    /**\n     * Moving toolbar to the specified node\n     */\n    toolbar.move = function () {\n\n        /** Close Toolbox when we move toolbar */\n        editor.modules.toolbar.toolbox.close();\n\n        if (!editor.modules.content.currentNode) {\n\n            return;\n\n        }\n\n        var newYCoordinate = editor.modules.content.currentNode.offsetTop - (editor.modules.toolbar.defaultToolbarHeight / 2) + editor.modules.toolbar.defaultOffset;\n\n        editor.nodes.toolbar.style.transform = `translate3D(0, ${Math.floor(newYCoordinate)}px, 0)`;\n\n        /** Close trash actions */\n        editor.modules.toolbar.settings.hideRemoveActions();\n\n    };\n\n    return toolbar;\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./modules/toolbar/toolbar.js","/**\n * Toolbar settings\n *\n * @version 1.0.5\n */\n\nmodule.exports = (function () {\n\n    let settings = {};\n\n    let editor = this;\n\n    settings.opened = false;\n\n    settings.setting = null;\n    settings.actions = null;\n\n    /**\n     * Append and open settings\n     */\n    settings.open = function (tool) {\n\n        /**\n         * Append settings content\n         * It's stored in tool.settings\n         */\n        if ( !editor.tools[tool.name] || !tool.makeSettings || typeof tool.makeSettings !== 'function') {\n\n            return;\n\n        }\n\n        /**\n         * Draw settings block\n         */\n        var settingsBlock = tool.makeSettings();\n\n        editor.nodes.pluginSettings.appendChild(settingsBlock);\n\n\n        /** Open settings block */\n        editor.nodes.blockSettings.classList.add('opened');\n        this.opened = true;\n\n    };\n\n    /**\n     * Close and clear settings\n     */\n    settings.close = function () {\n\n        editor.nodes.blockSettings.classList.remove('opened');\n        editor.nodes.pluginSettings.innerHTML = '';\n\n        this.opened = false;\n\n    };\n\n    /**\n     * @param {string} toolType - plugin type\n     */\n    settings.toggle = function ( tool ) {\n\n        if ( !this.opened ) {\n\n            this.open(tool);\n\n        } else {\n\n            this.close();\n\n        }\n\n    };\n\n    /**\n     * Here we will draw buttons and add listeners to components\n     */\n    settings.makeRemoveBlockButton = function () {\n\n        var removeBlockWrapper  = editor.modules.draw.node('SPAN', 'ce-toolbar__remove-btn', {}),\n            settingButton = editor.modules.draw.node('SPAN', 'ce-toolbar__remove-setting', { innerHTML : '<i class=\"ce-icon-trash\"></i>' }),\n            actionWrapper = editor.modules.draw.node('DIV', 'ce-toolbar__remove-confirmation', {}),\n            confirmAction = editor.modules.draw.node('DIV', 'ce-toolbar__remove-confirm', { textContent : 'Удалить блок' }),\n            cancelAction  = editor.modules.draw.node('DIV', 'ce-toolbar__remove-cancel', { textContent : 'Отмена' });\n\n        editor.modules.listeners.add(settingButton, 'click', editor.modules.toolbar.settings.removeButtonClicked, false);\n\n        editor.modules.listeners.add(confirmAction, 'click', editor.modules.toolbar.settings.confirmRemovingRequest, false);\n\n        editor.modules.listeners.add(cancelAction, 'click', editor.modules.toolbar.settings.cancelRemovingRequest, false);\n\n        actionWrapper.appendChild(confirmAction);\n        actionWrapper.appendChild(cancelAction);\n\n        removeBlockWrapper.appendChild(settingButton);\n        removeBlockWrapper.appendChild(actionWrapper);\n\n        /** Save setting */\n        editor.modules.toolbar.settings.setting = settingButton;\n        editor.modules.toolbar.settings.actions = actionWrapper;\n\n        return removeBlockWrapper;\n\n    };\n\n    settings.removeButtonClicked = function () {\n\n        var action = editor.modules.toolbar.settings.actions;\n\n        if (action.classList.contains('opened')) {\n\n            editor.modules.toolbar.settings.hideRemoveActions();\n\n        } else {\n\n            editor.modules.toolbar.settings.showRemoveActions();\n\n        }\n\n        editor.modules.toolbar.toolbox.close();\n        editor.modules.toolbar.settings.close();\n\n    };\n\n    settings.cancelRemovingRequest = function () {\n\n        editor.modules.toolbar.settings.actions.classList.remove('opened');\n\n    };\n\n    settings.confirmRemovingRequest = function () {\n\n        var currentBlock = editor.modules.content.currentNode,\n            firstLevelBlocksCount;\n\n        currentBlock.remove();\n\n        firstLevelBlocksCount = editor.nodes.redactor.childNodes.length;\n\n        /**\n         * If all blocks are removed\n         */\n        if (firstLevelBlocksCount === 0) {\n\n            /** update currentNode variable */\n            editor.modules.content.currentNode = null;\n\n            /** Inserting new empty initial block */\n            editor.modules.ui.addInitialBlock();\n\n        }\n\n        editor.modules.ui.saveInputs();\n\n        editor.modules.toolbar.close();\n\n    };\n\n    settings.showRemoveActions = function () {\n\n        editor.modules.toolbar.settings.actions.classList.add('opened');\n\n    };\n\n    settings.hideRemoveActions = function () {\n\n        editor.modules.toolbar.settings.actions.classList.remove('opened');\n\n    };\n\n    return settings;\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./modules/toolbar/settings.js","/**\n * Inline toolbar\n *\n * Contains from tools:\n * Bold, Italic, Underline and Anchor\n *\n * @author Codex Team\n * @version 1.0\n */\n\nmodule.exports = (function () {\n\n    let inline = {};\n\n    let editor = this;\n\n    inline.buttonsOpened = null;\n    inline.actionsOpened = null;\n    inline.wrappersOffset = null;\n\n    /**\n     * saving selection that need for execCommand for styling\n     *\n     */\n    inline.storedSelection = null;\n\n    /**\n     * @protected\n     *\n     * Open inline toobar\n     */\n    inline.show = function () {\n\n        var currentNode = editor.modules.content.currentNode,\n            tool = currentNode.dataset.tool,\n            plugin;\n\n        /**\n         * tool allowed to open inline toolbar\n         */\n        plugin = editor.tools[tool];\n\n        if (!plugin.showInlineToolbar)\n            return;\n\n        var selectedText = inline.getSelectionText(),\n            toolbar      = editor.nodes.inlineToolbar.wrapper;\n\n        if (selectedText.length > 0) {\n\n            /** Move toolbar and open */\n            editor.modules.toolbar.inline.move();\n\n            /** Open inline toolbar */\n            toolbar.classList.add('opened');\n\n            /** show buttons of inline toolbar */\n            editor.modules.toolbar.inline.showButtons();\n\n        }\n\n    };\n\n    /**\n     * @protected\n     *\n     * Closes inline toolbar\n     */\n    inline.close = function () {\n\n        var toolbar = editor.nodes.inlineToolbar.wrapper;\n\n        toolbar.classList.remove('opened');\n\n    };\n\n    /**\n     * @private\n     *\n     * Moving toolbar\n     */\n    inline.move = function () {\n\n        if (!this.wrappersOffset) {\n\n            this.wrappersOffset = this.getWrappersOffset();\n\n        }\n\n        var coords          = this.getSelectionCoords(),\n            defaultOffset   = 0,\n            toolbar         = editor.nodes.inlineToolbar.wrapper,\n            newCoordinateX,\n            newCoordinateY;\n\n        if (toolbar.offsetHeight === 0) {\n\n            defaultOffset = 40;\n\n        }\n\n        newCoordinateX = coords.x - this.wrappersOffset.left;\n        newCoordinateY = coords.y + window.scrollY - this.wrappersOffset.top - defaultOffset - toolbar.offsetHeight;\n\n        toolbar.style.transform = `translate3D(${Math.floor(newCoordinateX)}px, ${Math.floor(newCoordinateY)}px, 0)`;\n\n        /** Close everything */\n        editor.modules.toolbar.inline.closeButtons();\n        editor.modules.toolbar.inline.closeAction();\n\n    };\n\n    /**\n     * @private\n     *\n     * Tool Clicked\n     */\n\n    inline.toolClicked = function (event, type) {\n\n        /**\n         * For simple tools we use default browser function\n         * For more complicated tools, we should write our own behavior\n         */\n        switch (type) {\n            case 'createLink' : editor.modules.toolbar.inline.createLinkAction(event, type); break;\n            default           : editor.modules.toolbar.inline.defaultToolAction(type); break;\n        }\n\n        /**\n         * highlight buttons\n         * after making some action\n         */\n        editor.nodes.inlineToolbar.buttons.childNodes.forEach(editor.modules.toolbar.inline.hightlight);\n\n    };\n\n    /**\n     * @private\n     *\n     * Saving wrappers offset in DOM\n     */\n    inline.getWrappersOffset = function () {\n\n        var wrapper = editor.nodes.wrapper,\n            offset  = this.getOffset(wrapper);\n\n        this.wrappersOffset = offset;\n        return offset;\n\n    };\n\n    /**\n     * @private\n     *\n     * Calculates offset of DOM element\n     *\n     * @param el\n     * @returns {{top: number, left: number}}\n     */\n    inline.getOffset = function ( el ) {\n\n        var _x = 0;\n        var _y = 0;\n\n        while( el && !isNaN( el.offsetLeft ) && !isNaN( el.offsetTop ) ) {\n\n            _x += (el.offsetLeft + el.clientLeft);\n            _y += (el.offsetTop + el.clientTop);\n            el = el.offsetParent;\n\n        }\n        return { top: _y, left: _x };\n\n    };\n\n    /**\n     * @private\n     *\n     * Calculates position of selected text\n     * @returns {{x: number, y: number}}\n     */\n    inline.getSelectionCoords = function () {\n\n        var sel = document.selection, range;\n        var x = 0, y = 0;\n\n        if (sel) {\n\n            if (sel.type != 'Control') {\n\n                range = sel.createRange();\n                range.collapse(true);\n                x = range.boundingLeft;\n                y = range.boundingTop;\n\n            }\n\n        } else if (window.getSelection) {\n\n            sel = window.getSelection();\n\n            if (sel.rangeCount) {\n\n                range = sel.getRangeAt(0).cloneRange();\n                if (range.getClientRects) {\n\n                    range.collapse(true);\n                    var rect = range.getClientRects()[0];\n\n                    if (!rect) {\n\n                        return;\n\n                    }\n\n                    x = rect.left;\n                    y = rect.top;\n\n                }\n\n            }\n\n        }\n        return { x: x, y: y };\n\n    };\n\n    /**\n     * @private\n     *\n     * Returns selected text as String\n     * @returns {string}\n     */\n    inline.getSelectionText = function () {\n\n        var selectedText = '';\n\n        // all modern browsers and IE9+\n        if (window.getSelection) {\n\n            selectedText = window.getSelection().toString();\n\n        }\n\n        return selectedText;\n\n    };\n\n    /** Opens buttons block */\n    inline.showButtons = function () {\n\n        var buttons = editor.nodes.inlineToolbar.buttons;\n\n        buttons.classList.add('opened');\n\n        editor.modules.toolbar.inline.buttonsOpened = true;\n\n        /** highlight buttons */\n        editor.nodes.inlineToolbar.buttons.childNodes.forEach(editor.modules.toolbar.inline.hightlight);\n\n    };\n\n    /** Makes buttons disappear */\n    inline.closeButtons = function () {\n\n        var buttons = editor.nodes.inlineToolbar.buttons;\n\n        buttons.classList.remove('opened');\n\n        editor.modules.toolbar.inline.buttonsOpened = false;\n\n    };\n\n    /** Open buttons defined action if exist */\n    inline.showActions = function () {\n\n        var action = editor.nodes.inlineToolbar.actions;\n\n        action.classList.add('opened');\n\n        editor.modules.toolbar.inline.actionsOpened = true;\n\n    };\n\n    /** Close actions block */\n    inline.closeAction = function () {\n\n        var action = editor.nodes.inlineToolbar.actions;\n\n        action.innerHTML = '';\n        action.classList.remove('opened');\n        editor.modules.toolbar.inline.actionsOpened = false;\n\n    };\n\n\n    /**\n    * Callback for keydowns in inline toolbar \"Insert link...\" input\n    */\n    let inlineToolbarAnchorInputKeydown_ = function (event) {\n\n        if (event.keyCode != editor.core.keys.ENTER) {\n\n            return;\n\n        }\n\n        let editable        = editor.modules.content.currentNode,\n            storedSelection = editor.modules.toolbar.inline.storedSelection;\n\n        editor.modules.toolbar.inline.restoreSelection(editable, storedSelection);\n        editor.modules.toolbar.inline.setAnchor(this.value);\n\n        /**\n         * Preventing events that will be able to happen\n         */\n        event.preventDefault();\n        event.stopImmediatePropagation();\n\n        editor.modules.toolbar.inline.clearRange();\n\n    };\n\n    /** Action for link creation or for setting anchor */\n    inline.createLinkAction = function (event) {\n\n        var isActive = this.isLinkActive();\n\n        var editable        = editor.modules.content.currentNode,\n            storedSelection = editor.modules.toolbar.inline.saveSelection(editable);\n\n        /** Save globally selection */\n        editor.modules.toolbar.inline.storedSelection = storedSelection;\n\n        if (isActive) {\n\n\n            /**\n             * Changing stored selection. if we want to remove anchor from word\n             * we should remove anchor from whole word, not only selected part.\n             * The solution is than we get the length of current link\n             * Change start position to - end of selection minus length of anchor\n             */\n            editor.modules.toolbar.inline.restoreSelection(editable, storedSelection);\n\n            editor.modules.toolbar.inline.defaultToolAction('unlink');\n\n        } else {\n\n            /** Create input and close buttons */\n            var action = editor.draw.inputForLink();\n\n            editor.nodes.inlineToolbar.actions.appendChild(action);\n\n            editor.modules.toolbar.inline.closeButtons();\n            editor.modules.toolbar.inline.showActions();\n\n            /**\n             * focus to input\n             * Solution: https://developer.mozilla.org/ru/docs/Web/API/HTMLElement/focus\n             * Prevents event after showing input and when we need to focus an input which is in unexisted form\n             */\n            action.focus();\n            event.preventDefault();\n\n            /** Callback to link action */\n            editor.modules.listeners.add(action, 'keydown', inlineToolbarAnchorInputKeydown_, false);\n\n        }\n\n    };\n\n    inline.isLinkActive = function () {\n\n        var isActive = false;\n\n        editor.nodes.inlineToolbar.buttons.childNodes.forEach(function (tool) {\n\n            var dataType = tool.dataset.type;\n\n            if (dataType == 'link' && tool.classList.contains('hightlighted')) {\n\n                isActive = true;\n\n            }\n\n        });\n\n        return isActive;\n\n    };\n\n    /** default action behavior of tool */\n    inline.defaultToolAction = function (type) {\n\n        document.execCommand(type, false, null);\n\n    };\n\n    /**\n     * @private\n     *\n     * Sets URL\n     *\n     * @param {String} url - URL\n     */\n    inline.setAnchor = function (url) {\n\n        document.execCommand('createLink', false, url);\n\n        /** Close after URL inserting */\n        editor.modules.toolbar.inline.closeAction();\n\n    };\n\n    /**\n     * @private\n     *\n     * Saves selection\n     */\n    inline.saveSelection = function (containerEl) {\n\n        var range = window.getSelection().getRangeAt(0),\n            preSelectionRange = range.cloneRange(),\n            start;\n\n        preSelectionRange.selectNodeContents(containerEl);\n        preSelectionRange.setEnd(range.startContainer, range.startOffset);\n\n        start = preSelectionRange.toString().length;\n\n        return {\n            start: start,\n            end: start + range.toString().length\n        };\n\n    };\n\n    /**\n     * @private\n     *\n     * Sets to previous selection (Range)\n     *\n     * @param {Element} containerEl - editable element where we restore range\n     * @param {Object} savedSel - range basic information to restore\n     */\n    inline.restoreSelection = function (containerEl, savedSel) {\n\n        var range     = document.createRange(),\n            charIndex = 0;\n\n        range.setStart(containerEl, 0);\n        range.collapse(true);\n\n        var nodeStack = [ containerEl ],\n            node,\n            foundStart = false,\n            stop = false,\n            nextCharIndex;\n\n        while (!stop && (node = nodeStack.pop())) {\n\n            if (node.nodeType == 3) {\n\n                nextCharIndex = charIndex + node.length;\n\n                if (!foundStart && savedSel.start >= charIndex && savedSel.start <= nextCharIndex) {\n\n                    range.setStart(node, savedSel.start - charIndex);\n                    foundStart = true;\n\n                }\n                if (foundStart && savedSel.end >= charIndex && savedSel.end <= nextCharIndex) {\n\n                    range.setEnd(node, savedSel.end - charIndex);\n                    stop = true;\n\n                }\n                charIndex = nextCharIndex;\n\n            } else {\n\n                var i = node.childNodes.length;\n\n                while (i--) {\n\n                    nodeStack.push(node.childNodes[i]);\n\n                }\n\n            }\n\n        }\n\n        var sel = window.getSelection();\n\n        sel.removeAllRanges();\n        sel.addRange(range);\n\n    };\n\n    /**\n     * @private\n     *\n     * Removes all ranges from window selection\n     */\n    inline.clearRange = function () {\n\n        var selection = window.getSelection();\n\n        selection.removeAllRanges();\n\n    };\n\n    /**\n     * @private\n     *\n     * sets or removes hightlight\n     */\n    inline.hightlight = function (tool) {\n\n        var dataType = tool.dataset.type;\n\n        if (document.queryCommandState(dataType)) {\n\n            editor.modules.toolbar.inline.setButtonHighlighted(tool);\n\n        } else {\n\n            editor.modules.toolbar.inline.removeButtonsHighLight(tool);\n\n        }\n\n        /**\n         *\n         * hightlight for anchors\n         */\n        var selection = window.getSelection(),\n            tag = selection.anchorNode.parentNode;\n\n        if (tag.tagName == 'A' && dataType == 'link') {\n\n            editor.modules.toolbar.inline.setButtonHighlighted(tool);\n\n        }\n\n    };\n\n    /**\n     * @private\n     *\n     * Mark button if text is already executed\n     */\n    inline.setButtonHighlighted = function (button) {\n\n        button.classList.add('hightlighted');\n\n        /** At link tool we also change icon */\n        if (button.dataset.type == 'link') {\n\n            var icon = button.childNodes[0];\n\n            icon.classList.remove('ce-icon-link');\n            icon.classList.add('ce-icon-unlink');\n\n        }\n\n    };\n\n    /**\n     * @private\n     *\n     * Removes hightlight\n     */\n    inline.removeButtonsHighLight = function (button) {\n\n        button.classList.remove('hightlighted');\n\n        /** At link tool we also change icon */\n        if (button.dataset.type == 'link') {\n\n            var icon = button.childNodes[0];\n\n            icon.classList.remove('ce-icon-unlink');\n            icon.classList.add('ce-icon-link');\n\n        }\n\n    };\n\n\n    return inline;\n\n});\n\n\n// WEBPACK FOOTER //\n// ./modules/toolbar/inline.js","/**\n * Codex Editor toolbox\n *\n * All tools be able to appended here\n *\n * @author Codex Team\n * @version 1.0\n */\n\nmodule.exports = (function () {\n\n    let toolbox = {};\n\n    let editor = this;\n\n    toolbox.opened = false;\n    toolbox.openedOnBlock = null;\n\n    /** Shows toolbox */\n    toolbox.open = function () {\n\n        /** Close setting if toolbox is opened */\n        if (editor.modules.toolbar.settings.opened) {\n\n            editor.modules.toolbar.settings.close();\n\n        }\n\n        /** Add 'toolbar-opened' class for current block **/\n        toolbox.openedOnBlock = editor.modules.content.currentNode;\n        toolbox.openedOnBlock.classList.add('toolbar-opened');\n\n        /** display toolbox */\n        editor.nodes.toolbox.classList.add('opened');\n\n        /** Animate plus button */\n        editor.nodes.plusButton.classList.add('clicked');\n\n        /** toolbox state */\n        editor.modules.toolbar.toolbox.opened = true;\n\n    };\n\n    /** Closes toolbox */\n    toolbox.close = function () {\n\n        /** Remove 'toolbar-opened' class from current block **/\n        if (toolbox.openedOnBlock) toolbox.openedOnBlock.classList.remove('toolbar-opened');\n        toolbox.openedOnBlock = null;\n\n        /** Makes toolbox disappear */\n        editor.nodes.toolbox.classList.remove('opened');\n\n        /** Rotate plus button */\n        editor.nodes.plusButton.classList.remove('clicked');\n\n        /** toolbox state */\n        editor.modules.toolbar.toolbox.opened = false;\n\n        editor.modules.toolbar.current = null;\n\n    };\n\n    toolbox.leaf = function () {\n\n        let currentTool = editor.modules.toolbar.current,\n            tools       = Object.keys(editor.tools),\n            barButtons  = editor.nodes.toolbarButtons,\n            nextToolIndex = 0,\n            toolToSelect,\n            visibleTool,\n            tool;\n\n        if ( !currentTool ) {\n\n            /** Get first tool from object*/\n            for(tool in editor.tools) {\n\n                if (editor.tools[tool].displayInToolbox) {\n\n                    break;\n\n                }\n\n                nextToolIndex ++;\n\n            }\n\n        } else {\n\n            nextToolIndex = (tools.indexOf(currentTool) + 1) % tools.length;\n            visibleTool = tools[nextToolIndex];\n\n            while (!editor.tools[visibleTool].displayInToolbox) {\n\n                nextToolIndex = (nextToolIndex + 1) % tools.length;\n                visibleTool = tools[nextToolIndex];\n\n            }\n\n        }\n\n        toolToSelect = tools[nextToolIndex];\n\n        for ( var button in barButtons ) {\n\n            barButtons[button].classList.remove('selected');\n\n        }\n\n        barButtons[toolToSelect].classList.add('selected');\n        editor.modules.toolbar.current = toolToSelect;\n\n    };\n\n    /**\n     * Transforming selected node type into selected toolbar element type\n     * @param {event} event\n     */\n    toolbox.toolClicked = function (event) {\n\n        /**\n         * UNREPLACEBLE_TOOLS this types of tools are forbidden to replace even they are empty\n         */\n        var UNREPLACEBLE_TOOLS = ['image', 'link', 'list', 'instagram', 'twitter', 'embed'],\n            tool               = editor.tools[editor.modules.toolbar.current],\n            workingNode        = editor.modules.content.currentNode,\n            currentInputIndex  = editor.modules.caret.inputIndex,\n            newBlockContent,\n            appendCallback,\n            blockData;\n\n        /** Make block from plugin */\n        newBlockContent = editor.modules.renderer.makeBlockFromData({type: tool.type});\n\n        /** information about block */\n        blockData = {\n            block     : newBlockContent,\n            type      : tool.type,\n            stretched : false\n        };\n\n        if (\n            workingNode &&\n            UNREPLACEBLE_TOOLS.indexOf(workingNode.dataset.tool) === -1 &&\n            workingNode.textContent.trim() === ''\n        ) {\n\n            /** Replace current block */\n            editor.modules.content.switchBlock(workingNode, newBlockContent, tool.type);\n\n        } else {\n\n            /** Insert new Block from plugin */\n            editor.modules.content.insertBlock(blockData);\n\n            /** increase input index */\n            currentInputIndex++;\n\n        }\n\n        /** Fire tool append callback  */\n        appendCallback = tool.appendCallback;\n\n        if (appendCallback && typeof appendCallback == 'function') {\n\n            appendCallback.call(event);\n\n        }\n\n        window.setTimeout(function () {\n\n            /** Set caret to current block */\n            editor.modules.caret.setToBlock(currentInputIndex);\n\n        }, 10);\n\n\n        /**\n         * Changing current Node\n         */\n        editor.modules.content.workingNodeChanged();\n\n        /**\n         * Move toolbar when node is changed\n         */\n        editor.modules.toolbar.move();\n\n    };\n\n    return toolbox;\n\n});\n\n\n// WEBPACK FOOTER //\n// ./modules/toolbar/toolbox.js","/**\n * @module Codex Editor Callbacks module\n * @description Module works with editor added Elements\n *\n * @author Codex Team\n * @version 1.4.0\n */\n\nmodule.exports = (function () {\n\n    let callbacks = {};\n\n    let editor = this;\n\n    /**\n     * used by UI module\n     * @description Routes all keydowns on document\n     * @param {Object} event\n     */\n    callbacks.globalKeydown = function (event) {\n\n        switch (event.keyCode) {\n            case editor.modules.core.keys.ENTER : enterKeyPressed_(event);     break;\n        }\n\n    };\n\n    /**\n     * used by UI module\n     * @description Routes all keydowns on redactors area\n     * @param {Object} event\n     */\n    callbacks.redactorKeyDown = function (event) {\n\n        switch (event.keyCode) {\n            case editor.modules.core.keys.TAB   : tabKeyPressedOnRedactorsZone_(event);                     break;\n            case editor.modules.core.keys.ENTER : enterKeyPressedOnRedactorsZone_(event);                   break;\n            case editor.modules.core.keys.ESC   : escapeKeyPressedOnRedactorsZone_(event);                  break;\n            default                     : defaultKeyPressedOnRedactorsZone_(event);                 break;\n        }\n\n    };\n\n    /**\n     * used by UI module\n     * @description Routes all keyup events\n     * @param {Object} event\n     */\n    callbacks.globalKeyup = function (event) {\n\n        switch (event.keyCode) {\n            case editor.modules.core.keys.UP    :\n            case editor.modules.core.keys.LEFT  :\n            case editor.modules.core.keys.RIGHT :\n            case editor.modules.core.keys.DOWN  : arrowKeyPressed_(event); break;\n        }\n\n    };\n\n    /**\n     * @param {Object} event\n     * @private\n     *\n     * Handles behaviour when tab pressed\n     * @description if Content is empty show toolbox (if it is closed) or leaf tools\n     * uses Toolbars toolbox module to handle the situation\n     */\n    var tabKeyPressedOnRedactorsZone_ = function (event) {\n\n        /**\n         * Wait for solution. Would like to know the behaviour\n         * @todo Add spaces\n         */\n        event.preventDefault();\n\n\n        if (!editor.modules.core.isBlockEmpty(editor.modules.content.currentNode)) {\n\n            return;\n\n        }\n\n        if ( !editor.modules.toolbar.opened  ) {\n\n            editor.modules.toolbar.open();\n\n        }\n\n        if (editor.modules.toolbar.opened && !editor.modules.toolbar.toolbox.opened) {\n\n            editor.modules.toolbar.toolbox.open();\n\n        } else {\n\n            editor.modules.toolbar.toolbox.leaf();\n\n        }\n\n    };\n\n    /**\n     * Handles global EnterKey Press\n     * @see enterPressedOnBlock_\n     * @param {Object} event\n     */\n    var enterKeyPressed_ = function () {\n\n        if (editor.modules.content.editorAreaHightlighted) {\n\n            /**\n             * it means that we lose input index, saved index before is not correct\n             * therefore we need to set caret when we insert new block\n             */\n            editor.modules.caret.inputIndex = -1;\n\n            enterPressedOnBlock_();\n\n        }\n\n    };\n\n    /**\n     * Callback for enter key pressing in first-level block area\n     *\n     * @param {Event} event\n     * @private\n     *\n     * @description Inserts new block with initial type from settings\n     */\n    var enterPressedOnBlock_ = function () {\n\n        var NEW_BLOCK_TYPE  = editor.settings.initialBlockPlugin;\n\n        editor.modules.content.insertBlock({\n            type  : NEW_BLOCK_TYPE,\n            block : editor.tools[NEW_BLOCK_TYPE].render()\n        }, true );\n\n        editor.modules.toolbar.move();\n        editor.modules.toolbar.open();\n\n    };\n\n\n    /**\n     * ENTER key handler\n     *\n     * @param {Object} event\n     * @private\n     *\n     * @description Makes new block with initial type from settings\n     */\n    var enterKeyPressedOnRedactorsZone_ = function (event) {\n\n        if (event.target.contentEditable == 'true') {\n\n            /** Update input index */\n            editor.modules.caret.saveCurrentInputIndex();\n\n        }\n\n        var currentInputIndex       = editor.modules.caret.getCurrentInputIndex() || 0,\n            workingNode             = editor.modules.content.currentNode,\n            tool                    = workingNode.dataset.tool,\n            isEnterPressedOnToolbar = editor.modules.toolbar.opened &&\n                                        editor.modules.toolbar.current &&\n                                        event.target == editor.state.inputs[currentInputIndex];\n\n        /** The list of tools which needs the default browser behaviour */\n        var enableLineBreaks = editor.tools[tool].enableLineBreaks;\n\n        /** This type of block creates when enter is pressed */\n        var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\n        /**\n         * When toolbar is opened, select tool instead of making new paragraph\n         */\n        if ( isEnterPressedOnToolbar ) {\n\n            event.preventDefault();\n\n            editor.modules.toolbar.toolbox.toolClicked(event);\n\n            editor.modules.toolbar.close();\n\n            /**\n             * Stop other listeners callback executions\n             */\n            event.stopPropagation();\n            event.stopImmediatePropagation();\n\n            return;\n\n        }\n\n        /**\n         * Allow paragraph lineBreaks with shift enter\n         * Or if shiftkey pressed and enter and enabledLineBreaks, the let new block creation\n         */\n        if ( event.shiftKey || enableLineBreaks ) {\n\n            event.stopPropagation();\n            event.stopImmediatePropagation();\n            return;\n\n        }\n\n        var currentSelection = window.getSelection(),\n            currentSelectedNode = currentSelection.anchorNode,\n            caretAtTheEndOfText = editor.modules.caret.position.atTheEnd(),\n            isTextNodeHasParentBetweenContenteditable = false;\n\n        /**\n         * Allow making new <p> in same block by SHIFT+ENTER and forbids to prevent default browser behaviour\n         */\n        if ( event.shiftKey && !enableLineBreaks ) {\n\n            editor.modules.callback.enterPressedOnBlock(editor.modules.content.currentBlock, event);\n            event.preventDefault();\n            return;\n\n        }\n\n        /**\n         * Workaround situation when caret at the Text node that has some wrapper Elements\n         * Split block cant handle this.\n         * We need to save default behavior\n         */\n        isTextNodeHasParentBetweenContenteditable = currentSelectedNode && currentSelectedNode.parentNode.contentEditable != 'true';\n\n        /**\n         * Split blocks when input has several nodes and caret placed in textNode\n         */\n        if (\n            currentSelectedNode.nodeType == editor.modules.core.nodeTypes.TEXT &&\n            !isTextNodeHasParentBetweenContenteditable &&\n            !caretAtTheEndOfText\n        ) {\n\n            event.preventDefault();\n\n            editor.modules.core.log('Splitting Text node...');\n\n            editor.modules.content.splitBlock(currentInputIndex);\n\n            /** Show plus button when next input after split is empty*/\n            if (!editor.state.inputs[currentInputIndex + 1].textContent.trim()) {\n\n                editor.modules.toolbar.showPlusButton();\n\n            }\n\n        } else {\n\n            var islastNode = editor.modules.content.isLastNode(currentSelectedNode);\n\n            if ( islastNode && caretAtTheEndOfText ) {\n\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n\n                editor.modules.core.log('ENTER clicked in last textNode. Create new BLOCK');\n\n                editor.modules.content.insertBlock({\n                    type: NEW_BLOCK_TYPE,\n                    block: editor.modules.renderer.makeBlockFromData({type: NEW_BLOCK_TYPE})\n                }, true);\n\n                editor.modules.toolbar.move();\n                editor.modules.toolbar.open();\n\n                /** Show plus button with empty block */\n                editor.modules.toolbar.showPlusButton();\n\n            }\n\n        }\n\n        /** get all inputs after new appending block */\n        editor.modules.ui.saveInputs();\n\n    };\n\n    /**\n     * Escape behaviour\n     * @param event\n     * @private\n     *\n     * @description Closes toolbox and toolbar. Prevents default behaviour\n     */\n    var escapeKeyPressedOnRedactorsZone_ = function (event) {\n\n        /** Close all toolbar */\n        editor.modules.toolbar.close();\n\n        /** Close toolbox */\n        editor.modules.toolbar.toolbox.close();\n\n        event.preventDefault();\n\n    };\n\n    /**\n     * @param {Event} event\n     * @private\n     *\n     * closes and moves toolbar\n     */\n    var arrowKeyPressed_ = function (event) {\n\n        editor.modules.content.workingNodeChanged();\n\n        /* Closing toolbar */\n        editor.modules.toolbar.close();\n        editor.modules.toolbar.move();\n\n    };\n\n    /**\n     * @private\n     * @param {Event} event\n     *\n     * @description Closes all opened bars from toolbar.\n     * If block is mark, clears highlightning\n     */\n    var defaultKeyPressedOnRedactorsZone_ = function () {\n\n        editor.modules.toolbar.close();\n\n        if (!editor.modules.toolbar.inline.actionsOpened) {\n\n            editor.modules.toolbar.inline.close();\n            editor.modules.content.clearMark();\n\n        }\n\n    };\n\n    /**\n     * Handler when clicked on redactors area\n     *\n     * @protected\n     * @param event\n     *\n     * @description Detects clicked area. If it is first-level block area, marks as detected and\n     * on next enter press will be inserted new block\n     * Otherwise, save carets position (input index) and put caret to the editable zone.\n     *\n     * @see detectWhenClickedOnFirstLevelBlockArea_\n     *\n     */\n    callbacks.redactorClicked = function (event) {\n\n        detectWhenClickedOnFirstLevelBlockArea_();\n\n        editor.modules.content.workingNodeChanged(event.target);\n        editor.modules.ui.saveInputs();\n\n        var selectedText = editor.modules.toolbar.inline.getSelectionText(),\n            firstLevelBlock;\n\n        /** If selection range took off, then we hide inline toolbar */\n        if (selectedText.length === 0) {\n\n            editor.modules.toolbar.inline.close();\n\n        }\n\n        /** Update current input index in memory when caret focused into existed input */\n        if (event.target.contentEditable == 'true') {\n\n            editor.modules.caret.saveCurrentInputIndex();\n\n        }\n\n        if (editor.modules.content.currentNode === null) {\n\n            /**\n             * If inputs in redactor does not exits, then we put input index 0 not -1\n             */\n            var indexOfLastInput = editor.state.inputs.length > 0 ? editor.state.inputs.length - 1 : 0;\n\n            /** If we have any inputs */\n            if (editor.state.inputs.length) {\n\n                /** getting firstlevel parent of input */\n                firstLevelBlock = editor.modules.content.getFirstLevelBlock(editor.state.inputs[indexOfLastInput]);\n\n            }\n\n            /** If input is empty, then we set caret to the last input */\n            if (editor.state.inputs.length && editor.state.inputs[indexOfLastInput].textContent === '' && firstLevelBlock.dataset.tool == editor.settings.initialBlockPlugin) {\n\n                editor.modules.caret.setToBlock(indexOfLastInput);\n\n            } else {\n\n                /** Create new input when caret clicked in redactors area */\n                var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\n                editor.modules.content.insertBlock({\n                    type  : NEW_BLOCK_TYPE,\n                    block : editor.modules.renderer.makeBlockFromData({type: NEW_BLOCK_TYPE})\n                });\n\n                /** If there is no inputs except inserted */\n                if (editor.state.inputs.length === 1) {\n\n                    editor.modules.caret.setToBlock(indexOfLastInput);\n\n                } else {\n\n                    /** Set caret to this appended input */\n                    editor.modules.caret.setToNextBlock(indexOfLastInput);\n\n                }\n\n            }\n\n        } else {\n\n            /** Close all panels */\n            editor.modules.toolbar.settings.close();\n            editor.modules.toolbar.toolbox.close();\n\n        }\n\n        /**\n         * Move toolbar and open\n         */\n        editor.modules.toolbar.move();\n        editor.modules.toolbar.open();\n\n        var inputIsEmpty = !editor.modules.content.currentNode.textContent.trim(),\n            currentNodeType = editor.modules.content.currentNode.dataset.tool,\n            isInitialType = currentNodeType == editor.settings.initialBlockPlugin;\n\n\n        /** Hide plus buttons */\n        editor.modules.toolbar.hidePlusButton();\n\n        if (!inputIsEmpty) {\n\n            /** Mark current block */\n            editor.modules.content.markBlock();\n\n        }\n\n        if ( isInitialType && inputIsEmpty ) {\n\n            /** Show plus button */\n            editor.modules.toolbar.showPlusButton();\n\n        }\n\n\n    };\n\n    /**\n     * This method allows to define, is caret in contenteditable element or not.\n     *\n     * @private\n     *\n     * @description Otherwise, if we get TEXT node from range container, that will means we have input index.\n     * In this case we use default browsers behaviour (if plugin allows that) or overwritten action.\n     * Therefore, to be sure that we've clicked first-level block area, we should have currentNode, which always\n     * specifies to the first-level block. Other cases we just ignore.\n     */\n    var detectWhenClickedOnFirstLevelBlockArea_ = function () {\n\n        var selection  = window.getSelection(),\n            anchorNode = selection.anchorNode,\n            flag = false;\n\n        if (selection.rangeCount === 0) {\n\n            editor.modules.content.editorAreaHightlighted = true;\n\n        } else {\n\n            if (!editor.modules.core.isDomNode(anchorNode)) {\n\n                anchorNode = anchorNode.parentNode;\n\n            }\n\n            /** Already founded, without loop */\n            if (anchorNode.contentEditable == 'true') {\n\n                flag = true;\n\n            }\n\n            while (anchorNode.contentEditable != 'true') {\n\n                anchorNode = anchorNode.parentNode;\n\n                if (anchorNode.contentEditable == 'true') {\n\n                    flag = true;\n\n                }\n\n                if (anchorNode == document.body) {\n\n                    break;\n\n                }\n\n            }\n\n            /** If editable element founded, flag is \"TRUE\", Therefore we return \"FALSE\" */\n            editor.modules.content.editorAreaHightlighted = !flag;\n\n        }\n\n    };\n\n    /**\n     * Toolbar button click handler\n     *\n     * @param {Object} event - cursor to the button\n     * @protected\n     *\n     * @description gets current tool and calls render method\n     */\n    callbacks.toolbarButtonClicked = function (event) {\n\n        var button = this;\n\n        editor.modules.toolbar.current = button.dataset.type;\n\n        editor.modules.toolbar.toolbox.toolClicked(event);\n        editor.modules.toolbar.close();\n\n    };\n\n    /**\n     * Show or Hide toolbox when plus button is clicked\n     */\n    callbacks.plusButtonClicked = function () {\n\n        if (!editor.nodes.toolbox.classList.contains('opened')) {\n\n            editor.modules.toolbar.toolbox.open();\n\n        } else {\n\n            editor.modules.toolbar.toolbox.close();\n\n        }\n\n    };\n\n    /**\n     * Block handlers for KeyDown events\n     *\n     * @protected\n     * @param {Object} event\n     *\n     * Handles keydowns on block\n     * @see blockRightOrDownArrowPressed_\n     * @see backspacePressed_\n     * @see blockLeftOrUpArrowPressed_\n     */\n    callbacks.blockKeydown = function (event) {\n\n        let block = event.target; // event.target is input\n\n        switch (event.keyCode) {\n\n            case editor.modules.core.keys.DOWN:\n            case editor.modules.core.keys.RIGHT:\n                blockRightOrDownArrowPressed_(event);\n                break;\n\n            case editor.modules.core.keys.BACKSPACE:\n                backspacePressed_(block, event);\n                break;\n\n            case editor.modules.core.keys.UP:\n            case editor.modules.core.keys.LEFT:\n                blockLeftOrUpArrowPressed_(event);\n                break;\n\n        }\n\n    };\n\n    /**\n     * RIGHT or DOWN keydowns on block\n     *\n     * @param {Object} event\n     * @private\n     *\n     * @description watches the selection and gets closest editable element.\n     * Uses method getDeepestTextNodeFromPosition to get the last node of next block\n     * Sets caret if it is contenteditable\n     */\n    var blockRightOrDownArrowPressed_ = function (event) {\n\n        var selection   = window.getSelection(),\n            inputs      = editor.state.inputs,\n            focusedNode = selection.anchorNode,\n            focusedNodeHolder;\n\n        /** Check for caret existance */\n        if (!focusedNode) {\n\n            return false;\n\n        }\n\n        /** Looking for closest (parent) contentEditable element of focused node */\n        while (focusedNode.contentEditable != 'true') {\n\n            focusedNodeHolder = focusedNode.parentNode;\n            focusedNode       = focusedNodeHolder;\n\n        }\n\n        /** Input index in DOM level */\n        var editableElementIndex = 0;\n\n        while (focusedNode != inputs[editableElementIndex]) {\n\n            editableElementIndex ++;\n\n        }\n\n        /**\n         * Founded contentEditable element doesn't have childs\n         * Or maybe New created block\n         */\n        if (!focusedNode.textContent) {\n\n            editor.modules.caret.setToNextBlock(editableElementIndex);\n            return;\n\n        }\n\n        /**\n         * Do nothing when caret doesn not reaches the end of last child\n         */\n        var caretInLastChild    = false,\n            caretAtTheEndOfText = false;\n\n        var lastChild,\n            deepestTextnode;\n\n        lastChild = focusedNode.childNodes[focusedNode.childNodes.length - 1 ];\n\n        if (editor.core.isDomNode(lastChild)) {\n\n            deepestTextnode = editor.modules.content.getDeepestTextNodeFromPosition(lastChild, lastChild.childNodes.length);\n\n        } else {\n\n            deepestTextnode = lastChild;\n\n        }\n\n        caretInLastChild = selection.anchorNode == deepestTextnode;\n        caretAtTheEndOfText = deepestTextnode.length == selection.anchorOffset;\n\n        if ( !caretInLastChild  || !caretAtTheEndOfText ) {\n\n            editor.modules.core.log('arrow [down|right] : caret does not reached the end');\n            return false;\n\n        }\n\n        editor.modules.caret.setToNextBlock(editableElementIndex);\n\n    };\n\n    /**\n     * LEFT or UP keydowns on block\n     *\n     * @param {Object} event\n     * @private\n     *\n     * watches the selection and gets closest editable element.\n     * Uses method getDeepestTextNodeFromPosition to get the last node of previous block\n     * Sets caret if it is contenteditable\n     *\n     */\n    var blockLeftOrUpArrowPressed_ = function (event) {\n\n        var selection   = window.getSelection(),\n            inputs      = editor.state.inputs,\n            focusedNode = selection.anchorNode,\n            focusedNodeHolder;\n\n        /** Check for caret existance */\n        if (!focusedNode) {\n\n            return false;\n\n        }\n\n        /**\n         * LEFT or UP not at the beginning\n         */\n        if ( selection.anchorOffset !== 0) {\n\n            return false;\n\n        }\n\n        /** Looking for parent contentEditable block */\n        while (focusedNode.contentEditable != 'true') {\n\n            focusedNodeHolder = focusedNode.parentNode;\n            focusedNode       = focusedNodeHolder;\n\n        }\n\n        /** Input index in DOM level */\n        var editableElementIndex = 0;\n\n        while (focusedNode != inputs[editableElementIndex]) {\n\n            editableElementIndex ++;\n\n        }\n\n        /**\n         * Do nothing if caret is not at the beginning of first child\n         */\n        var caretInFirstChild   = false,\n            caretAtTheBeginning = false;\n\n        var firstChild,\n            deepestTextnode;\n\n        /**\n         * Founded contentEditable element doesn't have childs\n         * Or maybe New created block\n         */\n        if (!focusedNode.textContent) {\n\n            editor.modules.caret.setToPreviousBlock(editableElementIndex);\n            return;\n\n        }\n\n        firstChild = focusedNode.childNodes[0];\n\n        if (editor.modules.core.isDomNode(firstChild)) {\n\n            deepestTextnode = editor.modules.content.getDeepestTextNodeFromPosition(firstChild, 0);\n\n        } else {\n\n            deepestTextnode = firstChild;\n\n        }\n\n        caretInFirstChild   = selection.anchorNode == deepestTextnode;\n        caretAtTheBeginning = selection.anchorOffset === 0;\n\n        if ( caretInFirstChild && caretAtTheBeginning ) {\n\n            editor.modules.caret.setToPreviousBlock(editableElementIndex);\n\n        }\n\n    };\n\n    /**\n     * Handles backspace keydown\n     *\n     * @param {Element} block\n     * @param {Object} event\n     * @private\n     *\n     * @description if block is empty, delete the block and set caret to the previous block\n     * If block is not empty, try to merge two blocks - current and previous\n     * But it we try'n to remove first block, then we should set caret to the next block, not previous.\n     * If we removed the last block, create new one\n     */\n    var backspacePressed_ = function (block, event) {\n\n        var currentInputIndex = editor.modules.caret.getCurrentInputIndex(),\n            range,\n            selectionLength,\n            firstLevelBlocksCount;\n\n        if (editor.modules.core.isNativeInput(event.target)) {\n\n            /** If input value is empty - remove block */\n            if (event.target.value.trim() == '') {\n\n                block.remove();\n\n            } else {\n\n                return;\n\n            }\n\n        }\n\n        if (block.textContent.trim()) {\n\n            range           = editor.modules.content.getRange();\n            selectionLength = range.endOffset - range.startOffset;\n\n            if (editor.modules.caret.position.atStart() && !selectionLength && editor.state.inputs[currentInputIndex - 1]) {\n\n                editor.modules.content.mergeBlocks(currentInputIndex);\n\n            } else {\n\n                return;\n\n            }\n\n        }\n\n        if (!selectionLength) {\n\n            block.remove();\n\n        }\n\n\n        firstLevelBlocksCount = editor.nodes.redactor.childNodes.length;\n\n        /**\n         * If all blocks are removed\n         */\n        if (firstLevelBlocksCount === 0) {\n\n            /** update currentNode variable */\n            editor.modules.content.currentNode = null;\n\n            /** Inserting new empty initial block */\n            editor.modules.ui.addInitialBlock();\n\n            /** Updating inputs state after deleting last block */\n            editor.modules.ui.saveInputs();\n\n            /** Set to current appended block */\n            window.setTimeout(function () {\n\n                editor.modules.caret.setToPreviousBlock(1);\n\n            }, 10);\n\n        } else {\n\n            if (editor.modules.caret.inputIndex !== 0) {\n\n                /** Target block is not first */\n                editor.modules.caret.setToPreviousBlock(editor.modules.caret.inputIndex);\n\n            } else {\n\n                /** If we try to delete first block */\n                editor.modules.caret.setToNextBlock(editor.modules.caret.inputIndex);\n\n            }\n\n        }\n\n        editor.modules.toolbar.move();\n\n        if (!editor.modules.toolbar.opened) {\n\n            editor.modules.toolbar.open();\n\n        }\n\n        /** Updating inputs state */\n        editor.modules.ui.saveInputs();\n\n        /** Prevent default browser behaviour */\n        event.preventDefault();\n\n    };\n\n    /**\n     * used by UI module\n     * Clicks on block settings button\n     *\n     * @param {Object} event\n     * @protected\n     * @description Opens toolbar settings\n     */\n    callbacks.showSettingsButtonClicked = function (event) {\n\n        /**\n         * Get type of current block\n         * It uses to append settings from tool.settings property.\n         * ...\n         * Type is stored in data-type attribute on block\n         */\n        var currentTool = editor.modules.content.currentNode.childNodes[0].childNodes[0].tool;\n\n        editor.modules.toolbar.settings.toggle(currentTool);\n\n        /** Close toolbox when settings button is active */\n        editor.modules.toolbar.toolbox.close();\n        editor.modules.toolbar.settings.hideRemoveActions();\n\n    };\n\n    return callbacks;\n\n});\n\n\n// WEBPACK FOOTER //\n// ./modules/callbacks.js","/**\n * Codex Editor Draw module\n *\n * @author Codex Team\n * @version 1.0.\n */\n\nmodule.exports = (function () {\n\n    let draw = {};\n\n    /**\n     * Base editor wrapper\n     */\n    draw.wrapper = function () {\n\n        var wrapper = document.createElement('div');\n\n        wrapper.className += 'codex-editor';\n\n        return wrapper;\n\n    };\n\n    /**\n     * Content-editable holder\n     */\n    draw.redactor = function () {\n\n        var redactor = document.createElement('div');\n\n        redactor.className += 'ce-redactor';\n\n        return redactor;\n\n    };\n\n    draw.ceBlock = function () {\n\n        var block = document.createElement('DIV');\n\n        block.className += 'ce_block';\n\n        return block;\n\n    };\n\n    /**\n     * Empty toolbar with toggler\n     */\n    draw.toolbar = function () {\n\n        var bar = document.createElement('div');\n\n        bar.className += 'ce-toolbar';\n\n        return bar;\n\n    };\n\n    draw.toolbarContent = function () {\n\n        var wrapper = document.createElement('DIV');\n\n        wrapper.classList.add('ce-toolbar__content');\n\n        return wrapper;\n\n    };\n\n    /**\n     * Inline toolbar\n     */\n    draw.inlineToolbar = function () {\n\n        var bar = document.createElement('DIV');\n\n        bar.className += 'ce-toolbar-inline';\n\n        return bar;\n\n    };\n\n    /**\n     * Wrapper for inline toobar buttons\n     */\n    draw.inlineToolbarButtons = function () {\n\n        var wrapper = document.createElement('DIV');\n\n        wrapper.className += 'ce-toolbar-inline__buttons';\n\n        return wrapper;\n\n    };\n\n    /**\n     * For some actions\n     */\n    draw.inlineToolbarActions = function () {\n\n        var wrapper = document.createElement('DIV');\n\n        wrapper.className += 'ce-toolbar-inline__actions';\n\n        return wrapper;\n\n    };\n\n    draw.inputForLink = function () {\n\n        var input = document.createElement('INPUT');\n\n        input.type        = 'input';\n        input.className  += 'inputForLink';\n        input.placeholder = 'Вставьте ссылку ...';\n        input.setAttribute('form', 'defaultForm');\n\n        input.setAttribute('autofocus', 'autofocus');\n\n        return input;\n\n    };\n\n    /**\n     * @todo Desc\n     */\n    draw.blockButtons = function () {\n\n        var block = document.createElement('div');\n\n        block.className += 'ce-toolbar__actions';\n\n        return block;\n\n    };\n\n    /**\n     * Block settings panel\n     */\n    draw.blockSettings = function () {\n\n        var settings = document.createElement('div');\n\n        settings.className += 'ce-settings';\n\n        return settings;\n\n    };\n\n    draw.defaultSettings = function () {\n\n        var div = document.createElement('div');\n\n        div.classList.add('ce-settings_default');\n\n        return div;\n\n    };\n\n    draw.pluginsSettings = function () {\n\n        var div = document.createElement('div');\n\n        div.classList.add('ce-settings_plugin');\n\n        return div;\n\n    };\n\n    draw.plusButton = function () {\n\n        var button = document.createElement('span');\n\n        button.className = 'ce-toolbar__plus';\n        // button.innerHTML = '<i class=\"ce-icon-plus\"></i>';\n\n        return button;\n\n    };\n\n    /**\n     * Settings button in toolbar\n     */\n    draw.settingsButton = function () {\n\n        var toggler = document.createElement('span');\n\n        toggler.className = 'ce-toolbar__settings-btn';\n\n        /** Toggler button*/\n        toggler.innerHTML = '<i class=\"ce-icon-cog\"></i>';\n\n        return toggler;\n\n    };\n\n    /**\n     * Redactor tools wrapper\n     */\n\n    draw.toolbox = function () {\n\n        var wrapper = document.createElement('div');\n\n        wrapper.className = 'ce-toolbar__tools';\n\n        return wrapper;\n\n    };\n\n    /**\n     * @protected\n     *\n     * Draws tool buttons for toolbox\n     *\n     * @param {String} type\n     * @param {String} classname\n     * @returns {Element}\n     */\n    draw.toolbarButton = function (type, classname) {\n\n        var button     = document.createElement('li'),\n            toolIcon  = document.createElement('i'),\n            toolTitle = document.createElement('span');\n\n        button.dataset.type = type;\n        button.setAttribute('title', type);\n\n        toolIcon.classList.add(classname);\n        toolTitle.classList.add('ce_toolbar_tools--title');\n\n\n        button.appendChild(toolIcon);\n        button.appendChild(toolTitle);\n\n        return button;\n\n    };\n\n    /**\n     * @protected\n     *\n     * Draws tools for inline toolbar\n     *\n     * @param {String} type\n     * @param {String} classname\n     */\n    draw.toolbarButtonInline = function (type, classname) {\n\n        var button     = document.createElement('BUTTON'),\n            toolIcon  = document.createElement('I');\n\n        button.type = 'button';\n        button.dataset.type = type;\n        toolIcon.classList.add(classname);\n\n        button.appendChild(toolIcon);\n\n        return button;\n\n    };\n\n    /**\n     * Redactor block\n     */\n    draw.block = function (tagName, content) {\n\n        var node = document.createElement(tagName);\n\n        node.innerHTML = content || '';\n\n        return node;\n\n    };\n\n    /**\n     * Creates Node with passed tagName and className\n     * @param {string}  tagName\n     * @param {string} className\n     * @param {object} properties - allow to assign properties\n     */\n    draw.node = function ( tagName, className, properties ) {\n\n        var el = document.createElement( tagName );\n\n        if ( className ) el.className = className;\n\n        if ( properties ) {\n\n            for (var name in properties) {\n\n                el[name] = properties[name];\n\n            }\n\n        }\n\n        return el;\n\n    };\n\n    /**\n    * Unavailable plugin block\n    */\n    draw.unavailableBlock = function () {\n\n        var wrapper = document.createElement('DIV');\n\n        wrapper.classList.add('cdx-unavailable-block');\n\n        return wrapper;\n\n    };\n\n    return draw;\n\n});\n\n\n// WEBPACK FOOTER //\n// ./modules/draw.js","/**\n * Codex Editor Caret Module\n *\n * @author Codex Team\n * @version 1.0\n */\n\nmodule.exports = (function () {\n\n    let caret = {};\n\n    let editor = this;\n\n    /**\n     * @var {int} InputIndex - editable element in DOM\n     */\n    caret.inputIndex = null;\n\n    /**\n     * @var {int} offset - caret position in a text node.\n     */\n    caret.offset = null;\n\n    /**\n     * @var {int} focusedNodeIndex - we get index of child node from first-level block\n     */\n    caret.focusedNodeIndex = null;\n\n    /**\n     * Creates Document Range and sets caret to the element.\n     * @protected\n     * @uses caret.save — if you need to save caret position\n     * @param {Element} el - Changed Node.\n     */\n    caret.set = function ( el, index, offset) {\n\n        offset = offset || caret.offset || 0;\n        index  = index  || caret.focusedNodeIndex || 0;\n\n        var childs = el.childNodes,\n            nodeToSet;\n\n        if ( childs.length === 0 ) {\n\n            nodeToSet = el;\n\n        } else {\n\n            nodeToSet = childs[index];\n\n        }\n\n        /** If Element is INPUT */\n        if (el.contentEditable != 'true') {\n\n            el.focus();\n            return;\n\n        }\n\n        if (editor.modules.core.isDomNode(nodeToSet)) {\n\n            nodeToSet = editor.modules.content.getDeepestTextNodeFromPosition(nodeToSet, nodeToSet.childNodes.length);\n\n        }\n\n        var range     = document.createRange(),\n            selection = window.getSelection();\n\n        window.setTimeout(function () {\n\n            range.setStart(nodeToSet, offset);\n            range.setEnd(nodeToSet, offset);\n\n            selection.removeAllRanges();\n            selection.addRange(range);\n\n            editor.modules.caret.saveCurrentInputIndex();\n\n        }, 20);\n\n    };\n\n    /**\n     * @protected\n     * Updates index of input and saves it in caret object\n     */\n    caret.saveCurrentInputIndex = function () {\n\n        /** Index of Input that we paste sanitized content */\n        var selection   = window.getSelection(),\n            inputs      = editor.state.inputs,\n            focusedNode = selection.anchorNode,\n            focusedNodeHolder;\n\n        if (!focusedNode) {\n\n            return;\n\n        }\n\n        /** Looking for parent contentEditable block */\n        while (focusedNode.contentEditable != 'true') {\n\n            focusedNodeHolder = focusedNode.parentNode;\n            focusedNode       = focusedNodeHolder;\n\n        }\n\n        /** Input index in DOM level */\n        var editableElementIndex = 0;\n\n        while (focusedNode != inputs[editableElementIndex]) {\n\n            editableElementIndex ++;\n\n        }\n\n        caret.inputIndex = editableElementIndex;\n\n    };\n\n    /**\n     * Returns current input index (caret object)\n     */\n    caret.getCurrentInputIndex = function () {\n\n        return caret.inputIndex;\n\n    };\n\n    /**\n     * @param {int} index - index of first-level block after that we set caret into next input\n     */\n    caret.setToNextBlock = function (index) {\n\n        var inputs = editor.state.inputs,\n            nextInput = inputs[index + 1];\n\n        if (!nextInput) {\n\n            editor.modules.core.log('We are reached the end');\n            return;\n\n        }\n\n        /**\n         * When new Block created or deleted content of input\n         * We should add some text node to set caret\n         */\n        if (!nextInput.childNodes.length) {\n\n            var emptyTextElement = document.createTextNode('');\n\n            nextInput.appendChild(emptyTextElement);\n\n        }\n\n        editor.modules.caret.inputIndex = index + 1;\n        editor.modules.caret.set(nextInput, 0, 0);\n        editor.modules.content.workingNodeChanged(nextInput);\n\n    };\n\n    /**\n     * @param {int} index - index of target input.\n     * Sets caret to input with this index\n     */\n    caret.setToBlock = function (index) {\n\n        var inputs = editor.state.inputs,\n            targetInput = inputs[index];\n\n        if ( !targetInput ) {\n\n            return;\n\n        }\n\n        /**\n         * When new Block created or deleted content of input\n         * We should add some text node to set caret\n         */\n        if (!targetInput.childNodes.length) {\n\n            var emptyTextElement = document.createTextNode('');\n\n            targetInput.appendChild(emptyTextElement);\n\n        }\n\n        editor.modules.caret.inputIndex = index;\n        editor.modules.caret.set(targetInput, 0, 0);\n        editor.modules.content.workingNodeChanged(targetInput);\n\n    };\n\n    /**\n     * @param {int} index - index of input\n     */\n    caret.setToPreviousBlock = function (index) {\n\n        index = index || 0;\n\n        var inputs = editor.state.inputs,\n            previousInput = inputs[index - 1],\n            lastChildNode,\n            lengthOfLastChildNode,\n            emptyTextElement;\n\n\n        if (!previousInput) {\n\n            editor.modules.core.log('We are reached first node');\n            return;\n\n        }\n\n        lastChildNode = editor.modules.content.getDeepestTextNodeFromPosition(previousInput, previousInput.childNodes.length);\n        lengthOfLastChildNode = lastChildNode.length;\n\n        /**\n         * When new Block created or deleted content of input\n         * We should add some text node to set caret\n         */\n        if (!previousInput.childNodes.length) {\n\n            emptyTextElement = document.createTextNode('');\n            previousInput.appendChild(emptyTextElement);\n\n        }\n        editor.modules.caret.inputIndex = index - 1;\n        editor.modules.caret.set(previousInput, previousInput.childNodes.length - 1, lengthOfLastChildNode);\n        editor.modules.content.workingNodeChanged(inputs[index - 1]);\n\n    };\n\n    caret.position = {\n\n        atStart : function () {\n\n            var selection       = window.getSelection(),\n                anchorOffset    = selection.anchorOffset,\n                anchorNode      = selection.anchorNode,\n                firstLevelBlock = editor.modules.content.getFirstLevelBlock(anchorNode),\n                pluginsRender   = firstLevelBlock.childNodes[0];\n\n            if (!editor.modules.core.isDomNode(anchorNode)) {\n\n                anchorNode = anchorNode.parentNode;\n\n            }\n\n            var isFirstNode  = anchorNode === pluginsRender.childNodes[0],\n                isOffsetZero = anchorOffset === 0;\n\n            return isFirstNode && isOffsetZero;\n\n        },\n\n        atTheEnd : function () {\n\n            var selection    = window.getSelection(),\n                anchorOffset = selection.anchorOffset,\n                anchorNode   = selection.anchorNode;\n\n            /** Caret is at the end of input */\n            return !anchorNode || !anchorNode.length || anchorOffset === anchorNode.length;\n\n        }\n    };\n\n\n    /**\n     * Inserts node at the caret location\n     * @param {HTMLElement|DocumentFragment} node\n     */\n    caret.insertNode = function (node) {\n\n        var selection, range,\n            lastNode = node;\n\n        if (node.nodeType == editor.modules.core.nodeTypes.DOCUMENT_FRAGMENT) {\n\n            lastNode = node.lastChild;\n\n        }\n\n        selection = window.getSelection();\n\n        range = selection.getRangeAt(0);\n        range.deleteContents();\n\n        range.insertNode(node);\n\n        range.setStartAfter(lastNode);\n        range.collapse(true);\n\n        selection.removeAllRanges();\n        selection.addRange(range);\n\n\n    };\n\n    return caret;\n\n});\n\n\n// WEBPACK FOOTER //\n// ./modules/caret.js","/**\n * Codex Editor Notification Module\n *\n * @author Codex Team\n * @version 1.0\n */\n\nmodule.exports = (function () {\n\n    let notifications = {};\n\n    let editor = this;\n\n    var queue = [];\n\n    var addToQueue = function (settings) {\n\n        queue.push(settings);\n\n        var index = 0;\n\n        while ( index < queue.length && queue.length > 5) {\n\n            if (queue[index].type == 'confirm' || queue[index].type == 'prompt') {\n\n                index++;\n                continue;\n\n            }\n\n            queue[index].close();\n            queue.splice(index, 1);\n\n        }\n\n    };\n\n    notifications.createHolder = function () {\n\n        var holder = editor.modules.draw.node('DIV', 'cdx-notifications-block');\n\n        editor.nodes.notifications = document.body.appendChild(holder);\n\n        return holder;\n\n    };\n\n\n    /**\n     * Error notificator. Shows block with message\n     * @protected\n     */\n    notifications.errorThrown = function (errorMsg, event) {\n\n        editor.modules.notifications.notification({message: 'This action is not available currently', type: event.type});\n\n    };\n\n    /**\n     *\n     * Appends notification\n     *\n     *  settings = {\n     *      type        - notification type (reserved types: alert, confirm, prompt). Just add class 'cdx-notification-'+type\n     *      message     - notification message\n     *      okMsg       - confirm button text (default - 'Ok')\n     *      cancelBtn   - cancel button text (default - 'Cancel'). Only for confirm and prompt types\n     *      confirm     - function-handler for ok button click\n     *      cancel      - function-handler for cancel button click. Only for confirm and prompt types\n     *      time        - time (in seconds) after which notification will close (default - 10s)\n     *  }\n     *\n     * @param settings\n     */\n    notifications.notification = function (constructorSettings) {\n\n        /** Private vars and methods */\n        var notification = null,\n            cancel       = null,\n            type         = null,\n            confirm      = null,\n            inputField   = null;\n\n        var confirmHandler = function () {\n\n            close();\n\n            if (typeof confirm !== 'function' ) {\n\n                return;\n\n            }\n\n            if (type == 'prompt') {\n\n                confirm(inputField.value);\n                return;\n\n            }\n\n            confirm();\n\n        };\n\n        var cancelHandler = function () {\n\n            close();\n\n            if (typeof cancel !== 'function' ) {\n\n                return;\n\n            }\n\n            cancel();\n\n        };\n\n\n        /** Public methods */\n        function create(settings) {\n\n            if (!(settings && settings.message)) {\n\n                editor.modules.core.log('Can\\'t create notification. Message is missed');\n                return;\n\n            }\n\n            settings.type = settings.type || 'alert';\n            settings.time = settings.time*1000 || 10000;\n\n            var wrapper = editor.modules.draw.node('DIV', 'cdx-notification'),\n                message = editor.modules.draw.node('DIV', 'cdx-notification__message'),\n                input = editor.modules.draw.node('INPUT', 'cdx-notification__input'),\n                okBtn = editor.modules.draw.node('SPAN', 'cdx-notification__ok-btn'),\n                cancelBtn = editor.modules.draw.node('SPAN', 'cdx-notification__cancel-btn');\n\n            message.textContent = settings.message;\n            okBtn.textContent = settings.okMsg || 'ОК';\n            cancelBtn.textContent = settings.cancelMsg || 'Отмена';\n\n            editor.modules.listeners.add(okBtn, 'click', confirmHandler);\n            editor.modules.listeners.add(cancelBtn, 'click', cancelHandler);\n\n            wrapper.appendChild(message);\n\n            if (settings.type == 'prompt') {\n\n                wrapper.appendChild(input);\n\n            }\n\n            wrapper.appendChild(okBtn);\n\n            if (settings.type == 'prompt' || settings.type == 'confirm') {\n\n                wrapper.appendChild(cancelBtn);\n\n            }\n\n            wrapper.classList.add('cdx-notification-' + settings.type);\n            wrapper.dataset.type = settings.type;\n\n            notification = wrapper;\n            type         = settings.type;\n            confirm      = settings.confirm;\n            cancel       = settings.cancel;\n            inputField   = input;\n\n            if (settings.type != 'prompt' && settings.type != 'confirm') {\n\n                window.setTimeout(close, settings.time);\n\n            }\n\n        };\n\n        function send() {\n\n            editor.nodes.notifications.appendChild(notification);\n            inputField.focus();\n\n            editor.nodes.notifications.classList.add('cdx-notification__notification-appending');\n\n            window.setTimeout(function () {\n\n                editor.nodes.notifications.classList.remove('cdx-notification__notification-appending');\n\n            }, 100);\n\n            addToQueue({type: type, close: close});\n\n        };\n\n        function close() {\n\n            notification.remove();\n\n        };\n\n\n        if (constructorSettings) {\n\n            create(constructorSettings);\n            send();\n\n        }\n\n        return {\n            create: create,\n            send: send,\n            close: close\n        };\n\n    };\n\n    notifications.clear = function () {\n\n        editor.nodes.notifications.innerHTML = '';\n        queue = [];\n\n    };\n\n    return notifications;\n\n});\n\n\n// WEBPACK FOOTER //\n// ./modules/notifications.js","/**\n * Codex Editor Parser Module\n *\n * @author Codex Team\n * @version 1.1\n */\n\nmodule.exports = (function () {\n\n    let parser = {};\n\n    let editor = this;\n\n    /** inserting text */\n    parser.insertPastedContent = function (blockType, tag) {\n\n        editor.modules.content.insertBlock({\n            type :  blockType.type,\n            block : blockType.render({\n                text : tag.innerHTML\n            })\n        });\n\n    };\n\n    /**\n     * Check DOM node for display style: separated block or child-view\n     */\n    parser.isFirstLevelBlock = function (node) {\n\n        return node.nodeType == editor.modules.core.nodeTypes.TAG &&\n            node.classList.contains(editor.modules.ui.className.BLOCK_CLASSNAME);\n\n    };\n\n    return parser;\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./modules/parser.js","/**\n * Codex Sanitizer\n */\n\nmodule.exports = (function () {\n\n    let sanitizer = {};\n\n    /** HTML Janitor library */\n    let janitor = require('html-janitor');\n\n    /** Codex Editor */\n    let editor  = this;\n\n    sanitizer.prepare = function () {\n\n        if (editor.settings.sanitizer && !editor.modules.core.isEmpty(editor.settings.sanitizer)) {\n\n            Config.CUSTOM = editor.settings.sanitizer;\n\n        }\n\n    };\n\n    /**\n     * Basic config\n     */\n    var Config = {\n\n        /** User configuration */\n        CUSTOM : null,\n\n        BASIC : {\n\n            tags: {\n                p: {},\n                a: {\n                    href: true,\n                    target: '_blank',\n                    rel: 'nofollow'\n                }\n            }\n        }\n    };\n\n    sanitizer.Config = Config;\n\n    /**\n     *\n     * @param userCustomConfig\n     * @returns {*}\n     * @private\n     *\n     * @description If developer uses editor's API, then he can customize sane restrictions.\n     * Or, sane config can be defined globally in editors initialization. That config will be used everywhere\n     * At least, if there is no config overrides, that API uses BASIC Default configation\n     */\n    let init_ = function (userCustomConfig) {\n\n        let configuration = userCustomConfig || Config.CUSTOM || Config.BASIC;\n\n        return new janitor(configuration);\n\n    };\n\n    /**\n     * Cleans string from unwanted tags\n     * @protected\n     * @param {String} dirtyString - taint string\n     * @param {Object} customConfig - allowed tags\n     */\n    sanitizer.clean = function (dirtyString, customConfig) {\n\n        let janitorInstance = init_(customConfig);\n\n        return janitorInstance.clean(dirtyString);\n\n    };\n\n    return sanitizer;\n\n});\n\n\n// WEBPACK FOOTER //\n// ./modules/sanitizer.js","(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define('html-janitor', factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.HTMLJanitor = factory();\n  }\n}(this, function () {\n\n  /**\n   * @param {Object} config.tags Dictionary of allowed tags.\n   * @param {boolean} config.keepNestedBlockElements Default false.\n   */\n  function HTMLJanitor(config) {\n\n    var tagDefinitions = config['tags'];\n    var tags = Object.keys(tagDefinitions);\n\n    var validConfigValues = tags\n      .map(function(k) { return typeof tagDefinitions[k]; })\n      .every(function(type) { return type === 'object' || type === 'boolean' || type === 'function'; });\n\n    if(!validConfigValues) {\n      throw new Error(\"The configuration was invalid\");\n    }\n\n    this.config = config;\n  }\n\n  // TODO: not exhaustive?\n  var blockElementNames = ['P', 'LI', 'TD', 'TH', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'PRE'];\n  function isBlockElement(node) {\n    return blockElementNames.indexOf(node.nodeName) !== -1;\n  }\n\n  var inlineElementNames = ['A', 'B', 'STRONG', 'I', 'EM', 'SUB', 'SUP', 'U', 'STRIKE'];\n  function isInlineElement(node) {\n    return inlineElementNames.indexOf(node.nodeName) !== -1;\n  }\n\n  HTMLJanitor.prototype.clean = function (html) {\n    var sandbox = document.createElement('div');\n    sandbox.innerHTML = html;\n\n    this._sanitize(sandbox);\n\n    return sandbox.innerHTML;\n  };\n\n  HTMLJanitor.prototype._sanitize = function (parentNode) {\n    var treeWalker = createTreeWalker(parentNode);\n    var node = treeWalker.firstChild();\n    if (!node) { return; }\n\n    do {\n      // Ignore nodes that have already been sanitized\n      if (node._sanitized) {\n        continue;\n      }\n\n      if (node.nodeType === Node.TEXT_NODE) {\n        // If this text node is just whitespace and the previous or next element\n        // sibling is a block element, remove it\n        // N.B.: This heuristic could change. Very specific to a bug with\n        // `contenteditable` in Firefox: http://jsbin.com/EyuKase/1/edit?js,output\n        // FIXME: make this an option?\n        if (node.data.trim() === ''\n            && ((node.previousElementSibling && isBlockElement(node.previousElementSibling))\n                 || (node.nextElementSibling && isBlockElement(node.nextElementSibling)))) {\n          parentNode.removeChild(node);\n          this._sanitize(parentNode);\n          break;\n        } else {\n          continue;\n        }\n      }\n\n      // Remove all comments\n      if (node.nodeType === Node.COMMENT_NODE) {\n        parentNode.removeChild(node);\n        this._sanitize(parentNode);\n        break;\n      }\n\n      var isInline = isInlineElement(node);\n      var containsBlockElement;\n      if (isInline) {\n        containsBlockElement = Array.prototype.some.call(node.childNodes, isBlockElement);\n      }\n\n      // Block elements should not be nested (e.g. <li><p>...); if\n      // they are, we want to unwrap the inner block element.\n      var isNotTopContainer = !! parentNode.parentNode;\n      var isNestedBlockElement =\n            isBlockElement(parentNode) &&\n            isBlockElement(node) &&\n            isNotTopContainer;\n\n      var nodeName = node.nodeName.toLowerCase();\n\n      var allowedAttrs = getAllowedAttrs(this.config, nodeName, node);\n\n      var isInvalid = isInline && containsBlockElement;\n\n      // Drop tag entirely according to the whitelist *and* if the markup\n      // is invalid.\n      if (isInvalid || shouldRejectNode(node, allowedAttrs)\n          || (!this.config.keepNestedBlockElements && isNestedBlockElement)) {\n        // Do not keep the inner text of SCRIPT/STYLE elements.\n        if (! (node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE')) {\n          while (node.childNodes.length > 0) {\n            parentNode.insertBefore(node.childNodes[0], node);\n          }\n        }\n        parentNode.removeChild(node);\n\n        this._sanitize(parentNode);\n        break;\n      }\n\n      // Sanitize attributes\n      for (var a = 0; a < node.attributes.length; a += 1) {\n        var attr = node.attributes[a];\n\n        if (shouldRejectAttr(attr, allowedAttrs, node)) {\n          node.removeAttribute(attr.name);\n          // Shift the array to continue looping.\n          a = a - 1;\n        }\n      }\n\n      // Sanitize children\n      this._sanitize(node);\n\n      // Mark node as sanitized so it's ignored in future runs\n      node._sanitized = true;\n    } while ((node = treeWalker.nextSibling()));\n  };\n\n  function createTreeWalker(node) {\n    return document.createTreeWalker(node,\n                                     NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,\n                                     null, false);\n  }\n\n  function getAllowedAttrs(config, nodeName, node){\n    if (typeof config.tags[nodeName] === 'function') {\n      return config.tags[nodeName](node);\n    } else {\n      return config.tags[nodeName];\n    }\n  }\n\n  function shouldRejectNode(node, allowedAttrs){\n    if (typeof allowedAttrs === 'undefined') {\n      return true;\n    } else if (typeof allowedAttrs === 'boolean') {\n      return !allowedAttrs;\n    }\n\n    return false;\n  }\n\n  function shouldRejectAttr(attr, allowedAttrs, node){\n    var attrName = attr.name.toLowerCase();\n\n    if (allowedAttrs === true){\n      return false;\n    } else if (typeof allowedAttrs[attrName] === 'function'){\n      return !allowedAttrs[attrName](attr.value, node);\n    } else if (typeof allowedAttrs[attrName] === 'undefined'){\n      return true;\n    } else if (allowedAttrs[attrName] === false) {\n      return true;\n    } else if (typeof allowedAttrs[attrName] === 'string') {\n      return (allowedAttrs[attrName] !== attr.value);\n    }\n\n    return false;\n  }\n\n  return HTMLJanitor;\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/html-janitor/src/html-janitor.js\n// module id = 18\n// module chunks = 0","/**\n * Codex Editor Listeners module\n *\n * @author Codex Team\n * @version 1.0\n */\n\n/**\n * Module-decorator for event listeners assignment\n */\nmodule.exports = function () {\n\n    let listeners = {};\n\n    var allListeners = [];\n\n    /**\n     * Search methods\n     *\n     * byElement, byType and byHandler returns array of suitable listeners\n     * one and all takes element, eventType, and handler and returns first (all) suitable listener\n     *\n     */\n    listeners.search = function () {\n\n        var byElement = function (element, context) {\n\n            var listenersOnElement = [];\n\n            context = context || allListeners;\n\n            for (var i = 0; i < context.length; i++) {\n\n                var listener = context[i];\n\n                if (listener.element === element) {\n\n                    listenersOnElement.push(listener);\n\n                }\n\n            }\n\n            return listenersOnElement;\n\n        };\n\n        var byType = function (eventType, context) {\n\n            var listenersWithType = [];\n\n            context = context || allListeners;\n\n            for (var i = 0; i < context.length; i++) {\n\n                var listener = context[i];\n\n                if (listener.type === eventType) {\n\n                    listenersWithType.push(listener);\n\n                }\n\n            }\n\n            return listenersWithType;\n\n        };\n\n        var byHandler = function (handler, context) {\n\n            var listenersWithHandler = [];\n\n            context = context || allListeners;\n\n            for (var i = 0; i < context.length; i++) {\n\n                var listener = context[i];\n\n                if (listener.handler === handler) {\n\n                    listenersWithHandler.push(listener);\n\n                }\n\n            }\n\n            return listenersWithHandler;\n\n        };\n\n        var one = function (element, eventType, handler) {\n\n            var result = allListeners;\n\n            if (element)\n                result = byElement(element, result);\n\n            if (eventType)\n                result = byType(eventType, result);\n\n            if (handler)\n                result = byHandler(handler, result);\n\n            return result[0];\n\n        };\n\n        var all = function (element, eventType, handler) {\n\n            var result = allListeners;\n\n            if (element)\n                result = byElement(element, result);\n\n            if (eventType)\n                result = byType(eventType, result);\n\n            if (handler)\n                result = byHandler(handler, result);\n\n            return result;\n\n        };\n\n        return {\n            byElement   : byElement,\n            byType      : byType,\n            byHandler   : byHandler,\n            one         : one,\n            all         : all\n        };\n\n    }();\n\n    listeners.add = function (element, eventType, handler, isCapture) {\n\n        element.addEventListener(eventType, handler, isCapture);\n\n        var data = {\n            element: element,\n            type: eventType,\n            handler: handler\n        };\n\n        var alreadyAddedListener = listeners.search.one(element, eventType, handler);\n\n        if (!alreadyAddedListener) {\n\n            allListeners.push(data);\n\n        }\n\n    };\n\n    listeners.remove = function (element, eventType, handler) {\n\n        element.removeEventListener(eventType, handler);\n\n        var existingListeners = listeners.search.all(element, eventType, handler);\n\n        for (var i = 0; i < existingListeners.length; i++) {\n\n            var index = allListeners.indexOf(existingListeners[i]);\n\n            if (index > 0) {\n\n                allListeners.splice(index, 1);\n\n            }\n\n        }\n\n    };\n\n    listeners.removeAll = function () {\n\n        allListeners.map(function (current) {\n\n            listeners.remove(current.element, current.type, current.handler);\n\n        });\n\n    };\n\n    listeners.get = function (element, eventType, handler) {\n\n        return listeners.search.all(element, eventType, handler);\n\n    };\n\n    return listeners;\n\n};\n\n\n// WEBPACK FOOTER //\n// ./modules/listeners.js","/**\n * Codex Editor Destroyer module\n *\n * @auhor Codex Team\n * @version 1.0\n */\n\nmodule.exports = function () {\n\n    let destroyer = {};\n\n    let editor = this;\n\n    destroyer.removeNodes = function () {\n\n        editor.nodes.wrapper.remove();\n        editor.nodes.notifications.remove();\n\n    };\n\n    destroyer.destroyPlugins = function () {\n\n        for (var tool in editor.tools) {\n\n            if (typeof editor.tools[tool].destroy === 'function') {\n\n                editor.tools[tool].destroy();\n\n            }\n\n        }\n\n    };\n\n    destroyer.destroyScripts = function () {\n\n        var scripts = document.getElementsByTagName('SCRIPT');\n\n        for (var i = 0; i < scripts.length; i++) {\n\n            if (scripts[i].id.indexOf(editor.scriptPrefix) + 1) {\n\n                scripts[i].remove();\n                i--;\n\n            }\n\n        }\n\n    };\n\n\n    /**\n     * Delete editor data from webpage.\n     * You should send settings argument with boolean flags:\n     * @param settings.ui- remove redactor event listeners and DOM nodes\n     * @param settings.scripts - remove redactor scripts from DOM\n     * @param settings.plugins - remove plugin's objects\n     * @param settings.core - remove editor core. You can remove core only if UI and scripts flags is true\n     * }\n     *\n     */\n    destroyer.destroy = function (settings) {\n\n        if (!settings || typeof settings !== 'object') {\n\n            return;\n\n        }\n\n        if (settings.ui) {\n\n            destroyer.removeNodes();\n            editor.modules.listeners.removeAll();\n\n        }\n\n        if (settings.scripts) {\n\n            destroyer.destroyScripts();\n\n        }\n\n        if (settings.plugins) {\n\n            destroyer.destroyPlugins();\n\n        }\n\n        if (settings.ui && settings.scripts && settings.core) {\n\n            editor = null;\n\n        }\n\n    };\n\n    return destroyer;\n\n};\n\n\n// WEBPACK FOOTER //\n// ./modules/destroyer.js","/**\n * Codex Editor Paste module\n *\n * @author Codex Team\n * @version 1.1.1\n */\n\nmodule.exports = function () {\n\n    let paste = {};\n\n    let editor = this;\n\n    var patterns = [];\n\n    paste.prepare = function () {\n\n        var tools = editor.tools;\n\n        for (var tool in tools) {\n\n            if (!tools[tool].renderOnPastePatterns || !Array.isArray(tools[tool].renderOnPastePatterns)) {\n\n                continue;\n\n            }\n\n            tools[tool].renderOnPastePatterns.map(function (pattern) {\n\n\n                patterns.push(pattern);\n\n            });\n\n        }\n\n        return Promise.resolve();\n\n    };\n\n    /**\n     * Saves data\n     * @param event\n     */\n    paste.pasted = function (event) {\n\n        var clipBoardData = event.clipboardData || window.clipboardData,\n            content = clipBoardData.getData('Text');\n\n        var result = analize(content);\n\n        if (result) {\n\n            event.preventDefault();\n            event.stopImmediatePropagation();\n\n        }\n\n        return result;\n\n    };\n\n    /**\n     * Analizes pated string and calls necessary method\n     */\n\n    var analize = function (string) {\n\n        var result  = false,\n            content = editor.modules.content.currentNode,\n            plugin  = content.dataset.tool;\n\n        patterns.map( function (pattern) {\n\n            var execArray = pattern.regex.exec(string),\n                match     = execArray && execArray[0];\n\n            if ( match && match === string.trim()) {\n\n                /** current block is not empty */\n                if ( content.textContent.trim() && plugin == editor.settings.initialBlockPlugin ) {\n\n                    pasteToNewBlock_();\n\n                }\n\n                pattern.callback(string, pattern);\n                result = true;\n\n            }\n\n        });\n\n        return result;\n\n    };\n\n    var pasteToNewBlock_ = function () {\n\n        /** Create new initial block */\n        editor.modules.content.insertBlock({\n\n            type : editor.settings.initialBlockPlugin,\n            block : editor.tools[editor.settings.initialBlockPlugin].render({\n                text : ''\n            })\n\n        }, false);\n\n    };\n\n    /**\n     * This method prevents default behaviour.\n     *\n     * @param {Object} event\n     * @protected\n     *\n     * @description We get from clipboard pasted data, sanitize, make a fragment that contains of this sanitized nodes.\n     * Firstly, we need to memorize the caret position. We can do that by getting the range of selection.\n     * After all, we insert clear fragment into caret placed position. Then, we should move the caret to the last node\n     */\n    paste.blockPasteCallback = function (event) {\n\n\n        if (!needsToHandlePasteEvent(event.target)) {\n\n            return;\n\n        }\n\n        /** Prevent default behaviour */\n        event.preventDefault();\n\n        /** get html pasted data - dirty data */\n        var htmlData  = event.clipboardData.getData('text/html'),\n            plainData = event.clipboardData.getData('text/plain');\n\n        /** Temporary DIV that is used to work with text's paragraphs as DOM-elements*/\n        var paragraphs = editor.modules.draw.node('DIV', '', {}),\n            cleanData,\n            wrappedData;\n\n        /** Create fragment, that we paste to range after proccesing */\n        cleanData = editor.modules.sanitizer.clean(htmlData);\n\n        /**\n         * We wrap pasted text with <p> tags to split it logically\n         * @type {string}\n         */\n        wrappedData = editor.modules.content.wrapTextWithParagraphs(cleanData, plainData);\n        paragraphs.innerHTML = wrappedData;\n\n        /**\n         * If there only one paragraph, just insert in at the caret location\n         */\n        if (paragraphs.childNodes.length == 1) {\n\n            emulateUserAgentBehaviour(paragraphs.firstChild);\n            return;\n\n        }\n\n        insertPastedParagraphs(paragraphs.childNodes);\n\n    };\n\n    /**\n     * Checks if we should handle paste event on block\n     * @param block\n     *\n     * @return {boolean}\n     */\n    var needsToHandlePasteEvent = function (block) {\n\n        /** If area is input or textarea then allow default behaviour */\n        if ( editor.modules.core.isNativeInput(block) ) {\n\n            return false;\n\n        }\n\n        var editableParent = editor.modules.content.getEditableParent(block);\n\n        /** Allow paste when event target placed in Editable element */\n        if (!editableParent) {\n\n            return false;\n\n        }\n\n        return true;\n\n    };\n\n    /**\n     * Inserts new initial plugin blocks with data in paragraphs\n     *\n     * @param {Array} paragraphs - array of paragraphs (<p></p>) whit content, that should be inserted\n     */\n    var insertPastedParagraphs = function (paragraphs) {\n\n        var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin,\n            currentNode = editor.modules.content.currentNode;\n\n\n        paragraphs.forEach(function (paragraph) {\n\n            /** Don't allow empty paragraphs */\n            if (editor.modules.core.isBlockEmpty(paragraph)) {\n\n                return;\n\n            }\n\n            editor.modules.content.insertBlock({\n                type  : NEW_BLOCK_TYPE,\n                block : editor.tools[NEW_BLOCK_TYPE].render({\n                    text : paragraph.innerHTML\n                })\n            });\n\n            editor.modules.caret.inputIndex++;\n\n        });\n\n        editor.modules.caret.setToPreviousBlock(editor.modules.caret.getCurrentInputIndex() + 1);\n\n\n        /**\n         * If there was no data in working node, remove it\n         */\n        if (editor.modules.core.isBlockEmpty(currentNode)) {\n\n            currentNode.remove();\n            editor.modules.ui.saveInputs();\n\n        }\n\n\n    };\n\n    /**\n     * Inserts node content at the caret position\n     *\n     * @param {Node} node - DOM node (could be DocumentFragment), that should be inserted at the caret location\n     */\n    var emulateUserAgentBehaviour = function (node) {\n\n        var newNode;\n\n        if (node.childElementCount) {\n\n            newNode = document.createDocumentFragment();\n\n            node.childNodes.forEach(function (current) {\n\n                if (!editor.modules.core.isDomNode(current) && current.data.trim() === '') {\n\n                    return;\n\n                }\n\n                newNode.appendChild(current.cloneNode(true));\n\n            });\n\n        } else {\n\n            newNode = document.createTextNode(node.textContent);\n\n        }\n\n        editor.modules.caret.insertNode(newNode);\n\n    };\n\n\n    return paste;\n\n};\n\n\n// WEBPACK FOOTER //\n// ./modules/paste.js"],"sourceRoot":""}